def Balance.usd(self):
    self :: eth_portfolio.typing.Balance
    r0 :: object
L0:
    r0 = self.usd_value
    return r0

def Balance.__add__(self, other):
    self, other :: eth_portfolio.typing.Balance
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[object, None]
    r25 :: object
    r26 :: i32
    r27 :: bit
    r28 :: bool
    r29 :: str
    r30 :: union[object, None]
    r31, r32 :: str
    r33 :: union[object, None]
    r34, r35, r36 :: str
    r37 :: object
    r38 :: str
    r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42 :: object
    r43, r44 :: union[object, None]
    r45 :: object
    r46 :: i32
    r47 :: bit
    r48 :: bool
    r49 :: str
    r50 :: union[object, None]
    r51, r52 :: str
    r53 :: union[object, None]
    r54, r55, r56 :: str
    r57 :: object
    r58 :: str
    r59 :: object
    r60 :: object[1]
    r61 :: object_ptr
    r62, r63, r64, r65, r66, r67, r68 :: object
    r69, r70 :: union[object, None]
    r71 :: eth_portfolio.typing.Balance
    r72 :: tuple[object, object, object]
    r73 :: object
    r74 :: str
    r75 :: object
    r76 :: bit
    r77 :: object
    r78, r79, r80, r81, r82, r83, r84, r85 :: str
    r86 :: object
    r87 :: tuple
    r88 :: list
    r89, r90 :: ptr
    r91 :: object
    r92 :: tuple
    r93 :: str
    r94 :: i32
    r95, r96 :: bit
    r97 :: eth_portfolio.typing.Balance
L0:
    r0 = eth_portfolio.typing.Balance :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L50 (error at __add__:129) else goto L2
L2:
    r11 = ' is not a `Balance` object'
    r12 = PyList_New(2)
    if is_error(r12) goto L51 (error at __add__:129) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L50 (error at __add__:129) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L52 (error at __add__:129) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L52 (error at __add__:129) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L50 (error at __add__:129) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.token
    r24 = other.token
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L50 (error at __add__:130) else goto L9
L9:
    r26 = PyObject_IsTrue(r25)
    dec_ref r25
    r27 = r26 >= 0 :: signed
    if not r27 goto L50 (error at __add__:130) else goto L10 :: bool
L10:
    r28 = truncate r26: i32 to builtins.bool
    if r28 goto L11 else goto L18 :: bool
L11:
    r29 = 'These Balance objects represent balances of different tokens ('
    r30 = self.token
    r31 = PyObject_Str(r30)
    dec_ref r30
    if is_error(r31) goto L50 (error at __add__:132) else goto L12
L12:
    r32 = ' and '
    r33 = other.token
    r34 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r34) goto L53 (error at __add__:132) else goto L13
L13:
    r35 = ')'
    r36 = CPyStr_Build(5, r29, r31, r32, r34, r35)
    dec_ref r31
    dec_ref r34
    if is_error(r36) goto L50 (error at __add__:132) else goto L14
L14:
    r37 = builtins :: module
    r38 = 'ValueError'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L54 (error at __add__:131) else goto L15
L15:
    r40 = [r36]
    r41 = load_address r40
    r42 = _PyObject_Vectorcall(r39, r41, 1, 0)
    dec_ref r39
    if is_error(r42) goto L54 (error at __add__:131) else goto L16
L16:
    dec_ref r36
    CPy_Raise(r42)
    dec_ref r42
    if not 0 goto L50 (error at __add__:131) else goto L17 :: bool
L17:
    unreachable
L18:
    r43 = self.block
    r44 = other.block
    r45 = PyObject_RichCompare(r43, r44, 3)
    dec_ref r43
    dec_ref r44
    if is_error(r45) goto L50 (error at __add__:134) else goto L19
L19:
    r46 = PyObject_IsTrue(r45)
    dec_ref r45
    r47 = r46 >= 0 :: signed
    if not r47 goto L50 (error at __add__:134) else goto L20 :: bool
L20:
    r48 = truncate r46: i32 to builtins.bool
    if r48 goto L21 else goto L28 :: bool
L21:
    r49 = 'These Balance objects represent balances from different blocks ('
    r50 = self.block
    r51 = PyObject_Str(r50)
    dec_ref r50
    if is_error(r51) goto L50 (error at __add__:136) else goto L22
L22:
    r52 = ' and '
    r53 = other.block
    r54 = PyObject_Str(r53)
    dec_ref r53
    if is_error(r54) goto L55 (error at __add__:136) else goto L23
L23:
    r55 = ')'
    r56 = CPyStr_Build(5, r49, r51, r52, r54, r55)
    dec_ref r51
    dec_ref r54
    if is_error(r56) goto L50 (error at __add__:136) else goto L24
L24:
    r57 = builtins :: module
    r58 = 'ValueError'
    r59 = CPyObject_GetAttr(r57, r58)
    if is_error(r59) goto L56 (error at __add__:135) else goto L25
L25:
    r60 = [r56]
    r61 = load_address r60
    r62 = _PyObject_Vectorcall(r59, r61, 1, 0)
    dec_ref r59
    if is_error(r62) goto L56 (error at __add__:135) else goto L26
L26:
    dec_ref r56
    CPy_Raise(r62)
    dec_ref r62
    if not 0 goto L50 (error at __add__:135) else goto L27 :: bool
L27:
    unreachable
L28:
    r63 = self.balance
    r64 = other.balance
    r65 = PyNumber_Add(r63, r64)
    dec_ref r63
    dec_ref r64
    if is_error(r65) goto L32 (error at __add__:140) else goto L57
L29:
    r66 = self.usd_value
    r67 = other.usd_value
    r68 = PyNumber_Add(r66, r67)
    dec_ref r66
    dec_ref r67
    if is_error(r68) goto L32 (error at __add__:141) else goto L58
L30:
    r69 = self.token
    dec_ref r69
    r70 = self.block
    dec_ref r70
    r71 = Balance()
    if is_error(r71) goto L32 (error at __add__:139) else goto L31
L31:
    return r71
L32:
    r72 = CPy_CatchError()
    r73 = builtins :: module
    r74 = 'Exception'
    r75 = CPyObject_GetAttr(r73, r74)
    if is_error(r75) goto L48 (error at __add__:145) else goto L33
L33:
    r76 = CPy_ExceptionMatches(r75)
    dec_ref r75
    if r76 goto L34 else goto L46 :: bool
L34:
    r77 = CPy_GetExcValue()
    r78 = 'Cannot add '
    r79 = PyObject_Str(self)
    if is_error(r79) goto L59 (error at __add__:146) else goto L35
L35:
    r80 = ' and '
    r81 = PyObject_Str(other)
    if is_error(r81) goto L60 (error at __add__:146) else goto L36
L36:
    r82 = ': '
    r83 = PyObject_Str(r77)
    if is_error(r83) goto L61 (error at __add__:146) else goto L37
L37:
    r84 = CPyStr_Build(6, r78, r79, r80, r81, r82, r83)
    dec_ref r79
    dec_ref r81
    dec_ref r83
    if is_error(r84) goto L59 (error at __add__:146) else goto L38
L38:
    r85 = 'args'
    r86 = CPyObject_GetAttr(r77, r85)
    if is_error(r86) goto L62 (error at __add__:146) else goto L39
L39:
    r87 = cast(tuple, r86)
    if is_error(r87) goto L62 (error at __add__:146) else goto L40
L40:
    r88 = PyList_New(1)
    if is_error(r88) goto L63 (error at __add__:146) else goto L41
L41:
    r89 = get_element_ptr r88 ob_item :: PyListObject
    r90 = load_mem r89 :: ptr*
    set_mem r90, r84 :: builtins.object*
    r91 = CPyList_Extend(r88, r87)
    dec_ref r87
    if is_error(r91) goto L64 (error at __add__:146) else goto L65
L42:
    r92 = PyList_AsTuple(r88)
    dec_ref r88
    if is_error(r92) goto L59 (error at __add__:146) else goto L43
L43:
    r93 = 'args'
    r94 = PyObject_SetAttr(r77, r93, r92)
    dec_ref r77
    dec_ref r92
    r95 = r94 >= 0 :: signed
    if not r95 goto L48 (error at __add__:146) else goto L44 :: bool
L44:
    CPy_Reraise()
    if not 0 goto L48 else goto L66 :: bool
L45:
    unreachable
L46:
    CPy_Reraise()
    if not 0 goto L48 else goto L67 :: bool
L47:
    unreachable
L48:
    CPy_RestoreExcInfo(r72)
    dec_ref r72
    r96 = CPy_KeepPropagating()
    if not r96 goto L50 else goto L49 :: bool
L49:
    unreachable
L50:
    r97 = <error> :: eth_portfolio.typing.Balance
    return r97
L51:
    dec_ref r10
    goto L50
L52:
    dec_ref r16
    goto L50
L53:
    dec_ref r31
    goto L50
L54:
    dec_ref r36
    goto L50
L55:
    dec_ref r51
    goto L50
L56:
    dec_ref r56
    goto L50
L57:
    dec_ref r65
    goto L29
L58:
    dec_ref r68
    goto L30
L59:
    dec_ref r77
    goto L48
L60:
    dec_ref r77
    dec_ref r79
    goto L48
L61:
    dec_ref r77
    dec_ref r79
    dec_ref r81
    goto L48
L62:
    dec_ref r77
    dec_ref r84
    goto L48
L63:
    dec_ref r77
    dec_ref r84
    dec_ref r87
    goto L48
L64:
    dec_ref r77
    dec_ref r88
    goto L48
L65:
    dec_ref r91
    goto L42
L66:
    dec_ref r72
    goto L45
L67:
    dec_ref r72
    goto L47

def Balance.__radd__(self, other):
    self :: eth_portfolio.typing.Balance
    other :: union[eth_portfolio.typing.Balance, int]
    r0, r1 :: object
    r2 :: bool
    r3, r4, r5, r6 :: eth_portfolio.typing.Balance
L0:
    r0 = object 0
    r1 = PyObject_RichCompare(other, r0, 2)
    if is_error(r1) goto L8 (error at __radd__:169) else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L8 (error at __radd__:169) else goto L2
L2:
    if r2 goto L3 else goto L4 :: bool
L3:
    inc_ref self
    r3 = self
    goto L7
L4:
    inc_ref other
    r4 = cast(eth_portfolio.typing.Balance, other)
    if is_error(r4) goto L8 (error at __radd__:169) else goto L5
L5:
    r5 = self.__add__(r4)
    dec_ref r4
    if is_error(r5) goto L8 (error at __radd__:169) else goto L6
L6:
    r3 = r5
L7:
    return r3
L8:
    r6 = <error> :: eth_portfolio.typing.Balance
    return r6

def Balance.__sub__(self, other):
    self, other :: eth_portfolio.typing.Balance
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[object, None]
    r25 :: object
    r26 :: i32
    r27 :: bit
    r28 :: bool
    r29 :: str
    r30 :: union[object, None]
    r31, r32 :: str
    r33 :: union[object, None]
    r34, r35, r36 :: str
    r37 :: object
    r38 :: str
    r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42 :: object
    r43, r44 :: union[object, None]
    r45 :: object
    r46 :: i32
    r47 :: bit
    r48 :: bool
    r49 :: str
    r50 :: union[object, None]
    r51, r52 :: str
    r53 :: union[object, None]
    r54, r55, r56 :: str
    r57 :: object
    r58 :: str
    r59 :: object
    r60 :: object[1]
    r61 :: object_ptr
    r62, r63, r64, r65, r66, r67, r68 :: object
    r69, r70 :: union[object, None]
    r71 :: eth_portfolio.typing.Balance
    r72 :: tuple[object, object, object]
    r73 :: object
    r74 :: str
    r75 :: object
    r76 :: bit
    r77 :: object
    r78, r79, r80, r81, r82, r83, r84, r85 :: str
    r86 :: object[2]
    r87 :: object_ptr
    r88 :: object
    r89 :: bit
    r90 :: eth_portfolio.typing.Balance
L0:
    r0 = eth_portfolio.typing.Balance :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L45 (error at __sub__:194) else goto L2
L2:
    r11 = ' is not a `Balance` object.'
    r12 = PyList_New(2)
    if is_error(r12) goto L46 (error at __sub__:194) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L45 (error at __sub__:194) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L47 (error at __sub__:194) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L47 (error at __sub__:194) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L45 (error at __sub__:194) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.token
    r24 = other.token
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L45 (error at __sub__:195) else goto L9
L9:
    r26 = PyObject_IsTrue(r25)
    dec_ref r25
    r27 = r26 >= 0 :: signed
    if not r27 goto L45 (error at __sub__:195) else goto L10 :: bool
L10:
    r28 = truncate r26: i32 to builtins.bool
    if r28 goto L11 else goto L18 :: bool
L11:
    r29 = 'These Balance objects represent balances of different tokens ('
    r30 = self.token
    r31 = PyObject_Str(r30)
    dec_ref r30
    if is_error(r31) goto L45 (error at __sub__:197) else goto L12
L12:
    r32 = ' and '
    r33 = other.token
    r34 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r34) goto L48 (error at __sub__:197) else goto L13
L13:
    r35 = ')'
    r36 = CPyStr_Build(5, r29, r31, r32, r34, r35)
    dec_ref r31
    dec_ref r34
    if is_error(r36) goto L45 (error at __sub__:197) else goto L14
L14:
    r37 = builtins :: module
    r38 = 'ValueError'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L49 (error at __sub__:196) else goto L15
L15:
    r40 = [r36]
    r41 = load_address r40
    r42 = _PyObject_Vectorcall(r39, r41, 1, 0)
    dec_ref r39
    if is_error(r42) goto L49 (error at __sub__:196) else goto L16
L16:
    dec_ref r36
    CPy_Raise(r42)
    dec_ref r42
    if not 0 goto L45 (error at __sub__:196) else goto L17 :: bool
L17:
    unreachable
L18:
    r43 = self.block
    r44 = other.block
    r45 = PyObject_RichCompare(r43, r44, 3)
    dec_ref r43
    dec_ref r44
    if is_error(r45) goto L45 (error at __sub__:199) else goto L19
L19:
    r46 = PyObject_IsTrue(r45)
    dec_ref r45
    r47 = r46 >= 0 :: signed
    if not r47 goto L45 (error at __sub__:199) else goto L20 :: bool
L20:
    r48 = truncate r46: i32 to builtins.bool
    if r48 goto L21 else goto L28 :: bool
L21:
    r49 = 'These Balance objects represent balances from different blocks ('
    r50 = self.block
    r51 = PyObject_Str(r50)
    dec_ref r50
    if is_error(r51) goto L45 (error at __sub__:201) else goto L22
L22:
    r52 = ' and '
    r53 = other.block
    r54 = PyObject_Str(r53)
    dec_ref r53
    if is_error(r54) goto L50 (error at __sub__:201) else goto L23
L23:
    r55 = ')'
    r56 = CPyStr_Build(5, r49, r51, r52, r54, r55)
    dec_ref r51
    dec_ref r54
    if is_error(r56) goto L45 (error at __sub__:201) else goto L24
L24:
    r57 = builtins :: module
    r58 = 'ValueError'
    r59 = CPyObject_GetAttr(r57, r58)
    if is_error(r59) goto L51 (error at __sub__:200) else goto L25
L25:
    r60 = [r56]
    r61 = load_address r60
    r62 = _PyObject_Vectorcall(r59, r61, 1, 0)
    dec_ref r59
    if is_error(r62) goto L51 (error at __sub__:200) else goto L26
L26:
    dec_ref r56
    CPy_Raise(r62)
    dec_ref r62
    if not 0 goto L45 (error at __sub__:200) else goto L27 :: bool
L27:
    unreachable
L28:
    r63 = self.balance
    r64 = other.balance
    r65 = PyNumber_Subtract(r63, r64)
    dec_ref r63
    dec_ref r64
    if is_error(r65) goto L32 (error at __sub__:205) else goto L52
L29:
    r66 = self.usd_value
    r67 = other.usd_value
    r68 = PyNumber_Subtract(r66, r67)
    dec_ref r66
    dec_ref r67
    if is_error(r68) goto L32 (error at __sub__:206) else goto L53
L30:
    r69 = self.token
    dec_ref r69
    r70 = self.block
    dec_ref r70
    r71 = Balance()
    if is_error(r71) goto L32 (error at __sub__:204) else goto L31
L31:
    return r71
L32:
    r72 = CPy_CatchError()
    r73 = builtins :: module
    r74 = 'Exception'
    r75 = CPyObject_GetAttr(r73, r74)
    if is_error(r75) goto L43 (error at __sub__:210) else goto L33
L33:
    r76 = CPy_ExceptionMatches(r75)
    dec_ref r75
    if r76 goto L34 else goto L41 :: bool
L34:
    r77 = CPy_GetExcValue()
    r78 = 'Cannot subtract '
    r79 = PyObject_Str(self)
    if is_error(r79) goto L54 (error at __sub__:211) else goto L35
L35:
    r80 = ' and '
    r81 = PyObject_Str(other)
    if is_error(r81) goto L55 (error at __sub__:211) else goto L36
L36:
    r82 = ': '
    r83 = PyObject_Str(r77)
    if is_error(r83) goto L56 (error at __sub__:211) else goto L37
L37:
    r84 = CPyStr_Build(6, r78, r79, r80, r81, r82, r83)
    dec_ref r79
    dec_ref r81
    dec_ref r83
    if is_error(r84) goto L54 (error at __sub__:211) else goto L38
L38:
    r85 = '__class__'
    r86 = [r77, r84]
    r87 = load_address r86
    r88 = PyObject_VectorcallMethod(r85, r87, 9223372036854775810, 0)
    if is_error(r88) goto L57 (error at __sub__:211) else goto L39
L39:
    dec_ref r77
    dec_ref r84
    CPy_Raise(r88)
    dec_ref r88
    if not 0 goto L43 (error at __sub__:211) else goto L58 :: bool
L40:
    unreachable
L41:
    CPy_Reraise()
    if not 0 goto L43 else goto L59 :: bool
L42:
    unreachable
L43:
    CPy_RestoreExcInfo(r72)
    dec_ref r72
    r89 = CPy_KeepPropagating()
    if not r89 goto L45 else goto L44 :: bool
L44:
    unreachable
L45:
    r90 = <error> :: eth_portfolio.typing.Balance
    return r90
L46:
    dec_ref r10
    goto L45
L47:
    dec_ref r16
    goto L45
L48:
    dec_ref r31
    goto L45
L49:
    dec_ref r36
    goto L45
L50:
    dec_ref r51
    goto L45
L51:
    dec_ref r56
    goto L45
L52:
    dec_ref r65
    goto L29
L53:
    dec_ref r68
    goto L30
L54:
    dec_ref r77
    goto L43
L55:
    dec_ref r77
    dec_ref r79
    goto L43
L56:
    dec_ref r77
    dec_ref r79
    dec_ref r81
    goto L43
L57:
    dec_ref r77
    dec_ref r84
    goto L43
L58:
    dec_ref r72
    goto L40
L59:
    dec_ref r72
    goto L42

def Balance.__bool__(self):
    self :: eth_portfolio.typing.Balance
    r0, r1, r2 :: object
    r3, r4 :: bool
    r5, r6, r7 :: object
    r8, r9 :: bool
L0:
    r0 = self.balance
    r1 = object 0
    r2 = PyObject_RichCompare(r0, r1, 3)
    dec_ref r0
    if is_error(r2) goto L8 (error at __bool__:225) else goto L1
L1:
    r3 = unbox(bool, r2)
    dec_ref r2
    if is_error(r3) goto L8 (error at __bool__:225) else goto L2
L2:
    if r3 goto L3 else goto L4 :: bool
L3:
    r4 = r3
    goto L7
L4:
    r5 = self.usd_value
    r6 = object 0
    r7 = PyObject_RichCompare(r5, r6, 3)
    dec_ref r5
    if is_error(r7) goto L8 (error at __bool__:225) else goto L5
L5:
    r8 = unbox(bool, r7)
    dec_ref r7
    if is_error(r8) goto L8 (error at __bool__:225) else goto L6
L6:
    r4 = r8
L7:
    return r4
L8:
    r9 = <error> :: bool
    return r9

def Balance.__mypyc_defaults_setup(__mypyc_self__):
    __mypyc_self__ :: eth_portfolio.typing.Balance
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: dict
    r8 :: str
    r9, r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13, r14, r15 :: object
    r16 :: bool
L0:
    r0 = eth_portfolio.typing.globals :: static
    r1 = 'Decimal'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L5 else goto L1
L1:
    r3 = object 0
    r4 = [r3]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r2, r5, 1, 0)
    dec_ref r2
    if is_error(r6) goto L5 else goto L2
L2:
    __mypyc_self__.balance = r6
    r7 = eth_portfolio.typing.globals :: static
    r8 = 'Decimal'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L5 else goto L3
L3:
    r10 = object 0
    r11 = [r10]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r9, r12, 1, 0)
    dec_ref r9
    if is_error(r13) goto L5 else goto L4
L4:
    __mypyc_self__.usd_value = r13
    r14 = box(None, 1)
    inc_ref r14
    __mypyc_self__.token = r14
    r15 = box(None, 1)
    inc_ref r15
    __mypyc_self__.block = r15
    return 1
L5:
    r16 = <error> :: bool
    return r16

def _SummableNonNumericMixin.__add__(self, other):
    self, other :: eth_portfolio.typing._SummableNonNumericMixin
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    r0 = builtins :: module
    r1 = 'NotImplementedError'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 (error at __add__:254) else goto L1
L1:
    CPy_Raise(r2)
    dec_ref r2
    if not 0 goto L3 (error at __add__:254) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r3

def _SummableNonNumericMixin.__radd__(self, other):
    self :: eth_portfolio.typing._SummableNonNumericMixin
    other :: union[eth_portfolio.typing._SummableNonNumericMixin, int]
    r0, r1 :: object
    r2 :: bool
    r3, r4, r5, r6 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    r0 = object 0
    r1 = PyObject_RichCompare(other, r0, 2)
    if is_error(r1) goto L8 (error at __radd__:280) else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L8 (error at __radd__:280) else goto L2
L2:
    if r2 goto L3 else goto L4 :: bool
L3:
    inc_ref self
    r3 = self
    goto L7
L4:
    inc_ref other
    r4 = cast(eth_portfolio.typing._SummableNonNumericMixin, other)
    if is_error(r4) goto L8 (error at __radd__:280) else goto L5
L5:
    r5 = self.__add__(r4)
    dec_ref r4
    if is_error(r5) goto L8 (error at __radd__:280) else goto L6
L6:
    r3 = r5
L7:
    return r3
L8:
    r6 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r6

def TokenBalances.__init__(self, seed, block):
    self :: eth_portfolio.typing.TokenBalances
    seed :: union[dict, object, None]
    block :: union[int, None]
    r0, r1, r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10, r11 :: object
    r12 :: object[1]
    r13 :: object_ptr
    r14, r15 :: object
    r16 :: bit
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: dict
    r22 :: short_int
    r23 :: native_int
    r24 :: short_int
    r25 :: object
    r26 :: tuple[bool, short_int, object, object]
    r27 :: short_int
    r28 :: bool
    r29, r30, token :: object
    balance :: union[eth_portfolio.typing.Balance, object]
    r31 :: eth_portfolio.typing.Balance
    r32 :: object
    r33 :: eth_portfolio.typing.Balance
    r34 :: None
    r35, r36 :: bit
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: bool
    r41 :: list
    r42 :: short_int
    r43 :: ptr
    r44 :: native_int
    r45 :: short_int
    r46 :: bit
    r47 :: native_int
    r48, r49 :: ptr
    r50 :: native_int
    r51 :: ptr
    r52, r53, r54 :: object
    r55 :: bool
    r56 :: object
    r57 :: bool
    r58 :: object
    r59 :: bool
    r60 :: eth_portfolio.typing.Balance
    r61 :: object
    r62 :: eth_portfolio.typing.Balance
    r63 :: None
    r64 :: short_int
    r65, r66, r67 :: str
    r68 :: object
    r69 :: str
    r70 :: object
    r71 :: object[1]
    r72 :: object_ptr
    r73 :: object
    r74 :: None
L0:
    if is_error(seed) goto L1 else goto L49
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    if is_error(block) goto L3 else goto L50
L3:
    r1 = box(None, 1)
    inc_ref r1
    block = r1
L4:
    r2 = builtins :: module
    r3 = 'super'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L51 (error at __init__:308) else goto L5
L5:
    r5 = eth_portfolio.typing.TokenBalances :: type
    r6 = [r5, self]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r4, r7, 2, 0)
    dec_ref r4
    if is_error(r8) goto L51 (error at __init__:308) else goto L6
L6:
    r9 = '__init__'
    r10 = CPyObject_GetAttr(r8, r9)
    dec_ref r8
    if is_error(r10) goto L51 (error at __init__:308) else goto L7
L7:
    r11 = eth_portfolio.typing.Balance :: type
    r12 = [r11]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r10, r13, 1, 0)
    dec_ref r10
    if is_error(r14) goto L51 (error at __init__:308) else goto L52
L8:
    self.block = block
    r15 = load_address _Py_NoneStruct
    r16 = seed == r15
    if r16 goto L53 else goto L10 :: bool
L9:
    return 1
L10:
    r17 = load_address PyDict_Type
    r18 = PyObject_IsInstance(seed, r17)
    r19 = r18 >= 0 :: signed
    if not r19 goto L54 (error at __init__:312) else goto L11 :: bool
L11:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L12 else goto L21 :: bool
L12:
    r21 = cast(dict, seed)
    if is_error(r21) goto L48 (error at __init__:313) else goto L13
L13:
    r22 = 0
    r23 = PyDict_Size(r21)
    r24 = r23 << 1
    r25 = CPyDict_GetItemsIter(r21)
    if is_error(r25) goto L55 (error at __init__:313) else goto L14
L14:
    r26 = CPyDict_NextItem(r25, r22)
    r27 = r26[1]
    r22 = r27
    r28 = r26[0]
    if r28 goto L15 else goto L56 :: bool
L15:
    r29 = r26[2]
    r30 = r26[3]
    dec_ref r26
    token = r29
    balance = r30
    r31 = self.__getitem__(token)
    if is_error(r31) goto L57 (error at __init__:314) else goto L16
L16:
    r32 = PyNumber_InPlaceAdd(r31, balance)
    dec_ref r31
    dec_ref balance
    if is_error(r32) goto L58 (error at __init__:314) else goto L17
L17:
    r33 = cast(eth_portfolio.typing.Balance, r32)
    if is_error(r33) goto L58 (error at __init__:314) else goto L18
L18:
    r34 = self.__setitem__(token, r33)
    dec_ref token
    dec_ref r33
    if is_error(r34) goto L59 (error at __init__:314) else goto L19
L19:
    r35 = CPyDict_CheckSize(r21, r24)
    if not r35 goto L59 (error at __init__:313) else goto L14 :: bool
L20:
    r36 = CPy_NoErrOccurred()
    if not r36 goto L48 (error at __init__:313) else goto L47 :: bool
L21:
    r37 = load_address PyList_Type
    r38 = PyObject_IsInstance(seed, r37)
    r39 = r38 >= 0 :: signed
    if not r39 goto L54 (error at __init__:315) else goto L22 :: bool
L22:
    r40 = truncate r38: i32 to builtins.bool
    if r40 goto L23 else goto L41 :: bool
L23:
    r41 = cast(list, seed)
    if is_error(r41) goto L48 (error at __init__:316) else goto L24
L24:
    r42 = 0
L25:
    r43 = get_element_ptr r41 ob_size :: PyVarObject
    r44 = load_mem r43 :: native_int*
    r45 = r44 << 1
    r46 = r42 < r45 :: signed
    if r46 goto L26 else goto L60 :: bool
L26:
    r47 = r42 >> 1
    r48 = get_element_ptr r41 ob_item :: PyListObject
    r49 = load_mem r48 :: ptr*
    r50 = r47 * 8
    r51 = r49 + r50
    r52 = load_mem r51 :: builtins.object*
    inc_ref r52
    r53 = PyObject_GetIter(r52)
    dec_ref r52
    if is_error(r53) goto L61 (error at __init__:316) else goto L27
L27:
    r54 = PyIter_Next(r53)
    if is_error(r54) goto L62 else goto L30
L28:
    r55 = raise ValueError('not enough values to unpack')
    if not r55 goto L48 (error at __init__:316) else goto L29 :: bool
L29:
    unreachable
L30:
    token = r54
    r56 = PyIter_Next(r53)
    if is_error(r56) goto L63 else goto L33
L31:
    r57 = raise ValueError('not enough values to unpack')
    if not r57 goto L48 (error at __init__:316) else goto L32 :: bool
L32:
    unreachable
L33:
    balance = r56
    r58 = PyIter_Next(r53)
    dec_ref r53
    if is_error(r58) goto L36 else goto L64
L34:
    r59 = raise ValueError('too many values to unpack')
    if not r59 goto L48 (error at __init__:316) else goto L35 :: bool
L35:
    unreachable
L36:
    r60 = self.__getitem__(token)
    if is_error(r60) goto L65 (error at __init__:317) else goto L37
L37:
    r61 = PyNumber_InPlaceAdd(r60, balance)
    dec_ref r60
    dec_ref balance
    if is_error(r61) goto L66 (error at __init__:317) else goto L38
L38:
    r62 = cast(eth_portfolio.typing.Balance, r61)
    if is_error(r62) goto L66 (error at __init__:317) else goto L39
L39:
    r63 = self.__setitem__(token, r62)
    dec_ref token
    dec_ref r62
    if is_error(r63) goto L61 (error at __init__:317) else goto L40
L40:
    r64 = r42 + 2
    r42 = r64
    goto L25
L41:
    r65 = PyObject_Str(seed)
    dec_ref seed
    if is_error(r65) goto L48 (error at __init__:319) else goto L42
L42:
    r66 = ' is not a valid input for TokenBalances'
    r67 = CPyStr_Build(2, r65, r66)
    dec_ref r65
    if is_error(r67) goto L48 (error at __init__:319) else goto L43
L43:
    r68 = builtins :: module
    r69 = 'TypeError'
    r70 = CPyObject_GetAttr(r68, r69)
    if is_error(r70) goto L67 (error at __init__:319) else goto L44
L44:
    r71 = [r67]
    r72 = load_address r71
    r73 = _PyObject_Vectorcall(r70, r72, 1, 0)
    dec_ref r70
    if is_error(r73) goto L67 (error at __init__:319) else goto L45
L45:
    dec_ref r67
    CPy_Raise(r73)
    dec_ref r73
    if not 0 goto L48 (error at __init__:319) else goto L46 :: bool
L46:
    unreachable
L47:
    return 1
L48:
    r74 = <error> :: None
    return r74
L49:
    inc_ref seed
    goto L2
L50:
    inc_ref block
    goto L4
L51:
    dec_ref seed
    dec_ref block
    goto L48
L52:
    dec_ref r14
    goto L8
L53:
    dec_ref seed
    goto L9
L54:
    dec_ref seed
    goto L48
L55:
    dec_ref r21
    goto L48
L56:
    dec_ref r21
    dec_ref r25
    dec_ref r26
    goto L20
L57:
    dec_ref r21
    dec_ref r25
    dec_ref token
    dec_ref balance
    goto L48
L58:
    dec_ref r21
    dec_ref r25
    dec_ref token
    goto L48
L59:
    dec_ref r21
    dec_ref r25
    goto L48
L60:
    dec_ref r41
    goto L47
L61:
    dec_ref r41
    goto L48
L62:
    dec_ref r41
    dec_ref r53
    goto L28
L63:
    dec_ref token
    dec_ref r41
    dec_ref r53
    goto L31
L64:
    dec_ref token
    dec_ref balance
    dec_ref r41
    dec_ref r58
    goto L34
L65:
    dec_ref token
    dec_ref balance
    dec_ref r41
    goto L48
L66:
    dec_ref token
    dec_ref r41
    goto L48
L67:
    dec_ref r67
    goto L48

def TokenBalances.__getitem__(self, key):
    self :: eth_portfolio.typing.TokenBalances
    key :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7 :: object
    r8 :: str
    r9, r10 :: object
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: union[object, eth_portfolio.typing.Balance]
    r20 :: union[int, None]
    r21, r22, r23 :: eth_portfolio.typing.Balance
L0:
    r0 = '__contains__'
    r1 = [self, key]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L12 (error at __getitem__:322) else goto L1
L1:
    r4 = PyObject_IsTrue(r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L12 (error at __getitem__:322) else goto L2 :: bool
L2:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L3 else goto L8 :: bool
L3:
    r7 = builtins :: module
    r8 = 'super'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 (error at __getitem__:322) else goto L4
L4:
    r10 = eth_portfolio.typing.TokenBalances :: type
    r11 = [r10, self]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r9, r12, 2, 0)
    dec_ref r9
    if is_error(r13) goto L12 (error at __getitem__:322) else goto L5
L5:
    r14 = '__getitem__'
    r15 = CPyObject_GetAttr(r13, r14)
    dec_ref r13
    if is_error(r15) goto L12 (error at __getitem__:322) else goto L6
L6:
    r16 = [key]
    r17 = load_address r16
    r18 = _PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L12 (error at __getitem__:322) else goto L7
L7:
    r19 = r18
    goto L10
L8:
    r20 = self.block
    dec_ref r20
    r21 = Balance()
    if is_error(r21) goto L12 (error at __getitem__:322) else goto L9
L9:
    r19 = r21
L10:
    r22 = cast(eth_portfolio.typing.Balance, r19)
    if is_error(r22) goto L12 (error at __getitem__:322) else goto L11
L11:
    return r22
L12:
    r23 = <error> :: eth_portfolio.typing.Balance
    return r23

def TokenBalances.__setitem__(self, key, value):
    self :: eth_portfolio.typing.TokenBalances
    key :: object
    value :: eth_portfolio.typing.Balance
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22, r23 :: object
    r24 :: str
    r25, r26 :: object
    r27 :: object[2]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: object[2]
    r33 :: object_ptr
    r34 :: object
    r35 :: None
L0:
    r0 = eth_portfolio.typing.Balance :: type
    r1 = get_element_ptr value ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = 'value must be a `Balance` object. You passed '
    r6 = '{:{}}'
    r7 = ''
    r8 = 'format'
    r9 = [r6, value, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L13 (error at __setitem__:342) else goto L2
L2:
    r12 = PyList_New(2)
    if is_error(r12) goto L14 (error at __setitem__:342) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    inc_ref r5
    set_mem r14, r5 :: builtins.object*
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L13 (error at __setitem__:342) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L15 (error at __setitem__:342) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L15 (error at __setitem__:342) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L13 (error at __setitem__:342) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = builtins :: module
    r24 = 'super'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L13 (error at __setitem__:343) else goto L9
L9:
    r26 = eth_portfolio.typing.TokenBalances :: type
    r27 = [r26, self]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r25, r28, 2, 0)
    dec_ref r25
    if is_error(r29) goto L13 (error at __setitem__:343) else goto L10
L10:
    r30 = '__setitem__'
    r31 = CPyObject_GetAttr(r29, r30)
    dec_ref r29
    if is_error(r31) goto L13 (error at __setitem__:343) else goto L11
L11:
    r32 = [key, value]
    r33 = load_address r32
    r34 = _PyObject_Vectorcall(r31, r33, 2, 0)
    dec_ref r31
    if is_error(r34) goto L13 (error at __setitem__:343) else goto L16
L12:
    return 1
L13:
    r35 = <error> :: None
    return r35
L14:
    dec_ref r11
    goto L13
L15:
    dec_ref r16
    goto L13
L16:
    dec_ref r34
    goto L12

def TokenBalances.dataframe(self):
    self :: eth_portfolio.typing.TokenBalances
    r0 :: dict
    r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7, r8 :: object
    r9 :: bool
    r10 :: object
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14, r15 :: str
    r16 :: object
    r17, r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: i32
    r22, r23 :: bit
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: str
    r33 :: object
    r34 :: object[2]
    r35 :: object_ptr
    r36, r37 :: object
    r38, r39 :: str
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: object[3]
    r44 :: object_ptr
    r45, r46, r47 :: object
L0:
    r0 = PyDict_New()
    if is_error(r0) goto L26 (error at dataframe:354) else goto L1
L1:
    r1 = 'items'
    r2 = [self]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L27 (error at dataframe:356) else goto L2
L2:
    r5 = PyObject_GetIter(r4)
    dec_ref r4
    if is_error(r5) goto L27 (error at dataframe:354) else goto L3
L3:
    r6 = PyIter_Next(r5)
    if is_error(r6) goto L28 else goto L4
L4:
    r7 = PyObject_GetIter(r6)
    dec_ref r6
    if is_error(r7) goto L29 (error at dataframe:354) else goto L5
L5:
    r8 = PyIter_Next(r7)
    if is_error(r8) goto L30 else goto L8
L6:
    r9 = raise ValueError('not enough values to unpack')
    if not r9 goto L26 (error at dataframe:354) else goto L7 :: bool
L7:
    unreachable
L8:
    r10 = PyIter_Next(r7)
    if is_error(r10) goto L31 else goto L11
L9:
    r11 = raise ValueError('not enough values to unpack')
    if not r11 goto L26 (error at dataframe:354) else goto L10 :: bool
L10:
    unreachable
L11:
    r12 = PyIter_Next(r7)
    dec_ref r7
    if is_error(r12) goto L14 else goto L32
L12:
    r13 = raise ValueError('too many values to unpack')
    if not r13 goto L26 (error at dataframe:354) else goto L13 :: bool
L13:
    unreachable
L14:
    r14 = 'balance'
    r15 = 'balance'
    r16 = CPyObject_GetAttr(r10, r15)
    if is_error(r16) goto L33 (error at dataframe:355) else goto L15
L15:
    r17 = 'usd_value'
    r18 = 'usd_value'
    r19 = CPyObject_GetAttr(r10, r18)
    dec_ref r10
    if is_error(r19) goto L34 (error at dataframe:355) else goto L16
L16:
    r20 = CPyDict_Build(2, r14, r16, r17, r19)
    dec_ref r16
    dec_ref r19
    if is_error(r20) goto L35 (error at dataframe:355) else goto L17
L17:
    r21 = CPyDict_SetItem(r0, r8, r20)
    dec_ref r8
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L29 (error at dataframe:354) else goto L3 :: bool
L18:
    r23 = CPy_NoErrOccurred()
    if not r23 goto L27 (error at dataframe:354) else goto L19 :: bool
L19:
    r24 = eth_portfolio.typing.globals :: static
    r25 = 'DataFrame'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L27 (error at dataframe:353) else goto L20
L20:
    r27 = [r0]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r26, r28, 1, 0)
    dec_ref r26
    if is_error(r29) goto L27 (error at dataframe:353) else goto L21
L21:
    dec_ref r0
    r30 = 'T'
    r31 = CPyObject_GetAttr(r29, r30)
    dec_ref r29
    if is_error(r31) goto L26 (error at dataframe:353) else goto L22
L22:
    r32 = 'reset_index'
    r33 = box(bool, 1)
    r34 = [r31, r33]
    r35 = load_address r34
    r36 = ('inplace',)
    r37 = PyObject_VectorcallMethod(r32, r35, 9223372036854775809, r36)
    if is_error(r37) goto L36 (error at dataframe:359) else goto L37
L23:
    r38 = 'index'
    r39 = 'token'
    r40 = CPyDict_Build(1, r38, r39)
    if is_error(r40) goto L36 (error at dataframe:360) else goto L24
L24:
    r41 = 'rename'
    r42 = box(bool, 1)
    r43 = [r31, r40, r42]
    r44 = load_address r43
    r45 = ('columns', 'inplace')
    r46 = PyObject_VectorcallMethod(r41, r44, 9223372036854775809, r45)
    if is_error(r46) goto L38 (error at dataframe:360) else goto L39
L25:
    dec_ref r40
    return r31
L26:
    r47 = <error> :: object
    return r47
L27:
    dec_ref r0
    goto L26
L28:
    dec_ref r5
    goto L18
L29:
    dec_ref r0
    dec_ref r5
    goto L26
L30:
    dec_ref r0
    dec_ref r5
    dec_ref r7
    goto L6
L31:
    dec_ref r0
    dec_ref r5
    dec_ref r7
    dec_ref r8
    goto L9
L32:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    dec_ref r10
    dec_ref r12
    goto L12
L33:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    dec_ref r10
    goto L26
L34:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    dec_ref r16
    goto L26
L35:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L26
L36:
    dec_ref r31
    goto L26
L37:
    dec_ref r37
    goto L23
L38:
    dec_ref r31
    dec_ref r40
    goto L26
L39:
    dec_ref r46
    goto L25

def TokenBalances.sum_usd(self):
    self :: eth_portfolio.typing.TokenBalances
    r0, r1 :: object
    r2 :: str
    r3 :: object[1]
    r4 :: object_ptr
    r5, r6, r7 :: object
    r8 :: str
    r9, r10 :: object
    r11 :: bit
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17, r18 :: object
L0:
    r0 = object 0
    inc_ref r0
    r1 = r0
    r2 = 'values'
    r3 = [self]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775809, 0)
    if is_error(r5) goto L11 (error at sum_usd:376) else goto L1
L1:
    r6 = PyObject_GetIter(r5)
    dec_ref r5
    if is_error(r6) goto L11 (error at sum_usd:376) else goto L2
L2:
    r7 = PyIter_Next(r6)
    if is_error(r7) goto L12 else goto L3
L3:
    r8 = 'usd'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L13 (error at sum_usd:376) else goto L4
L4:
    r10 = PyNumber_Add(r1, r9)
    dec_ref r1
    dec_ref r9
    if is_error(r10) goto L14 (error at sum_usd:-1) else goto L5
L5:
    r1 = r10
    goto L2
L6:
    r11 = CPy_NoErrOccurred()
    if not r11 goto L11 (error at sum_usd:376) else goto L7 :: bool
L7:
    r12 = eth_portfolio.typing.globals :: static
    r13 = 'Decimal'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L11 (error at sum_usd:376) else goto L8
L8:
    r15 = [r1]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L11 (error at sum_usd:376) else goto L9
L9:
    dec_ref r1
    return r17
L10:
    r18 = <error> :: object
    return r18
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r6
    goto L6
L13:
    dec_ref r1
    dec_ref r6
    goto L10
L14:
    dec_ref r6
    goto L10

def TokenBalances.__bool__(self):
    self :: eth_portfolio.typing.TokenBalances
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3, r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bool
L0:
    r0 = 'values'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L5 (error at __bool__:390) else goto L1
L1:
    r4 = builtins :: module
    r5 = 'any'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L6 (error at __bool__:390) else goto L2
L2:
    r7 = [r3]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r6, r8, 1, 0)
    dec_ref r6
    if is_error(r9) goto L6 (error at __bool__:390) else goto L3
L3:
    dec_ref r3
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L5 (error at __bool__:390) else goto L4
L4:
    return r10
L5:
    r11 = <error> :: bool
    return r11
L6:
    dec_ref r3
    goto L5

def TokenBalances.__repr__(self):
    self :: eth_portfolio.typing.TokenBalances
    r0 :: str
    r1 :: dict
    r2, r3, r4 :: str
L0:
    r0 = 'TokenBalances'
    r1 = CPyDict_FromAny(self)
    if is_error(r1) goto L4 (error at __repr__:399) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:399) else goto L2
L2:
    r3 = CPyStr_Build(2, r0, r2)
    dec_ref r2
    if is_error(r3) goto L4 (error at __repr__:399) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: str
    return r4

def TokenBalances.__add__(self, other):
    self, other :: eth_portfolio.typing.TokenBalances
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[int, None]
    r25 :: object
    r26 :: bool
    r27 :: str
    r28 :: union[int, None]
    r29, r30 :: str
    r31 :: union[int, None]
    r32, r33, r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: union[int, None]
    r42 :: union[dict, object, None]
    r43 :: eth_portfolio.typing.TokenBalances
    r44 :: str
    r45 :: object[1]
    r46 :: object_ptr
    r47, r48, r49, r50, r51 :: object
    r52 :: bool
    token, r53 :: object
    r54 :: bool
    balance, r55 :: object
    r56 :: bool
    r57 :: i32
    r58 :: bit
    r59 :: bool
    r60 :: str
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: union[int, None]
    r65 :: eth_portfolio.typing.Balance
    r66 :: str
    r67 :: object[3]
    r68 :: object_ptr
    r69 :: object
    r70 :: bit
    r71 :: str
    r72 :: object[1]
    r73 :: object_ptr
    r74, r75, r76, r77, r78 :: object
    r79 :: bool
    r80 :: object
    r81 :: bool
    r82 :: object
    r83 :: bool
    r84 :: i32
    r85 :: bit
    r86 :: bool
    r87 :: str
    r88 :: object[2]
    r89 :: object_ptr
    r90 :: object
    r91 :: i32
    r92 :: bit
    r93 :: bool
    r94 :: str
    r95 :: object[2]
    r96 :: object_ptr
    r97, r98 :: object
    r99 :: str
    r100 :: object[3]
    r101 :: object_ptr
    r102 :: object
    r103 :: str
    r104 :: object
    r105 :: str
    r106 :: object
    r107 :: union[int, None]
    r108 :: eth_portfolio.typing.Balance
    r109 :: str
    r110 :: object[3]
    r111 :: object_ptr
    r112 :: object
    r113 :: bit
    r114 :: eth_portfolio.typing.TokenBalances
L0:
    r0 = eth_portfolio.typing.TokenBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L69 (error at __add__:422) else goto L2
L2:
    r11 = ' is not a TokenBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L70 (error at __add__:422) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L69 (error at __add__:422) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L71 (error at __add__:422) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L71 (error at __add__:422) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L69 (error at __add__:422) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.block
    r24 = other.block
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L69 (error at __add__:423) else goto L9
L9:
    r26 = unbox(bool, r25)
    dec_ref r25
    if is_error(r26) goto L69 (error at __add__:423) else goto L10
L10:
    if r26 goto L11 else goto L18 :: bool
L11:
    r27 = 'These TokenBalances objects are not from the same block ('
    r28 = self.block
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L69 (error at __add__:425) else goto L12
L12:
    r30 = ' and '
    r31 = other.block
    r32 = PyObject_Str(r31)
    dec_ref r31
    if is_error(r32) goto L72 (error at __add__:425) else goto L13
L13:
    r33 = ')'
    r34 = CPyStr_Build(5, r27, r29, r30, r32, r33)
    dec_ref r29
    dec_ref r32
    if is_error(r34) goto L69 (error at __add__:425) else goto L14
L14:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L73 (error at __add__:424) else goto L15
L15:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L73 (error at __add__:424) else goto L16
L16:
    dec_ref r34
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L69 (error at __add__:424) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = self.block
    r42 = <error> :: union[dict, object, None]
    r43 = TokenBalances(r42, r41)
    dec_ref r41
    if is_error(r43) goto L69 (error at __add__:428) else goto L19
L19:
    r44 = 'items'
    r45 = [self]
    r46 = load_address r45
    r47 = PyObject_VectorcallMethod(r44, r46, 9223372036854775809, 0)
    if is_error(r47) goto L74 (error at __add__:429) else goto L20
L20:
    r48 = PyObject_GetIter(r47)
    dec_ref r47
    if is_error(r48) goto L74 (error at __add__:429) else goto L21
L21:
    r49 = PyIter_Next(r48)
    if is_error(r49) goto L75 else goto L22
L22:
    r50 = PyObject_GetIter(r49)
    dec_ref r49
    if is_error(r50) goto L76 (error at __add__:429) else goto L23
L23:
    r51 = PyIter_Next(r50)
    if is_error(r51) goto L77 else goto L26
L24:
    r52 = raise ValueError('not enough values to unpack')
    if not r52 goto L69 (error at __add__:429) else goto L25 :: bool
L25:
    unreachable
L26:
    token = r51
    r53 = PyIter_Next(r50)
    if is_error(r53) goto L78 else goto L29
L27:
    r54 = raise ValueError('not enough values to unpack')
    if not r54 goto L69 (error at __add__:429) else goto L28 :: bool
L28:
    unreachable
L29:
    balance = r53
    r55 = PyIter_Next(r50)
    dec_ref r50
    if is_error(r55) goto L32 else goto L79
L30:
    r56 = raise ValueError('too many values to unpack')
    if not r56 goto L69 (error at __add__:429) else goto L31 :: bool
L31:
    unreachable
L32:
    r57 = PyObject_IsTrue(balance)
    r58 = r57 >= 0 :: signed
    if not r58 goto L80 (error at __add__:429) else goto L33 :: bool
L33:
    r59 = truncate r57: i32 to builtins.bool
    if r59 goto L34 else goto L81 :: bool
L34:
    r60 = 'balance'
    r61 = CPyObject_GetAttr(balance, r60)
    if is_error(r61) goto L80 (error at __add__:433) else goto L82
L35:
    r62 = 'usd_value'
    r63 = CPyObject_GetAttr(balance, r62)
    dec_ref balance
    if is_error(r63) goto L83 (error at __add__:433) else goto L84
L36:
    r64 = self.block
    dec_ref r64
    r65 = Balance()
    if is_error(r65) goto L83 (error at __add__:433) else goto L37
L37:
    r66 = '_setitem_nochecksum'
    r67 = [r43, token, r65]
    r68 = load_address r67
    r69 = PyObject_VectorcallMethod(r66, r68, 9223372036854775811, 0)
    if is_error(r69) goto L85 (error at __add__:431) else goto L86
L38:
    dec_ref token
    dec_ref r65
    goto L21
L39:
    r70 = CPy_NoErrOccurred()
    if not r70 goto L74 (error at __add__:429) else goto L40 :: bool
L40:
    r71 = 'items'
    r72 = [other]
    r73 = load_address r72
    r74 = PyObject_VectorcallMethod(r71, r73, 9223372036854775809, 0)
    if is_error(r74) goto L74 (error at __add__:435) else goto L41
L41:
    r75 = PyObject_GetIter(r74)
    dec_ref r74
    if is_error(r75) goto L74 (error at __add__:435) else goto L42
L42:
    r76 = PyIter_Next(r75)
    if is_error(r76) goto L87 else goto L43
L43:
    r77 = PyObject_GetIter(r76)
    dec_ref r76
    if is_error(r77) goto L88 (error at __add__:435) else goto L44
L44:
    r78 = PyIter_Next(r77)
    if is_error(r78) goto L89 else goto L47
L45:
    r79 = raise ValueError('not enough values to unpack')
    if not r79 goto L69 (error at __add__:435) else goto L46 :: bool
L46:
    unreachable
L47:
    token = r78
    r80 = PyIter_Next(r77)
    if is_error(r80) goto L90 else goto L50
L48:
    r81 = raise ValueError('not enough values to unpack')
    if not r81 goto L69 (error at __add__:435) else goto L49 :: bool
L49:
    unreachable
L50:
    balance = r80
    r82 = PyIter_Next(r77)
    dec_ref r77
    if is_error(r82) goto L53 else goto L91
L51:
    r83 = raise ValueError('too many values to unpack')
    if not r83 goto L69 (error at __add__:435) else goto L52 :: bool
L52:
    unreachable
L53:
    r84 = PyObject_IsTrue(balance)
    r85 = r84 >= 0 :: signed
    if not r85 goto L92 (error at __add__:429) else goto L54 :: bool
L54:
    r86 = truncate r84: i32 to builtins.bool
    if r86 goto L55 else goto L93 :: bool
L55:
    r87 = '__contains__'
    r88 = [r43, token]
    r89 = load_address r88
    r90 = PyObject_VectorcallMethod(r87, r89, 9223372036854775810, 0)
    if is_error(r90) goto L92 (error at __add__:437) else goto L56
L56:
    r91 = PyObject_IsTrue(r90)
    dec_ref r90
    r92 = r91 >= 0 :: signed
    if not r92 goto L92 (error at __add__:437) else goto L57 :: bool
L57:
    r93 = truncate r91: i32 to builtins.bool
    if r93 goto L58 else goto L62 :: bool
L58:
    r94 = '_getitem_nochecksum'
    r95 = [r43, token]
    r96 = load_address r95
    r97 = PyObject_VectorcallMethod(r94, r96, 9223372036854775810, 0)
    if is_error(r97) goto L92 (error at __add__:439) else goto L59
L59:
    r98 = PyNumber_Add(r97, balance)
    dec_ref r97
    dec_ref balance
    if is_error(r98) goto L94 (error at __add__:439) else goto L60
L60:
    r99 = '_setitem_nochecksum'
    r100 = [r43, token, r98]
    r101 = load_address r100
    r102 = PyObject_VectorcallMethod(r99, r101, 9223372036854775811, 0)
    if is_error(r102) goto L95 (error at __add__:438) else goto L96
L61:
    dec_ref token
    dec_ref r98
    goto L42
L62:
    r103 = 'balance'
    r104 = CPyObject_GetAttr(balance, r103)
    if is_error(r104) goto L92 (error at __add__:444) else goto L97
L63:
    r105 = 'usd_value'
    r106 = CPyObject_GetAttr(balance, r105)
    dec_ref balance
    if is_error(r106) goto L94 (error at __add__:444) else goto L98
L64:
    r107 = self.block
    dec_ref r107
    r108 = Balance()
    if is_error(r108) goto L94 (error at __add__:444) else goto L65
L65:
    r109 = '_setitem_nochecksum'
    r110 = [r43, token, r108]
    r111 = load_address r110
    r112 = PyObject_VectorcallMethod(r109, r111, 9223372036854775811, 0)
    if is_error(r112) goto L99 (error at __add__:442) else goto L100
L66:
    dec_ref token
    dec_ref r108
    goto L42
L67:
    r113 = CPy_NoErrOccurred()
    if not r113 goto L74 (error at __add__:435) else goto L68 :: bool
L68:
    return r43
L69:
    r114 = <error> :: eth_portfolio.typing.TokenBalances
    return r114
L70:
    dec_ref r10
    goto L69
L71:
    dec_ref r16
    goto L69
L72:
    dec_ref r29
    goto L69
L73:
    dec_ref r34
    goto L69
L74:
    dec_ref r43
    goto L69
L75:
    dec_ref r48
    goto L39
L76:
    dec_ref r43
    dec_ref r48
    goto L69
L77:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    goto L24
L78:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    dec_ref token
    goto L27
L79:
    dec_ref r43
    dec_ref r48
    dec_ref token
    dec_ref balance
    dec_ref r55
    goto L30
L80:
    dec_ref r43
    dec_ref r48
    dec_ref token
    dec_ref balance
    goto L69
L81:
    dec_ref token
    dec_ref balance
    goto L21
L82:
    dec_ref r61
    goto L35
L83:
    dec_ref r43
    dec_ref r48
    dec_ref token
    goto L69
L84:
    dec_ref r63
    goto L36
L85:
    dec_ref r43
    dec_ref r48
    dec_ref token
    dec_ref r65
    goto L69
L86:
    dec_ref r69
    goto L38
L87:
    dec_ref r75
    goto L67
L88:
    dec_ref r43
    dec_ref r75
    goto L69
L89:
    dec_ref r43
    dec_ref r75
    dec_ref r77
    goto L45
L90:
    dec_ref r43
    dec_ref token
    dec_ref r75
    dec_ref r77
    goto L48
L91:
    dec_ref r43
    dec_ref token
    dec_ref balance
    dec_ref r75
    dec_ref r82
    goto L51
L92:
    dec_ref r43
    dec_ref token
    dec_ref balance
    dec_ref r75
    goto L69
L93:
    dec_ref token
    dec_ref balance
    goto L42
L94:
    dec_ref r43
    dec_ref token
    dec_ref r75
    goto L69
L95:
    dec_ref r43
    dec_ref token
    dec_ref r75
    dec_ref r98
    goto L69
L96:
    dec_ref r102
    goto L61
L97:
    dec_ref r104
    goto L63
L98:
    dec_ref r106
    goto L64
L99:
    dec_ref r43
    dec_ref token
    dec_ref r75
    dec_ref r108
    goto L69
L100:
    dec_ref r112
    goto L66

def TokenBalances.__add_____SummableNonNumericMixin_glue(self, other):
    self :: eth_portfolio.typing.TokenBalances
    other :: eth_portfolio.typing._SummableNonNumericMixin
    r0, r1 :: eth_portfolio.typing.TokenBalances
    r2 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    inc_ref other
    r0 = cast(eth_portfolio.typing.TokenBalances, other)
    if is_error(r0) goto L3 else goto L1
L1:
    r1 = TokenBalances.__add__(self, r0)
    dec_ref r0
    if is_error(r1) goto L3 else goto L2
L2:
    return r1
L3:
    r2 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r2

def TokenBalances.__sub__(self, other):
    self, other :: eth_portfolio.typing.TokenBalances
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[int, None]
    r25 :: object
    r26 :: bool
    r27 :: str
    r28 :: union[int, None]
    r29, r30 :: str
    r31 :: union[int, None]
    r32, r33, r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: union[int, None]
    r42 :: eth_portfolio.typing.TokenBalances
    r43 :: str
    r44 :: object[1]
    r45 :: object_ptr
    r46, r47, r48, r49, r50 :: object
    r51 :: bool
    token, r52 :: object
    r53 :: bool
    balance, r54 :: object
    r55 :: bool
    r56 :: eth_portfolio.typing.Balance
    r57 :: object
    r58 :: eth_portfolio.typing.Balance
    r59 :: None
    r60 :: bit
    r61 :: dict
    r62 :: short_int
    r63 :: native_int
    r64 :: short_int
    r65 :: object
    r66 :: tuple[bool, short_int, object, object]
    r67 :: short_int
    r68 :: bool
    r69, r70 :: object
    r71 :: eth_portfolio.typing.Balance
    r72 :: i32
    r73 :: bit
    r74 :: bool
    r75 :: i32
    r76, r77, r78 :: bit
    r79 :: eth_portfolio.typing.TokenBalances
L0:
    r0 = eth_portfolio.typing.TokenBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L47 (error at __sub__:469) else goto L2
L2:
    r11 = ' is not a TokenBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L48 (error at __sub__:469) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L47 (error at __sub__:469) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L49 (error at __sub__:469) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L49 (error at __sub__:469) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L47 (error at __sub__:469) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.block
    r24 = other.block
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L47 (error at __sub__:470) else goto L9
L9:
    r26 = unbox(bool, r25)
    dec_ref r25
    if is_error(r26) goto L47 (error at __sub__:470) else goto L10
L10:
    if r26 goto L11 else goto L18 :: bool
L11:
    r27 = 'These TokenBalances objects are not from the same block ('
    r28 = self.block
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L47 (error at __sub__:472) else goto L12
L12:
    r30 = ' and '
    r31 = other.block
    r32 = PyObject_Str(r31)
    dec_ref r31
    if is_error(r32) goto L50 (error at __sub__:472) else goto L13
L13:
    r33 = ')'
    r34 = CPyStr_Build(5, r27, r29, r30, r32, r33)
    dec_ref r29
    dec_ref r32
    if is_error(r34) goto L47 (error at __sub__:472) else goto L14
L14:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L51 (error at __sub__:471) else goto L15
L15:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L51 (error at __sub__:471) else goto L16
L16:
    dec_ref r34
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L47 (error at __sub__:471) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = self.block
    r42 = TokenBalances(self, r41)
    dec_ref r41
    if is_error(r42) goto L47 (error at __sub__:475) else goto L19
L19:
    r43 = 'items'
    r44 = [other]
    r45 = load_address r44
    r46 = PyObject_VectorcallMethod(r43, r45, 9223372036854775809, 0)
    if is_error(r46) goto L52 (error at __sub__:476) else goto L20
L20:
    r47 = PyObject_GetIter(r46)
    dec_ref r46
    if is_error(r47) goto L52 (error at __sub__:476) else goto L21
L21:
    r48 = PyIter_Next(r47)
    if is_error(r48) goto L53 else goto L22
L22:
    r49 = PyObject_GetIter(r48)
    dec_ref r48
    if is_error(r49) goto L54 (error at __sub__:476) else goto L23
L23:
    r50 = PyIter_Next(r49)
    if is_error(r50) goto L55 else goto L26
L24:
    r51 = raise ValueError('not enough values to unpack')
    if not r51 goto L47 (error at __sub__:476) else goto L25 :: bool
L25:
    unreachable
L26:
    token = r50
    r52 = PyIter_Next(r49)
    if is_error(r52) goto L56 else goto L29
L27:
    r53 = raise ValueError('not enough values to unpack')
    if not r53 goto L47 (error at __sub__:476) else goto L28 :: bool
L28:
    unreachable
L29:
    balance = r52
    r54 = PyIter_Next(r49)
    dec_ref r49
    if is_error(r54) goto L32 else goto L57
L30:
    r55 = raise ValueError('too many values to unpack')
    if not r55 goto L47 (error at __sub__:476) else goto L31 :: bool
L31:
    unreachable
L32:
    r56 = r42.__getitem__(token)
    if is_error(r56) goto L58 (error at __sub__:477) else goto L33
L33:
    r57 = PyNumber_InPlaceSubtract(r56, balance)
    dec_ref r56
    dec_ref balance
    if is_error(r57) goto L59 (error at __sub__:477) else goto L34
L34:
    r58 = cast(eth_portfolio.typing.Balance, r57)
    if is_error(r58) goto L59 (error at __sub__:477) else goto L35
L35:
    r59 = r42.__setitem__(token, r58)
    dec_ref token
    dec_ref r58
    if is_error(r59) goto L54 (error at __sub__:477) else goto L21
L36:
    r60 = CPy_NoErrOccurred()
    if not r60 goto L52 (error at __sub__:476) else goto L37 :: bool
L37:
    r61 = CPyDict_FromAny(r42)
    if is_error(r61) goto L52 (error at __sub__:478) else goto L38
L38:
    r62 = 0
    r63 = PyDict_Size(r61)
    r64 = r63 << 1
    r65 = CPyDict_GetItemsIter(r61)
    if is_error(r65) goto L60 (error at __sub__:478) else goto L39
L39:
    r66 = CPyDict_NextItem(r65, r62)
    r67 = r66[1]
    r62 = r67
    r68 = r66[0]
    if r68 goto L40 else goto L61 :: bool
L40:
    r69 = r66[2]
    r70 = r66[3]
    dec_ref r66
    r71 = cast(eth_portfolio.typing.Balance, r70)
    if is_error(r71) goto L62 (error at __sub__:478) else goto L41
L41:
    token = r69
    balance = r71
    r72 = PyObject_IsTrue(balance)
    dec_ref balance
    r73 = r72 >= 0 :: signed
    if not r73 goto L63 (error at __sub__:476) else goto L42 :: bool
L42:
    r74 = truncate r72: i32 to builtins.bool
    if r74 goto L64 else goto L43 :: bool
L43:
    r75 = PyObject_DelItem(r42, token)
    dec_ref token
    r76 = r75 >= 0 :: signed
    if not r76 goto L65 (error at __sub__:480) else goto L44 :: bool
L44:
    r77 = CPyDict_CheckSize(r61, r64)
    if not r77 goto L65 (error at __sub__:478) else goto L39 :: bool
L45:
    r78 = CPy_NoErrOccurred()
    if not r78 goto L52 (error at __sub__:478) else goto L46 :: bool
L46:
    return r42
L47:
    r79 = <error> :: eth_portfolio.typing.TokenBalances
    return r79
L48:
    dec_ref r10
    goto L47
L49:
    dec_ref r16
    goto L47
L50:
    dec_ref r29
    goto L47
L51:
    dec_ref r34
    goto L47
L52:
    dec_ref r42
    goto L47
L53:
    dec_ref r47
    goto L36
L54:
    dec_ref r42
    dec_ref r47
    goto L47
L55:
    dec_ref r42
    dec_ref r47
    dec_ref r49
    goto L24
L56:
    dec_ref r42
    dec_ref r47
    dec_ref r49
    dec_ref token
    goto L27
L57:
    dec_ref r42
    dec_ref r47
    dec_ref token
    dec_ref balance
    dec_ref r54
    goto L30
L58:
    dec_ref r42
    dec_ref r47
    dec_ref token
    dec_ref balance
    goto L47
L59:
    dec_ref r42
    dec_ref r47
    dec_ref token
    goto L47
L60:
    dec_ref r42
    dec_ref r61
    goto L47
L61:
    dec_ref r61
    dec_ref r65
    dec_ref r66
    goto L45
L62:
    dec_ref r42
    dec_ref r61
    dec_ref r65
    dec_ref r69
    goto L47
L63:
    dec_ref r42
    dec_ref token
    dec_ref r61
    dec_ref r65
    goto L47
L64:
    dec_ref token
    goto L44
L65:
    dec_ref r42
    dec_ref r61
    dec_ref r65
    goto L47

def __mypyc_lambda__0___init___RemoteTokenBalances_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0___init___RemoteTokenBalances_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: eth_portfolio.typing.__mypyc_lambda__0___init___RemoteTokenBalances_obj
    r0 :: eth_portfolio.typing.__init___RemoteTokenBalances_env
    r1 :: union[int, None]
    r2 :: union[dict, object, None]
    r3, r4 :: eth_portfolio.typing.TokenBalances
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L4 (error at <lambda>:507) else goto L1
L1:
    r1 = r0.block
    dec_ref r0
    if is_error(r1) goto L4 (error at <lambda>:507) else goto L2
L2:
    r2 = <error> :: union[dict, object, None]
    r3 = TokenBalances(r2, r1)
    dec_ref r1
    if is_error(r3) goto L4 (error at <lambda>:507) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: eth_portfolio.typing.TokenBalances
    return r4

def RemoteTokenBalances.__init__(self, seed, block):
    self :: dict
    seed :: union[dict, list, None]
    block :: union[int, None]
    r0, r1 :: object
    r2 :: eth_portfolio.typing.__init___RemoteTokenBalances_env
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: eth_portfolio.typing.__mypyc_lambda__0___init___RemoteTokenBalances_obj
    r14 :: bool
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: union[int, None]
    r19 :: str
    r20 :: i32
    r21 :: bit
    r22 :: object
    r23 :: bit
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: bool
    r28 :: dict
    r29 :: short_int
    r30 :: native_int
    r31 :: short_int
    r32 :: object
    r33 :: tuple[bool, short_int, object, object]
    r34 :: short_int
    r35 :: bool
    r36, r37 :: object
    r38 :: str
    r39 :: eth_portfolio.typing.TokenBalances
    remote :: str
    token_balances :: eth_portfolio.typing.TokenBalances
    r40 :: str
    r41 :: object
    r42, r43 :: union[int, None]
    r44 :: object
    r45 :: bool
    r46, r47 :: str
    r48 :: object
    r49 :: union[int, None]
    r50, r51 :: str
    r52 :: union[int, None]
    r53, r54, r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: object[1]
    r60 :: object_ptr
    r61, r62, r63 :: object
    r64 :: i32
    r65, r66, r67 :: bit
    r68 :: object
    r69 :: i32
    r70 :: bit
    r71 :: bool
    r72 :: list
    r73 :: short_int
    r74 :: ptr
    r75 :: native_int
    r76 :: short_int
    r77 :: bit
    r78 :: native_int
    r79, r80 :: ptr
    r81 :: native_int
    r82 :: ptr
    r83 :: object
    r84 :: tuple[str, eth_portfolio.typing.TokenBalances]
    r85 :: str
    r86 :: eth_portfolio.typing.TokenBalances
    r87 :: str
    r88 :: object
    r89, r90 :: union[int, None]
    r91 :: object
    r92 :: bool
    r93, r94 :: str
    r95 :: object
    r96 :: union[int, None]
    r97, r98 :: str
    r99 :: union[int, None]
    r100, r101, r102 :: str
    r103 :: object
    r104 :: str
    r105 :: object
    r106 :: object[1]
    r107 :: object_ptr
    r108, r109, r110 :: object
    r111 :: i32
    r112 :: bit
    r113 :: short_int
    r114, r115, r116, r117 :: str
    r118 :: object[3]
    r119 :: object_ptr
    r120 :: object
    r121 :: str
    r122 :: list
    r123, r124, r125 :: ptr
    r126 :: str
    r127 :: object
    r128 :: str
    r129 :: object
    r130 :: object[1]
    r131 :: object_ptr
    r132 :: object
    r133 :: None
L0:
    if is_error(seed) goto L1 else goto L75
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    if is_error(block) goto L3 else goto L76
L3:
    r1 = box(None, 1)
    inc_ref r1
    block = r1
L4:
    r2 = __init___RemoteTokenBalances_env()
    if is_error(r2) goto L77 (error at __init__:506) else goto L5
L5:
    r2.block = block; r3 = is_error
    if not r3 goto L78 (error at __init__:506) else goto L6 :: bool
L6:
    r4 = builtins :: module
    r5 = 'super'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L78 (error at __init__:507) else goto L7
L7:
    r7 = eth_portfolio.typing.RemoteTokenBalances :: type
    r8 = [r7, self]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r6, r9, 2, 0)
    dec_ref r6
    if is_error(r10) goto L78 (error at __init__:507) else goto L8
L8:
    r11 = '__init__'
    r12 = CPyObject_GetAttr(r10, r11)
    dec_ref r10
    if is_error(r12) goto L78 (error at __init__:507) else goto L9
L9:
    r13 = __mypyc_lambda__0___init___RemoteTokenBalances_obj()
    if is_error(r13) goto L79 (error at __init__:507) else goto L10
L10:
    inc_ref r2
    r13.__mypyc_env__ = r2; r14 = is_error
    if not r14 goto L80 (error at __init__:507) else goto L11 :: bool
L11:
    r15 = [r13]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r12, r16, 1, 0)
    dec_ref r12
    if is_error(r17) goto L81 (error at __init__:507) else goto L82
L12:
    dec_ref r13
    r18 = r2.block
    dec_ref r2
    if is_error(r18) goto L83 (error at __init__:508) else goto L13
L13:
    r19 = 'block'
    r20 = PyObject_SetAttr(self, r19, r18)
    dec_ref r18
    r21 = r20 >= 0 :: signed
    if not r21 goto L83 (error at __init__:508) else goto L14 :: bool
L14:
    r22 = load_address _Py_NoneStruct
    r23 = seed == r22
    if r23 goto L84 else goto L16 :: bool
L15:
    return 1
L16:
    r24 = load_address PyDict_Type
    r25 = PyObject_IsInstance(seed, r24)
    r26 = r25 >= 0 :: signed
    if not r26 goto L83 (error at __init__:511) else goto L17 :: bool
L17:
    r27 = truncate r25: i32 to builtins.bool
    if r27 goto L18 else goto L42 :: bool
L18:
    r28 = cast(dict, seed)
    if is_error(r28) goto L74 (error at __init__:512) else goto L19
L19:
    r29 = 0
    r30 = PyDict_Size(r28)
    r31 = r30 << 1
    r32 = CPyDict_GetItemsIter(r28)
    if is_error(r32) goto L85 (error at __init__:512) else goto L20
L20:
    r33 = CPyDict_NextItem(r32, r29)
    r34 = r33[1]
    r29 = r34
    r35 = r33[0]
    if r35 goto L21 else goto L86 :: bool
L21:
    r36 = r33[2]
    r37 = r33[3]
    dec_ref r33
    r38 = cast(str, r36)
    if is_error(r38) goto L87 (error at __init__:512) else goto L22
L22:
    r39 = cast(eth_portfolio.typing.TokenBalances, r37)
    if is_error(r39) goto L88 (error at __init__:512) else goto L23
L23:
    remote = r38
    token_balances = r39
    r40 = 'block'
    r41 = CPyObject_GetAttr(self, r40)
    if is_error(r41) goto L89 (error at __init__:513) else goto L24
L24:
    r42 = cast(union[int, None], r41)
    if is_error(r42) goto L89 (error at __init__:513) else goto L25
L25:
    r43 = token_balances.block
    r44 = PyObject_RichCompare(r42, r43, 3)
    dec_ref r42
    dec_ref r43
    if is_error(r44) goto L89 (error at __init__:513) else goto L26
L26:
    r45 = unbox(bool, r44)
    dec_ref r44
    if is_error(r45) goto L89 (error at __init__:513) else goto L27
L27:
    if r45 goto L90 else goto L37 :: bool
L28:
    r46 = 'These objects are not from the same block ('
    r47 = 'block'
    r48 = CPyObject_GetAttr(self, r47)
    if is_error(r48) goto L91 (error at __init__:515) else goto L29
L29:
    r49 = cast(union[int, None], r48)
    if is_error(r49) goto L91 (error at __init__:515) else goto L30
L30:
    r50 = PyObject_Str(r49)
    dec_ref r49
    if is_error(r50) goto L91 (error at __init__:515) else goto L31
L31:
    r51 = ' and '
    r52 = token_balances.block
    dec_ref token_balances
    r53 = PyObject_Str(r52)
    dec_ref r52
    if is_error(r53) goto L92 (error at __init__:515) else goto L32
L32:
    r54 = ')'
    r55 = CPyStr_Build(5, r46, r50, r51, r53, r54)
    dec_ref r50
    dec_ref r53
    if is_error(r55) goto L74 (error at __init__:515) else goto L33
L33:
    r56 = builtins :: module
    r57 = 'ValueError'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L93 (error at __init__:514) else goto L34
L34:
    r59 = [r55]
    r60 = load_address r59
    r61 = _PyObject_Vectorcall(r58, r60, 1, 0)
    dec_ref r58
    if is_error(r61) goto L93 (error at __init__:514) else goto L35
L35:
    dec_ref r55
    CPy_Raise(r61)
    dec_ref r61
    if not 0 goto L74 (error at __init__:514) else goto L36 :: bool
L36:
    unreachable
L37:
    r62 = CPyDict_GetItem(self, remote)
    if is_error(r62) goto L89 (error at __init__:517) else goto L38
L38:
    r63 = PyNumber_InPlaceAdd(r62, token_balances)
    dec_ref r62
    dec_ref token_balances
    if is_error(r63) goto L94 (error at __init__:517) else goto L39
L39:
    r64 = CPyDict_SetItem(self, remote, r63)
    dec_ref remote
    dec_ref r63
    r65 = r64 >= 0 :: signed
    if not r65 goto L95 (error at __init__:517) else goto L40 :: bool
L40:
    r66 = CPyDict_CheckSize(r28, r31)
    if not r66 goto L95 (error at __init__:512) else goto L20 :: bool
L41:
    r67 = CPy_NoErrOccurred()
    if not r67 goto L74 (error at __init__:512) else goto L73 :: bool
L42:
    r68 = load_address PyList_Type
    r69 = PyObject_IsInstance(seed, r68)
    r70 = r69 >= 0 :: signed
    if not r70 goto L83 (error at __init__:518) else goto L43 :: bool
L43:
    r71 = truncate r69: i32 to builtins.bool
    if r71 goto L44 else goto L66 :: bool
L44:
    r72 = cast(list, seed)
    if is_error(r72) goto L74 (error at __init__:519) else goto L45
L45:
    r73 = 0
L46:
    r74 = get_element_ptr r72 ob_size :: PyVarObject
    r75 = load_mem r74 :: native_int*
    r76 = r75 << 1
    r77 = r73 < r76 :: signed
    if r77 goto L47 else goto L96 :: bool
L47:
    r78 = r73 >> 1
    r79 = get_element_ptr r72 ob_item :: PyListObject
    r80 = load_mem r79 :: ptr*
    r81 = r78 * 8
    r82 = r80 + r81
    r83 = load_mem r82 :: builtins.object*
    inc_ref r83
    r84 = unbox(tuple[str, eth_portfolio.typing.TokenBalances], r83)
    dec_ref r83
    if is_error(r84) goto L97 (error at __init__:519) else goto L48
L48:
    r85 = r84[0]
    remote = r85
    r86 = r84[1]
    dec_ref r84
    token_balances = r86
    r87 = 'block'
    r88 = CPyObject_GetAttr(self, r87)
    if is_error(r88) goto L98 (error at __init__:520) else goto L49
L49:
    r89 = cast(union[int, None], r88)
    if is_error(r89) goto L98 (error at __init__:520) else goto L50
L50:
    r90 = token_balances.block
    r91 = PyObject_RichCompare(r89, r90, 3)
    dec_ref r89
    dec_ref r90
    if is_error(r91) goto L98 (error at __init__:520) else goto L51
L51:
    r92 = unbox(bool, r91)
    dec_ref r91
    if is_error(r92) goto L98 (error at __init__:520) else goto L52
L52:
    if r92 goto L99 else goto L62 :: bool
L53:
    r93 = 'These objects are not from the same block ('
    r94 = 'block'
    r95 = CPyObject_GetAttr(self, r94)
    if is_error(r95) goto L91 (error at __init__:522) else goto L54
L54:
    r96 = cast(union[int, None], r95)
    if is_error(r96) goto L91 (error at __init__:522) else goto L55
L55:
    r97 = PyObject_Str(r96)
    dec_ref r96
    if is_error(r97) goto L91 (error at __init__:522) else goto L56
L56:
    r98 = ' and '
    r99 = token_balances.block
    dec_ref token_balances
    r100 = PyObject_Str(r99)
    dec_ref r99
    if is_error(r100) goto L100 (error at __init__:522) else goto L57
L57:
    r101 = ')'
    r102 = CPyStr_Build(5, r93, r97, r98, r100, r101)
    dec_ref r97
    dec_ref r100
    if is_error(r102) goto L74 (error at __init__:522) else goto L58
L58:
    r103 = builtins :: module
    r104 = 'ValueError'
    r105 = CPyObject_GetAttr(r103, r104)
    if is_error(r105) goto L101 (error at __init__:521) else goto L59
L59:
    r106 = [r102]
    r107 = load_address r106
    r108 = _PyObject_Vectorcall(r105, r107, 1, 0)
    dec_ref r105
    if is_error(r108) goto L101 (error at __init__:521) else goto L60
L60:
    dec_ref r102
    CPy_Raise(r108)
    dec_ref r108
    if not 0 goto L74 (error at __init__:521) else goto L61 :: bool
L61:
    unreachable
L62:
    r109 = CPyDict_GetItem(self, remote)
    if is_error(r109) goto L98 (error at __init__:524) else goto L63
L63:
    r110 = PyNumber_InPlaceAdd(r109, token_balances)
    dec_ref r109
    dec_ref token_balances
    if is_error(r110) goto L102 (error at __init__:524) else goto L64
L64:
    r111 = CPyDict_SetItem(self, remote, r110)
    dec_ref remote
    dec_ref r110
    r112 = r111 >= 0 :: signed
    if not r112 goto L97 (error at __init__:524) else goto L65 :: bool
L65:
    r113 = r73 + 2
    r73 = r113
    goto L46
L66:
    r114 = ''
    r115 = '{:{}}'
    r116 = ''
    r117 = 'format'
    r118 = [r115, seed, r116]
    r119 = load_address r118
    r120 = PyObject_VectorcallMethod(r117, r119, 9223372036854775811, 0)
    if is_error(r120) goto L83 (error at __init__:526) else goto L67
L67:
    dec_ref seed
    r121 = ' is not a valid input for TokenBalances'
    r122 = PyList_New(2)
    if is_error(r122) goto L103 (error at __init__:526) else goto L68
L68:
    r123 = get_element_ptr r122 ob_item :: PyListObject
    r124 = load_mem r123 :: ptr*
    set_mem r124, r120 :: builtins.object*
    inc_ref r121
    r125 = r124 + 8
    set_mem r125, r121 :: builtins.object*
    r126 = PyUnicode_Join(r114, r122)
    dec_ref r122
    if is_error(r126) goto L74 (error at __init__:526) else goto L69
L69:
    r127 = builtins :: module
    r128 = 'TypeError'
    r129 = CPyObject_GetAttr(r127, r128)
    if is_error(r129) goto L104 (error at __init__:526) else goto L70
L70:
    r130 = [r126]
    r131 = load_address r130
    r132 = _PyObject_Vectorcall(r129, r131, 1, 0)
    dec_ref r129
    if is_error(r132) goto L104 (error at __init__:526) else goto L71
L71:
    dec_ref r126
    CPy_Raise(r132)
    dec_ref r132
    if not 0 goto L74 (error at __init__:526) else goto L72 :: bool
L72:
    unreachable
L73:
    return 1
L74:
    r133 = <error> :: None
    return r133
L75:
    inc_ref seed
    goto L2
L76:
    inc_ref block
    goto L4
L77:
    dec_ref seed
    dec_ref block
    goto L74
L78:
    dec_ref seed
    dec_ref r2
    goto L74
L79:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    goto L74
L80:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    dec_ref r13
    goto L74
L81:
    dec_ref seed
    dec_ref r2
    dec_ref r13
    goto L74
L82:
    dec_ref r17
    goto L12
L83:
    dec_ref seed
    goto L74
L84:
    dec_ref seed
    goto L15
L85:
    dec_ref r28
    goto L74
L86:
    dec_ref r28
    dec_ref r32
    dec_ref r33
    goto L41
L87:
    dec_ref r28
    dec_ref r32
    dec_ref r37
    goto L74
L88:
    dec_ref r28
    dec_ref r32
    dec_ref r38
    goto L74
L89:
    dec_ref r28
    dec_ref r32
    dec_ref remote
    dec_ref token_balances
    goto L74
L90:
    dec_ref r28
    dec_ref r32
    dec_ref remote
    goto L28
L91:
    dec_ref token_balances
    goto L74
L92:
    dec_ref r50
    goto L74
L93:
    dec_ref r55
    goto L74
L94:
    dec_ref r28
    dec_ref r32
    dec_ref remote
    goto L74
L95:
    dec_ref r28
    dec_ref r32
    goto L74
L96:
    dec_ref r72
    goto L73
L97:
    dec_ref r72
    goto L74
L98:
    dec_ref remote
    dec_ref token_balances
    dec_ref r72
    goto L74
L99:
    dec_ref remote
    dec_ref r72
    goto L53
L100:
    dec_ref r97
    goto L74
L101:
    dec_ref r102
    goto L74
L102:
    dec_ref remote
    dec_ref r72
    goto L74
L103:
    dec_ref r120
    goto L74
L104:
    dec_ref r126
    goto L74

def RemoteTokenBalances.__setitem__(self, protocol, value):
    self :: dict
    protocol :: str
    value :: eth_portfolio.typing.TokenBalances
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22, r23 :: object
    r24 :: str
    r25, r26 :: object
    r27 :: object[2]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: object[2]
    r33 :: object_ptr
    r34 :: object
    r35, r36 :: None
L0:
    r0 = eth_portfolio.typing.TokenBalances :: type
    r1 = get_element_ptr value ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = 'value must be a `TokenBalances` object. You passed '
    r6 = '{:{}}'
    r7 = ''
    r8 = 'format'
    r9 = [r6, value, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L14 (error at __setitem__:546) else goto L2
L2:
    r12 = PyList_New(2)
    if is_error(r12) goto L15 (error at __setitem__:546) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    inc_ref r5
    set_mem r14, r5 :: builtins.object*
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L14 (error at __setitem__:546) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L16 (error at __setitem__:546) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L16 (error at __setitem__:546) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L14 (error at __setitem__:546) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = builtins :: module
    r24 = 'super'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L14 (error at __setitem__:547) else goto L9
L9:
    r26 = eth_portfolio.typing.RemoteTokenBalances :: type
    r27 = [r26, self]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r25, r28, 2, 0)
    dec_ref r25
    if is_error(r29) goto L14 (error at __setitem__:547) else goto L10
L10:
    r30 = '__setitem__'
    r31 = CPyObject_GetAttr(r29, r30)
    dec_ref r29
    if is_error(r31) goto L14 (error at __setitem__:547) else goto L11
L11:
    r32 = [protocol, value]
    r33 = load_address r32
    r34 = _PyObject_Vectorcall(r31, r33, 2, 0)
    dec_ref r31
    if is_error(r34) goto L14 (error at __setitem__:547) else goto L12
L12:
    r35 = unbox(None, r34)
    dec_ref r34
    if is_error(r35) goto L14 (error at __setitem__:547) else goto L13
L13:
    return r35
L14:
    r36 = <error> :: None
    return r36
L15:
    dec_ref r11
    goto L14
L16:
    dec_ref r16
    goto L14

def RemoteTokenBalances.dataframe(self):
    self :: dict
    r0 :: list
    r1 :: short_int
    r2 :: native_int
    r3 :: short_int
    r4 :: object
    r5 :: tuple[bool, short_int, object, object]
    r6 :: short_int
    r7 :: bool
    r8, r9 :: object
    r10 :: str
    r11 :: eth_portfolio.typing.TokenBalances
    r12 :: object
    r13 :: str
    r14 :: i32
    r15 :: bit
    r16 :: i32
    r17, r18, r19 :: bit
    r20 :: ptr
    r21 :: native_int
    r22 :: short_int
    r23 :: bit
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: object[2]
    r33 :: object_ptr
    r34, r35, r36 :: object
    r37 :: dict
    r38 :: str
    r39, r40, r41 :: object
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L19 (error at dataframe:557) else goto L1
L1:
    r1 = 0
    r2 = PyDict_Size(self)
    r3 = r2 << 1
    r4 = CPyDict_GetItemsIter(self)
    if is_error(r4) goto L20 (error at dataframe:558) else goto L2
L2:
    r5 = CPyDict_NextItem(r4, r1)
    r6 = r5[1]
    r1 = r6
    r7 = r5[0]
    if r7 goto L3 else goto L21 :: bool
L3:
    r8 = r5[2]
    r9 = r5[3]
    dec_ref r5
    r10 = cast(str, r8)
    if is_error(r10) goto L22 (error at dataframe:558) else goto L4
L4:
    r11 = cast(eth_portfolio.typing.TokenBalances, r9)
    if is_error(r11) goto L23 (error at dataframe:558) else goto L5
L5:
    r12 = r11.dataframe
    dec_ref r11
    if is_error(r12) goto L24 (error at dataframe:559) else goto L6
L6:
    r13 = 'protocol'
    r14 = PyObject_SetItem(r12, r13, r10)
    dec_ref r10
    r15 = r14 >= 0 :: signed
    if not r15 goto L25 (error at dataframe:560) else goto L7 :: bool
L7:
    r16 = PyList_Append(r0, r12)
    dec_ref r12
    r17 = r16 >= 0 :: signed
    if not r17 goto L26 (error at dataframe:561) else goto L8 :: bool
L8:
    r18 = CPyDict_CheckSize(self, r3)
    if not r18 goto L26 (error at dataframe:558) else goto L2 :: bool
L9:
    r19 = CPy_NoErrOccurred()
    if not r19 goto L20 (error at dataframe:558) else goto L10 :: bool
L10:
    r20 = get_element_ptr r0 ob_size :: PyVarObject
    r21 = load_mem r20 :: native_int*
    r22 = r21 << 1
    r23 = r22 != 0
    if r23 goto L11 else goto L27 :: bool
L11:
    r24 = eth_portfolio.typing.globals :: static
    r25 = 'concat'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L20 (error at dataframe:562) else goto L12
L12:
    r27 = [r0]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r26, r28, 1, 0)
    dec_ref r26
    if is_error(r29) goto L20 (error at dataframe:562) else goto L13
L13:
    dec_ref r0
    r30 = 'reset_index'
    r31 = box(bool, 1)
    r32 = [r29, r31]
    r33 = load_address r32
    r34 = ('drop',)
    r35 = PyObject_VectorcallMethod(r30, r33, 9223372036854775809, r34)
    if is_error(r35) goto L28 (error at dataframe:562) else goto L14
L14:
    dec_ref r29
    r36 = r35
    goto L18
L15:
    r37 = eth_portfolio.typing.globals :: static
    r38 = 'DataFrame'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L19 (error at dataframe:562) else goto L16
L16:
    r40 = _PyObject_Vectorcall(r39, 0, 0, 0)
    dec_ref r39
    if is_error(r40) goto L19 (error at dataframe:562) else goto L17
L17:
    r36 = r40
L18:
    return r36
L19:
    r41 = <error> :: object
    return r41
L20:
    dec_ref r0
    goto L19
L21:
    dec_ref r4
    dec_ref r5
    goto L9
L22:
    dec_ref r0
    dec_ref r4
    dec_ref r9
    goto L19
L23:
    dec_ref r0
    dec_ref r4
    dec_ref r10
    goto L19
L24:
    dec_ref r0
    dec_ref r4
    dec_ref r10
    goto L19
L25:
    dec_ref r0
    dec_ref r4
    dec_ref r12
    goto L19
L26:
    dec_ref r0
    dec_ref r4
    goto L19
L27:
    dec_ref r0
    goto L15
L28:
    dec_ref r29
    goto L19

def RemoteTokenBalances.sum_usd(self):
    self :: dict
    r0 :: object
    r1 :: union[object, int]
    r2 :: short_int
    r3 :: native_int
    r4 :: short_int
    r5 :: object
    r6 :: tuple[bool, short_int, object]
    r7 :: short_int
    r8 :: bool
    r9 :: object
    r10 :: eth_portfolio.typing.TokenBalances
    r11, r12 :: object
    r13, r14 :: bit
    r15 :: dict
    r16 :: str
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20, r21 :: object
L0:
    r0 = object 0
    inc_ref r0
    r1 = r0
    r2 = 0
    r3 = PyDict_Size(self)
    r4 = r3 << 1
    r5 = CPyDict_GetValuesIter(self)
    if is_error(r5) goto L12 (error at sum_usd:577) else goto L1
L1:
    r6 = CPyDict_NextValue(r5, r2)
    r7 = r6[1]
    r2 = r7
    r8 = r6[0]
    if r8 goto L2 else goto L13 :: bool
L2:
    r9 = r6[2]
    dec_ref r6
    r10 = cast(eth_portfolio.typing.TokenBalances, r9)
    if is_error(r10) goto L14 (error at sum_usd:577) else goto L3
L3:
    r11 = r10.sum_usd()
    dec_ref r10
    if is_error(r11) goto L14 (error at sum_usd:577) else goto L4
L4:
    r12 = PyNumber_Add(r1, r11)
    dec_ref r1
    dec_ref r11
    if is_error(r12) goto L15 (error at sum_usd:-1) else goto L5
L5:
    r1 = r12
L6:
    r13 = CPyDict_CheckSize(self, r4)
    if not r13 goto L14 (error at sum_usd:577) else goto L1 :: bool
L7:
    r14 = CPy_NoErrOccurred()
    if not r14 goto L12 (error at sum_usd:577) else goto L8 :: bool
L8:
    r15 = eth_portfolio.typing.globals :: static
    r16 = 'Decimal'
    r17 = CPyDict_GetItem(r15, r16)
    if is_error(r17) goto L12 (error at sum_usd:577) else goto L9
L9:
    r18 = [r1]
    r19 = load_address r18
    r20 = _PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L12 (error at sum_usd:577) else goto L10
L10:
    dec_ref r1
    return r20
L11:
    r21 = <error> :: object
    return r21
L12:
    dec_ref r1
    goto L11
L13:
    dec_ref r5
    dec_ref r6
    goto L7
L14:
    dec_ref r1
    dec_ref r5
    goto L11
L15:
    dec_ref r5
    goto L11

def RemoteTokenBalances.__bool__(self):
    self :: dict
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bool
L0:
    r0 = CPyDict_ValuesView(self)
    if is_error(r0) goto L5 (error at __bool__:591) else goto L1
L1:
    r1 = builtins :: module
    r2 = 'any'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L6 (error at __bool__:591) else goto L2
L2:
    r4 = [r0]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L6 (error at __bool__:591) else goto L3
L3:
    dec_ref r0
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L5 (error at __bool__:591) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: bool
    return r8
L6:
    dec_ref r0
    goto L5

def RemoteTokenBalances.__repr__(self):
    self :: dict
    r0 :: str
    r1 :: dict
    r2, r3, r4 :: str
L0:
    r0 = 'RemoteTokenBalances'
    r1 = PyDict_Copy(self)
    if is_error(r1) goto L4 (error at __repr__:600) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:600) else goto L2
L2:
    r3 = CPyStr_Build(2, r0, r2)
    dec_ref r2
    if is_error(r3) goto L4 (error at __repr__:600) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: str
    return r4

def RemoteTokenBalances.__add__(self, other):
    self, other :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: union[int, None]
    r26 :: str
    r27 :: object
    r28 :: union[int, None]
    r29 :: object
    r30 :: bool
    r31, r32 :: str
    r33 :: object
    r34 :: union[int, None]
    r35, r36, r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40, r41, r42 :: str
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: union[int, None]
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: dict
    r58 :: short_int
    r59 :: native_int
    r60 :: short_int
    r61 :: object
    r62 :: tuple[bool, short_int, object, object]
    r63 :: short_int
    r64 :: bool
    r65, r66 :: object
    r67 :: str
    r68 :: eth_portfolio.typing.TokenBalances
    protocol :: str
    token_balances :: eth_portfolio.typing.TokenBalances
    r69 :: bool
    r70, r71 :: object
    r72 :: i32
    r73, r74, r75 :: bit
    r76 :: short_int
    r77 :: native_int
    r78 :: short_int
    r79 :: object
    r80 :: tuple[bool, short_int, object, object]
    r81 :: short_int
    r82 :: bool
    r83, r84 :: object
    r85 :: str
    r86 :: eth_portfolio.typing.TokenBalances
    r87 :: bool
    r88, r89 :: object
    r90 :: i32
    r91, r92, r93 :: bit
    r94 :: dict
L0:
    r0 = eth_portfolio.typing.RemoteTokenBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L53 (error at __add__:623) else goto L2
L2:
    r11 = ' is not a RemoteTokenBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L54 (error at __add__:623) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L53 (error at __add__:623) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L55 (error at __add__:623) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L55 (error at __add__:623) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L53 (error at __add__:623) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = 'block'
    r24 = CPyObject_GetAttr(self, r23)
    if is_error(r24) goto L53 (error at __add__:624) else goto L9
L9:
    r25 = cast(union[int, None], r24)
    if is_error(r25) goto L53 (error at __add__:624) else goto L10
L10:
    r26 = 'block'
    r27 = CPyObject_GetAttr(other, r26)
    if is_error(r27) goto L56 (error at __add__:624) else goto L11
L11:
    r28 = cast(union[int, None], r27)
    if is_error(r28) goto L56 (error at __add__:624) else goto L12
L12:
    r29 = PyObject_RichCompare(r25, r28, 3)
    dec_ref r25
    dec_ref r28
    if is_error(r29) goto L53 (error at __add__:624) else goto L13
L13:
    r30 = unbox(bool, r29)
    dec_ref r29
    if is_error(r30) goto L53 (error at __add__:624) else goto L14
L14:
    if r30 goto L15 else goto L26 :: bool
L15:
    r31 = 'These RemoteTokenBalances objects are not from the same block ('
    r32 = 'block'
    r33 = CPyObject_GetAttr(self, r32)
    if is_error(r33) goto L53 (error at __add__:626) else goto L16
L16:
    r34 = cast(union[int, None], r33)
    if is_error(r34) goto L53 (error at __add__:626) else goto L17
L17:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L53 (error at __add__:626) else goto L18
L18:
    r36 = ' and '
    r37 = 'block'
    r38 = CPyObject_GetAttr(other, r37)
    if is_error(r38) goto L57 (error at __add__:626) else goto L19
L19:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L57 (error at __add__:626) else goto L20
L20:
    r40 = PyObject_Str(r39)
    dec_ref r39
    if is_error(r40) goto L57 (error at __add__:626) else goto L21
L21:
    r41 = ')'
    r42 = CPyStr_Build(5, r31, r35, r36, r40, r41)
    dec_ref r35
    dec_ref r40
    if is_error(r42) goto L53 (error at __add__:626) else goto L22
L22:
    r43 = builtins :: module
    r44 = 'ValueError'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L58 (error at __add__:625) else goto L23
L23:
    r46 = [r42]
    r47 = load_address r46
    r48 = _PyObject_Vectorcall(r45, r47, 1, 0)
    dec_ref r45
    if is_error(r48) goto L58 (error at __add__:625) else goto L24
L24:
    dec_ref r42
    CPy_Raise(r48)
    dec_ref r48
    if not 0 goto L53 (error at __add__:625) else goto L25 :: bool
L25:
    unreachable
L26:
    r49 = 'block'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L53 (error at __add__:629) else goto L27
L27:
    r51 = cast(union[int, None], r50)
    if is_error(r51) goto L53 (error at __add__:629) else goto L28
L28:
    r52 = eth_portfolio.typing.RemoteTokenBalances :: type
    r53 = [r51]
    r54 = load_address r53
    r55 = ('block',)
    r56 = _PyObject_Vectorcall(r52, r54, 0, r55)
    if is_error(r56) goto L59 (error at __add__:629) else goto L29
L29:
    dec_ref r51
    r57 = cast(dict, r56)
    if is_error(r57) goto L53 (error at __add__:629) else goto L30
L30:
    r58 = 0
    r59 = PyDict_Size(self)
    r60 = r59 << 1
    r61 = CPyDict_GetItemsIter(self)
    if is_error(r61) goto L60 (error at __add__:630) else goto L31
L31:
    r62 = CPyDict_NextItem(r61, r58)
    r63 = r62[1]
    r58 = r63
    r64 = r62[0]
    if r64 goto L32 else goto L61 :: bool
L32:
    r65 = r62[2]
    r66 = r62[3]
    dec_ref r62
    r67 = cast(str, r65)
    if is_error(r67) goto L62 (error at __add__:630) else goto L33
L33:
    r68 = cast(eth_portfolio.typing.TokenBalances, r66)
    if is_error(r68) goto L63 (error at __add__:630) else goto L34
L34:
    protocol = r67
    token_balances = r68
    r69 = token_balances.__bool__()
    if is_error(r69) goto L64 (error at __add__:630) else goto L35
L35:
    if r69 goto L36 else goto L65 :: bool
L36:
    r70 = CPyDict_GetItem(r57, protocol)
    if is_error(r70) goto L64 (error at __add__:632) else goto L37
L37:
    r71 = PyNumber_InPlaceAdd(r70, token_balances)
    dec_ref r70
    dec_ref token_balances
    if is_error(r71) goto L66 (error at __add__:632) else goto L38
L38:
    r72 = CPyDict_SetItem(r57, protocol, r71)
    dec_ref protocol
    dec_ref r71
    r73 = r72 >= 0 :: signed
    if not r73 goto L67 (error at __add__:632) else goto L39 :: bool
L39:
    r74 = CPyDict_CheckSize(self, r60)
    if not r74 goto L67 (error at __add__:630) else goto L31 :: bool
L40:
    r75 = CPy_NoErrOccurred()
    if not r75 goto L60 (error at __add__:630) else goto L41 :: bool
L41:
    r76 = 0
    r77 = PyDict_Size(other)
    r78 = r77 << 1
    r79 = CPyDict_GetItemsIter(other)
    if is_error(r79) goto L60 (error at __add__:633) else goto L42
L42:
    r80 = CPyDict_NextItem(r79, r76)
    r81 = r80[1]
    r76 = r81
    r82 = r80[0]
    if r82 goto L43 else goto L68 :: bool
L43:
    r83 = r80[2]
    r84 = r80[3]
    dec_ref r80
    r85 = cast(str, r83)
    if is_error(r85) goto L69 (error at __add__:633) else goto L44
L44:
    r86 = cast(eth_portfolio.typing.TokenBalances, r84)
    if is_error(r86) goto L70 (error at __add__:633) else goto L45
L45:
    protocol = r85
    token_balances = r86
    r87 = token_balances.__bool__()
    if is_error(r87) goto L71 (error at __add__:630) else goto L46
L46:
    if r87 goto L47 else goto L72 :: bool
L47:
    r88 = CPyDict_GetItem(r57, protocol)
    if is_error(r88) goto L71 (error at __add__:635) else goto L48
L48:
    r89 = PyNumber_InPlaceAdd(r88, token_balances)
    dec_ref r88
    dec_ref token_balances
    if is_error(r89) goto L73 (error at __add__:635) else goto L49
L49:
    r90 = CPyDict_SetItem(r57, protocol, r89)
    dec_ref protocol
    dec_ref r89
    r91 = r90 >= 0 :: signed
    if not r91 goto L74 (error at __add__:635) else goto L50 :: bool
L50:
    r92 = CPyDict_CheckSize(other, r78)
    if not r92 goto L74 (error at __add__:633) else goto L42 :: bool
L51:
    r93 = CPy_NoErrOccurred()
    if not r93 goto L60 (error at __add__:633) else goto L52 :: bool
L52:
    return r57
L53:
    r94 = <error> :: dict
    return r94
L54:
    dec_ref r10
    goto L53
L55:
    dec_ref r16
    goto L53
L56:
    dec_ref r25
    goto L53
L57:
    dec_ref r35
    goto L53
L58:
    dec_ref r42
    goto L53
L59:
    dec_ref r51
    goto L53
L60:
    dec_ref r57
    goto L53
L61:
    dec_ref r61
    dec_ref r62
    goto L40
L62:
    dec_ref r57
    dec_ref r61
    dec_ref r66
    goto L53
L63:
    dec_ref r57
    dec_ref r61
    dec_ref r67
    goto L53
L64:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    dec_ref token_balances
    goto L53
L65:
    dec_ref protocol
    dec_ref token_balances
    goto L39
L66:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    goto L53
L67:
    dec_ref r57
    dec_ref r61
    goto L53
L68:
    dec_ref r79
    dec_ref r80
    goto L51
L69:
    dec_ref r57
    dec_ref r79
    dec_ref r84
    goto L53
L70:
    dec_ref r57
    dec_ref r79
    dec_ref r85
    goto L53
L71:
    dec_ref r57
    dec_ref protocol
    dec_ref token_balances
    dec_ref r79
    goto L53
L72:
    dec_ref protocol
    dec_ref token_balances
    goto L50
L73:
    dec_ref r57
    dec_ref protocol
    dec_ref r79
    goto L53
L74:
    dec_ref r57
    dec_ref r79
    goto L53

def RemoteTokenBalances.__add_____SummableNonNumericMixin_glue(self, other):
    self :: eth_portfolio.typing.RemoteTokenBalances
    other :: eth_portfolio.typing._SummableNonNumericMixin
    r0, r1, r2 :: dict
    r3, r4 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    inc_ref self
    r0 = cast(dict, self)
    if is_error(r0) goto L5 else goto L1
L1:
    inc_ref other
    r1 = cast(dict, other)
    if is_error(r1) goto L6 else goto L2
L2:
    r2 = RemoteTokenBalances.__add__(r0, r1)
    dec_ref r0
    dec_ref r1
    if is_error(r2) goto L5 else goto L3
L3:
    r3 = cast(eth_portfolio.typing._SummableNonNumericMixin, r2)
    if is_error(r3) goto L5 else goto L4
L4:
    return r3
L5:
    r4 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r4
L6:
    dec_ref r0
    goto L5

def RemoteTokenBalances.__sub__(self, other):
    self, other :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: union[int, None]
    r26 :: str
    r27 :: object
    r28 :: union[int, None]
    r29 :: object
    r30 :: bool
    r31, r32 :: str
    r33 :: object
    r34 :: union[int, None]
    r35, r36, r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40, r41, r42 :: str
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: union[int, None]
    r52 :: object
    r53 :: object[2]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: dict
    r58 :: short_int
    r59 :: native_int
    r60 :: short_int
    r61 :: object
    r62 :: tuple[bool, short_int, object, object]
    r63 :: short_int
    r64 :: bool
    r65, r66 :: object
    r67 :: str
    r68 :: eth_portfolio.typing.TokenBalances
    protocol :: str
    token_balances :: eth_portfolio.typing.TokenBalances
    r69, r70 :: object
    r71 :: i32
    r72, r73, r74 :: bit
    r75 :: dict
    r76 :: short_int
    r77 :: native_int
    r78 :: short_int
    r79 :: object
    r80 :: tuple[bool, short_int, object, object]
    r81 :: short_int
    r82 :: bool
    r83, r84 :: object
    r85 :: str
    r86 :: eth_portfolio.typing.TokenBalances
    r87 :: bool
    r88 :: i32
    r89, r90, r91 :: bit
    r92 :: dict
L0:
    r0 = eth_portfolio.typing.RemoteTokenBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L50 (error at __sub__:659) else goto L2
L2:
    r11 = ' is not a RemoteTokenBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L51 (error at __sub__:659) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L50 (error at __sub__:659) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L52 (error at __sub__:659) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L52 (error at __sub__:659) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L50 (error at __sub__:659) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = 'block'
    r24 = CPyObject_GetAttr(self, r23)
    if is_error(r24) goto L50 (error at __sub__:660) else goto L9
L9:
    r25 = cast(union[int, None], r24)
    if is_error(r25) goto L50 (error at __sub__:660) else goto L10
L10:
    r26 = 'block'
    r27 = CPyObject_GetAttr(other, r26)
    if is_error(r27) goto L53 (error at __sub__:660) else goto L11
L11:
    r28 = cast(union[int, None], r27)
    if is_error(r28) goto L53 (error at __sub__:660) else goto L12
L12:
    r29 = PyObject_RichCompare(r25, r28, 3)
    dec_ref r25
    dec_ref r28
    if is_error(r29) goto L50 (error at __sub__:660) else goto L13
L13:
    r30 = unbox(bool, r29)
    dec_ref r29
    if is_error(r30) goto L50 (error at __sub__:660) else goto L14
L14:
    if r30 goto L15 else goto L26 :: bool
L15:
    r31 = 'These RemoteTokenBalances objects are not from the same block ('
    r32 = 'block'
    r33 = CPyObject_GetAttr(self, r32)
    if is_error(r33) goto L50 (error at __sub__:662) else goto L16
L16:
    r34 = cast(union[int, None], r33)
    if is_error(r34) goto L50 (error at __sub__:662) else goto L17
L17:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L50 (error at __sub__:662) else goto L18
L18:
    r36 = ' and '
    r37 = 'block'
    r38 = CPyObject_GetAttr(other, r37)
    if is_error(r38) goto L54 (error at __sub__:662) else goto L19
L19:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L54 (error at __sub__:662) else goto L20
L20:
    r40 = PyObject_Str(r39)
    dec_ref r39
    if is_error(r40) goto L54 (error at __sub__:662) else goto L21
L21:
    r41 = ')'
    r42 = CPyStr_Build(5, r31, r35, r36, r40, r41)
    dec_ref r35
    dec_ref r40
    if is_error(r42) goto L50 (error at __sub__:662) else goto L22
L22:
    r43 = builtins :: module
    r44 = 'ValueError'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L55 (error at __sub__:661) else goto L23
L23:
    r46 = [r42]
    r47 = load_address r46
    r48 = _PyObject_Vectorcall(r45, r47, 1, 0)
    dec_ref r45
    if is_error(r48) goto L55 (error at __sub__:661) else goto L24
L24:
    dec_ref r42
    CPy_Raise(r48)
    dec_ref r48
    if not 0 goto L50 (error at __sub__:661) else goto L25 :: bool
L25:
    unreachable
L26:
    r49 = 'block'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L50 (error at __sub__:665) else goto L27
L27:
    r51 = cast(union[int, None], r50)
    if is_error(r51) goto L50 (error at __sub__:665) else goto L28
L28:
    r52 = eth_portfolio.typing.RemoteTokenBalances :: type
    r53 = [self, r51]
    r54 = load_address r53
    r55 = ('block',)
    r56 = _PyObject_Vectorcall(r52, r54, 1, r55)
    if is_error(r56) goto L56 (error at __sub__:665) else goto L29
L29:
    dec_ref r51
    r57 = cast(dict, r56)
    if is_error(r57) goto L50 (error at __sub__:665) else goto L30
L30:
    r58 = 0
    r59 = PyDict_Size(other)
    r60 = r59 << 1
    r61 = CPyDict_GetItemsIter(other)
    if is_error(r61) goto L57 (error at __sub__:666) else goto L31
L31:
    r62 = CPyDict_NextItem(r61, r58)
    r63 = r62[1]
    r58 = r63
    r64 = r62[0]
    if r64 goto L32 else goto L58 :: bool
L32:
    r65 = r62[2]
    r66 = r62[3]
    dec_ref r62
    r67 = cast(str, r65)
    if is_error(r67) goto L59 (error at __sub__:666) else goto L33
L33:
    r68 = cast(eth_portfolio.typing.TokenBalances, r66)
    if is_error(r68) goto L60 (error at __sub__:666) else goto L34
L34:
    protocol = r67
    token_balances = r68
    r69 = CPyDict_GetItem(r57, protocol)
    if is_error(r69) goto L61 (error at __sub__:667) else goto L35
L35:
    r70 = PyNumber_InPlaceSubtract(r69, token_balances)
    dec_ref r69
    dec_ref token_balances
    if is_error(r70) goto L62 (error at __sub__:667) else goto L36
L36:
    r71 = CPyDict_SetItem(r57, protocol, r70)
    dec_ref protocol
    dec_ref r70
    r72 = r71 >= 0 :: signed
    if not r72 goto L63 (error at __sub__:667) else goto L37 :: bool
L37:
    r73 = CPyDict_CheckSize(other, r60)
    if not r73 goto L63 (error at __sub__:666) else goto L31 :: bool
L38:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L57 (error at __sub__:666) else goto L39 :: bool
L39:
    r75 = PyDict_Copy(r57)
    if is_error(r75) goto L57 (error at __sub__:668) else goto L40
L40:
    r76 = 0
    r77 = PyDict_Size(r75)
    r78 = r77 << 1
    r79 = CPyDict_GetItemsIter(r75)
    if is_error(r79) goto L64 (error at __sub__:668) else goto L41
L41:
    r80 = CPyDict_NextItem(r79, r76)
    r81 = r80[1]
    r76 = r81
    r82 = r80[0]
    if r82 goto L42 else goto L65 :: bool
L42:
    r83 = r80[2]
    r84 = r80[3]
    dec_ref r80
    r85 = cast(str, r83)
    if is_error(r85) goto L66 (error at __sub__:668) else goto L43
L43:
    r86 = cast(eth_portfolio.typing.TokenBalances, r84)
    if is_error(r86) goto L67 (error at __sub__:668) else goto L44
L44:
    protocol = r85
    token_balances = r86
    r87 = token_balances.__bool__()
    dec_ref token_balances
    if is_error(r87) goto L68 (error at __sub__:666) else goto L45
L45:
    if r87 goto L69 else goto L46 :: bool
L46:
    r88 = PyObject_DelItem(r57, protocol)
    dec_ref protocol
    r89 = r88 >= 0 :: signed
    if not r89 goto L70 (error at __sub__:670) else goto L47 :: bool
L47:
    r90 = CPyDict_CheckSize(r75, r78)
    if not r90 goto L70 (error at __sub__:668) else goto L41 :: bool
L48:
    r91 = CPy_NoErrOccurred()
    if not r91 goto L57 (error at __sub__:668) else goto L49 :: bool
L49:
    return r57
L50:
    r92 = <error> :: dict
    return r92
L51:
    dec_ref r10
    goto L50
L52:
    dec_ref r16
    goto L50
L53:
    dec_ref r25
    goto L50
L54:
    dec_ref r35
    goto L50
L55:
    dec_ref r42
    goto L50
L56:
    dec_ref r51
    goto L50
L57:
    dec_ref r57
    goto L50
L58:
    dec_ref r61
    dec_ref r62
    goto L38
L59:
    dec_ref r57
    dec_ref r61
    dec_ref r66
    goto L50
L60:
    dec_ref r57
    dec_ref r61
    dec_ref r67
    goto L50
L61:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    dec_ref token_balances
    goto L50
L62:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    goto L50
L63:
    dec_ref r57
    dec_ref r61
    goto L50
L64:
    dec_ref r57
    dec_ref r75
    goto L50
L65:
    dec_ref r75
    dec_ref r79
    dec_ref r80
    goto L48
L66:
    dec_ref r57
    dec_ref r75
    dec_ref r79
    dec_ref r84
    goto L50
L67:
    dec_ref r57
    dec_ref r75
    dec_ref r79
    dec_ref r85
    goto L50
L68:
    dec_ref r57
    dec_ref protocol
    dec_ref r75
    dec_ref r79
    goto L50
L69:
    dec_ref protocol
    goto L47
L70:
    dec_ref r57
    dec_ref r75
    dec_ref r79
    goto L50

def WalletBalances.__init__(self, seed, block):
    self :: dict
    seed :: union[dict, object, None]
    block :: union[int, None]
    r0, r1, r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10, r11 :: object
    r12 :: str
    r13 :: i32
    r14 :: bit
    r15, r16, r17 :: str
    r18 :: tuple[str, str, str]
    r19 :: str
    r20 :: object
    r21 :: i32
    r22 :: bit
    r23 :: union[dict, object, None]
    r24 :: eth_portfolio.typing.TokenBalances
    r25 :: str
    r26 :: i32
    r27 :: bit
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31, r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40, r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: bit
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: bool
    r52 :: dict
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: i32
    r58 :: bit
    r59 :: bool
    r60, r61, r62, r63 :: str
    r64 :: object[3]
    r65 :: object_ptr
    r66 :: object
    r67 :: str
    r68 :: list
    r69, r70, r71 :: ptr
    r72 :: str
    r73 :: object
    r74 :: str
    r75 :: object
    r76 :: object[1]
    r77 :: object_ptr
    r78, r79, r80 :: object
    r81 :: union[str, tuple[str, eth_portfolio.typing.TokenBalances]]
    r82, r83 :: object
    r84 :: bool
    key :: union[object, str]
    r85 :: object
    r86 :: bool
    balances :: union[object, eth_portfolio.typing.TokenBalances]
    r87 :: object
    r88 :: bool
    r89 :: str
    r90 :: object
    r91 :: union[int, None]
    r92 :: object
    r93 :: ptr
    r94 :: object
    r95 :: bit
    r96 :: eth_portfolio.typing.TokenBalances
    r97 :: union[int, None]
    r98 :: union[object, int, None]
    r99 :: object
    r100 :: str
    r101, r102 :: object
    r103 :: bool
    r104, r105 :: str
    r106 :: object
    r107 :: union[int, None]
    r108, r109 :: str
    r110 :: object
    r111 :: ptr
    r112 :: object
    r113 :: bit
    r114 :: eth_portfolio.typing.TokenBalances
    r115 :: union[int, None]
    r116 :: union[object, int, None]
    r117 :: object
    r118 :: str
    r119 :: object
    r120, r121, r122 :: str
    r123 :: object
    r124 :: str
    r125 :: object
    r126 :: object[1]
    r127 :: object_ptr
    r128 :: object
    r129 :: str
    r130 :: object[3]
    r131 :: object_ptr
    r132, r133, r134 :: object
    r135 :: i32
    r136, r137 :: bit
    r138 :: None
L0:
    if is_error(seed) goto L1 else goto L79
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    if is_error(block) goto L3 else goto L80
L3:
    r1 = box(None, 1)
    inc_ref r1
    block = r1
L4:
    r2 = builtins :: module
    r3 = 'super'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L81 (error at __init__:703) else goto L5
L5:
    r5 = eth_portfolio.typing.WalletBalances :: type
    r6 = [r5, self]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r4, r7, 2, 0)
    dec_ref r4
    if is_error(r8) goto L81 (error at __init__:703) else goto L6
L6:
    r9 = '__init__'
    r10 = CPyObject_GetAttr(r8, r9)
    dec_ref r8
    if is_error(r10) goto L81 (error at __init__:703) else goto L7
L7:
    r11 = _PyObject_Vectorcall(r10, 0, 0, 0)
    dec_ref r10
    if is_error(r11) goto L81 (error at __init__:703) else goto L82
L8:
    r12 = 'block'
    r13 = PyObject_SetAttr(self, r12, block)
    r14 = r13 >= 0 :: signed
    if not r14 goto L81 (error at __init__:704) else goto L9 :: bool
L9:
    r15 = 'assets'
    r16 = 'debt'
    r17 = 'external'
    inc_ref r15
    inc_ref r16
    inc_ref r17
    r18 = (r15, r16, r17)
    r19 = '_keys'
    r20 = box(tuple[str, str, str], r18)
    r21 = PyObject_SetAttr(self, r19, r20)
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L81 (error at __init__:705) else goto L10 :: bool
L10:
    r23 = <error> :: union[dict, object, None]
    r24 = TokenBalances(r23, block)
    if is_error(r24) goto L81 (error at __init__:706) else goto L11
L11:
    r25 = 'assets'
    r26 = CPyDict_SetItem(self, r25, r24)
    dec_ref r24
    r27 = r26 >= 0 :: signed
    if not r27 goto L81 (error at __init__:706) else goto L12 :: bool
L12:
    r28 = eth_portfolio.typing.RemoteTokenBalances :: type
    r29 = [block]
    r30 = load_address r29
    r31 = ('block',)
    r32 = _PyObject_Vectorcall(r28, r30, 0, r31)
    if is_error(r32) goto L81 (error at __init__:707) else goto L13
L13:
    r33 = cast(dict, r32)
    if is_error(r33) goto L81 (error at __init__:707) else goto L14
L14:
    r34 = 'debt'
    r35 = CPyDict_SetItem(self, r34, r33)
    dec_ref r33
    r36 = r35 >= 0 :: signed
    if not r36 goto L81 (error at __init__:707) else goto L15 :: bool
L15:
    r37 = eth_portfolio.typing.RemoteTokenBalances :: type
    r38 = [block]
    r39 = load_address r38
    r40 = ('block',)
    r41 = _PyObject_Vectorcall(r37, r39, 0, r40)
    if is_error(r41) goto L81 (error at __init__:708) else goto L16
L16:
    dec_ref block
    r42 = cast(dict, r41)
    if is_error(r42) goto L83 (error at __init__:708) else goto L17
L17:
    r43 = 'external'
    r44 = CPyDict_SetItem(self, r43, r42)
    dec_ref r42
    r45 = r44 >= 0 :: signed
    if not r45 goto L83 (error at __init__:708) else goto L18 :: bool
L18:
    r46 = load_address _Py_NoneStruct
    r47 = seed == r46
    if r47 goto L84 else goto L20 :: bool
L19:
    return 1
L20:
    r48 = load_address PyDict_Type
    r49 = PyObject_IsInstance(seed, r48)
    r50 = r49 >= 0 :: signed
    if not r50 goto L83 (error at __init__:712) else goto L21 :: bool
L21:
    r51 = truncate r49: i32 to builtins.bool
    if r51 goto L22 else goto L25 :: bool
L22:
    r52 = cast(dict, seed)
    if is_error(r52) goto L78 (error at __init__:713) else goto L23
L23:
    r53 = CPyDict_ItemsView(r52)
    dec_ref r52
    if is_error(r53) goto L78 (error at __init__:713) else goto L24
L24:
    seed = r53
L25:
    r54 = eth_portfolio.typing.globals :: static
    r55 = 'Iterable'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L83 (error at __init__:714) else goto L26
L26:
    r57 = PyObject_IsInstance(seed, r56)
    dec_ref r56
    r58 = r57 >= 0 :: signed
    if not r58 goto L83 (error at __init__:714) else goto L27 :: bool
L27:
    r59 = truncate r57: i32 to builtins.bool
    if r59 goto L35 else goto L28 :: bool
L28:
    r60 = ''
    r61 = '{:{}}'
    r62 = ''
    r63 = 'format'
    r64 = [r61, seed, r62]
    r65 = load_address r64
    r66 = PyObject_VectorcallMethod(r63, r65, 9223372036854775811, 0)
    if is_error(r66) goto L83 (error at __init__:715) else goto L29
L29:
    dec_ref seed
    r67 = ' is not a valid input for WalletBalances'
    r68 = PyList_New(2)
    if is_error(r68) goto L85 (error at __init__:715) else goto L30
L30:
    r69 = get_element_ptr r68 ob_item :: PyListObject
    r70 = load_mem r69 :: ptr*
    set_mem r70, r66 :: builtins.object*
    inc_ref r67
    r71 = r70 + 8
    set_mem r71, r67 :: builtins.object*
    r72 = PyUnicode_Join(r60, r68)
    dec_ref r68
    if is_error(r72) goto L78 (error at __init__:715) else goto L31
L31:
    r73 = builtins :: module
    r74 = 'TypeError'
    r75 = CPyObject_GetAttr(r73, r74)
    if is_error(r75) goto L86 (error at __init__:715) else goto L32
L32:
    r76 = [r72]
    r77 = load_address r76
    r78 = _PyObject_Vectorcall(r75, r77, 1, 0)
    dec_ref r75
    if is_error(r78) goto L86 (error at __init__:715) else goto L33
L33:
    dec_ref r72
    CPy_Raise(r78)
    dec_ref r78
    if not 0 goto L78 (error at __init__:715) else goto L34 :: bool
L34:
    unreachable
L35:
    r79 = PyObject_GetIter(seed)
    dec_ref seed
    if is_error(r79) goto L78 (error at __init__:716) else goto L36
L36:
    r80 = PyIter_Next(r79)
    if is_error(r80) goto L87 else goto L37
L37:
    r81 = cast(union[str, tuple[str, eth_portfolio.typing.TokenBalances]], r80)
    if is_error(r81) goto L88 (error at __init__:716) else goto L38
L38:
    r82 = PyObject_GetIter(r81)
    dec_ref r81
    if is_error(r82) goto L88 (error at __init__:716) else goto L39
L39:
    r83 = PyIter_Next(r82)
    if is_error(r83) goto L89 else goto L42
L40:
    r84 = raise ValueError('not enough values to unpack')
    if not r84 goto L78 (error at __init__:716) else goto L41 :: bool
L41:
    unreachable
L42:
    key = r83
    r85 = PyIter_Next(r82)
    if is_error(r85) goto L90 else goto L45
L43:
    r86 = raise ValueError('not enough values to unpack')
    if not r86 goto L78 (error at __init__:716) else goto L44 :: bool
L44:
    unreachable
L45:
    balances = r85
    r87 = PyIter_Next(r82)
    dec_ref r82
    if is_error(r87) goto L48 else goto L91
L46:
    r88 = raise ValueError('too many values to unpack')
    if not r88 goto L78 (error at __init__:716) else goto L47 :: bool
L47:
    unreachable
L48:
    r89 = 'block'
    r90 = CPyObject_GetAttr(self, r89)
    if is_error(r90) goto L92 (error at __init__:717) else goto L49
L49:
    r91 = cast(union[int, None], r90)
    if is_error(r91) goto L92 (error at __init__:717) else goto L50
L50:
    r92 = eth_portfolio.typing.TokenBalances :: type
    r93 = get_element_ptr balances ob_type :: PyObject
    r94 = load_mem r93 :: builtins.object*
    r95 = r94 == r92
    if r95 goto L51 else goto L53 :: bool
L51:
    inc_ref balances
    r96 = cast(eth_portfolio.typing.TokenBalances, balances)
    if is_error(r96) goto L93 (error at __init__:717) else goto L52
L52:
    r97 = r96.block
    dec_ref r96
    r98 = r97
    goto L55
L53:
    inc_ref balances
    r99 = balances
    r100 = 'block'
    r101 = CPyObject_GetAttr(r99, r100)
    dec_ref r99
    if is_error(r101) goto L93 (error at __init__:717) else goto L54
L54:
    r98 = r101
L55:
    r102 = PyObject_RichCompare(r91, r98, 3)
    dec_ref r91
    dec_ref r98
    if is_error(r102) goto L92 (error at __init__:717) else goto L56
L56:
    r103 = unbox(bool, r102)
    dec_ref r102
    if is_error(r103) goto L92 (error at __init__:717) else goto L57
L57:
    if r103 goto L94 else goto L72 :: bool
L58:
    r104 = 'These objects are not from the same block ('
    r105 = 'block'
    r106 = CPyObject_GetAttr(self, r105)
    if is_error(r106) goto L95 (error at __init__:719) else goto L59
L59:
    r107 = cast(union[int, None], r106)
    if is_error(r107) goto L95 (error at __init__:719) else goto L60
L60:
    r108 = PyObject_Str(r107)
    dec_ref r107
    if is_error(r108) goto L95 (error at __init__:719) else goto L61
L61:
    r109 = ' and '
    r110 = eth_portfolio.typing.TokenBalances :: type
    r111 = get_element_ptr balances ob_type :: PyObject
    r112 = load_mem r111 :: builtins.object*
    r113 = r112 == r110
    if r113 goto L62 else goto L64 :: bool
L62:
    r114 = cast(eth_portfolio.typing.TokenBalances, balances)
    if is_error(r114) goto L96 (error at __init__:719) else goto L63
L63:
    r115 = r114.block
    dec_ref r114
    r116 = r115
    goto L66
L64:
    r117 = balances
    r118 = 'block'
    r119 = CPyObject_GetAttr(r117, r118)
    dec_ref r117
    if is_error(r119) goto L96 (error at __init__:719) else goto L65
L65:
    r116 = r119
L66:
    r120 = PyObject_Str(r116)
    dec_ref r116
    if is_error(r120) goto L96 (error at __init__:719) else goto L67
L67:
    r121 = ')'
    r122 = CPyStr_Build(5, r104, r108, r109, r120, r121)
    dec_ref r108
    dec_ref r120
    if is_error(r122) goto L78 (error at __init__:719) else goto L68
L68:
    r123 = builtins :: module
    r124 = 'ValueError'
    r125 = CPyObject_GetAttr(r123, r124)
    if is_error(r125) goto L97 (error at __init__:718) else goto L69
L69:
    r126 = [r122]
    r127 = load_address r126
    r128 = _PyObject_Vectorcall(r125, r127, 1, 0)
    dec_ref r125
    if is_error(r128) goto L97 (error at __init__:718) else goto L70
L70:
    dec_ref r122
    CPy_Raise(r128)
    dec_ref r128
    if not 0 goto L78 (error at __init__:718) else goto L71 :: bool
L71:
    unreachable
L72:
    r129 = '__validateitem'
    r130 = [self, key, balances]
    r131 = load_address r130
    r132 = PyObject_VectorcallMethod(r129, r131, 9223372036854775811, 0)
    if is_error(r132) goto L92 (error at __init__:721) else goto L98
L73:
    r133 = CPyDict_GetItem(self, key)
    if is_error(r133) goto L92 (error at __init__:722) else goto L74
L74:
    r134 = PyNumber_InPlaceAdd(r133, balances)
    dec_ref r133
    dec_ref balances
    if is_error(r134) goto L99 (error at __init__:722) else goto L75
L75:
    r135 = CPyDict_SetItem(self, key, r134)
    dec_ref key
    dec_ref r134
    r136 = r135 >= 0 :: signed
    if not r136 goto L88 (error at __init__:722) else goto L36 :: bool
L76:
    r137 = CPy_NoErrOccurred()
    if not r137 goto L78 (error at __init__:716) else goto L77 :: bool
L77:
    return 1
L78:
    r138 = <error> :: None
    return r138
L79:
    inc_ref seed
    goto L2
L80:
    inc_ref block
    goto L4
L81:
    dec_ref seed
    dec_ref block
    goto L78
L82:
    dec_ref r11
    goto L8
L83:
    dec_ref seed
    goto L78
L84:
    dec_ref seed
    goto L19
L85:
    dec_ref r66
    goto L78
L86:
    dec_ref r72
    goto L78
L87:
    dec_ref r79
    goto L76
L88:
    dec_ref r79
    goto L78
L89:
    dec_ref r79
    dec_ref r82
    goto L40
L90:
    dec_ref r79
    dec_ref r82
    dec_ref key
    goto L43
L91:
    dec_ref r79
    dec_ref key
    dec_ref balances
    dec_ref r87
    goto L46
L92:
    dec_ref r79
    dec_ref key
    dec_ref balances
    goto L78
L93:
    dec_ref r79
    dec_ref key
    dec_ref balances
    dec_ref r91
    goto L78
L94:
    dec_ref r79
    dec_ref key
    goto L58
L95:
    dec_ref balances
    goto L78
L96:
    dec_ref r108
    goto L78
L97:
    dec_ref r122
    goto L78
L98:
    dec_ref r132
    goto L73
L99:
    dec_ref r79
    dec_ref key
    goto L78

def WalletBalances.assets(self):
    self :: dict
    r0 :: str
    r1 :: object
    r2 :: union[eth_portfolio.typing.TokenBalances, dict]
    r3, r4 :: eth_portfolio.typing.TokenBalances
L0:
    r0 = 'assets'
    r1 = CPyDict_GetItem(self, r0)
    if is_error(r1) goto L4 (error at assets:732) else goto L1
L1:
    r2 = cast(union[eth_portfolio.typing.TokenBalances, dict], r1)
    if is_error(r2) goto L4 (error at assets:732) else goto L2
L2:
    r3 = cast(eth_portfolio.typing.TokenBalances, r2)
    if is_error(r3) goto L4 (error at assets:732) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: eth_portfolio.typing.TokenBalances
    return r4

def WalletBalances.debt(self):
    self :: dict
    r0 :: str
    r1 :: object
    r2 :: union[eth_portfolio.typing.TokenBalances, dict]
    r3, r4 :: dict
L0:
    r0 = 'debt'
    r1 = CPyDict_GetItem(self, r0)
    if is_error(r1) goto L4 (error at debt:742) else goto L1
L1:
    r2 = cast(union[eth_portfolio.typing.TokenBalances, dict], r1)
    if is_error(r2) goto L4 (error at debt:742) else goto L2
L2:
    r3 = cast(dict, r2)
    if is_error(r3) goto L4 (error at debt:742) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: dict
    return r4

def WalletBalances.external(self):
    self :: dict
    r0 :: str
    r1 :: object
    r2 :: union[eth_portfolio.typing.TokenBalances, dict]
    r3, r4 :: dict
L0:
    r0 = 'external'
    r1 = CPyDict_GetItem(self, r0)
    if is_error(r1) goto L4 (error at external:752) else goto L1
L1:
    r2 = cast(union[eth_portfolio.typing.TokenBalances, dict], r1)
    if is_error(r2) goto L4 (error at external:752) else goto L2
L2:
    r3 = cast(dict, r2)
    if is_error(r3) goto L4 (error at external:752) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: dict
    return r4

def WalletBalances.dataframe(self):
    self :: dict
    r0 :: list
    r1 :: short_int
    r2 :: native_int
    r3 :: short_int
    r4 :: object
    r5 :: tuple[bool, short_int, object, object]
    r6 :: short_int
    r7 :: bool
    r8, r9 :: object
    r10 :: str
    r11 :: union[eth_portfolio.typing.TokenBalances, dict]
    r12 :: object
    r13 :: ptr
    r14 :: object
    r15 :: bit
    r16 :: eth_portfolio.typing.TokenBalances
    r17, r18, r19 :: object
    r20 :: str
    r21, df :: object
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: i32
    r26, r27, r28 :: bit
    r29 :: ptr
    r30 :: native_int
    r31 :: short_int
    r32 :: bit
    r33 :: dict
    r34 :: str
    r35 :: object
    r36 :: object[1]
    r37 :: object_ptr
    r38 :: object
    r39 :: str
    r40 :: object
    r41 :: object[2]
    r42 :: object_ptr
    r43, r44, r45 :: object
    r46 :: dict
    r47 :: str
    r48, r49, r50 :: object
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L24 (error at dataframe:762) else goto L1
L1:
    r1 = 0
    r2 = PyDict_Size(self)
    r3 = r2 << 1
    r4 = CPyDict_GetItemsIter(self)
    if is_error(r4) goto L25 (error at dataframe:763) else goto L2
L2:
    r5 = CPyDict_NextItem(r4, r1)
    r6 = r5[1]
    r1 = r6
    r7 = r5[0]
    if r7 goto L3 else goto L26 :: bool
L3:
    r8 = r5[2]
    r9 = r5[3]
    dec_ref r5
    r10 = cast(str, r8)
    if is_error(r10) goto L27 (error at dataframe:763) else goto L4
L4:
    r11 = cast(union[eth_portfolio.typing.TokenBalances, dict], r9)
    if is_error(r11) goto L28 (error at dataframe:763) else goto L5
L5:
    r12 = eth_portfolio.typing.TokenBalances :: type
    r13 = get_element_ptr r11 ob_type :: PyObject
    r14 = load_mem r13 :: builtins.object*
    r15 = r14 == r12
    if r15 goto L6 else goto L9 :: bool
L6:
    r16 = cast(eth_portfolio.typing.TokenBalances, r11)
    if is_error(r16) goto L29 (error at dataframe:764) else goto L7
L7:
    r17 = r16.dataframe
    dec_ref r16
    if is_error(r17) goto L29 (error at dataframe:764) else goto L8
L8:
    r18 = r17
    goto L11
L9:
    r19 = r11
    r20 = 'dataframe'
    r21 = CPyObject_GetAttr(r19, r20)
    dec_ref r19
    if is_error(r21) goto L29 (error at dataframe:764) else goto L10
L10:
    r18 = r21
L11:
    df = r18
    r22 = 'category'
    r23 = PyObject_SetItem(df, r22, r10)
    dec_ref r10
    r24 = r23 >= 0 :: signed
    if not r24 goto L30 (error at dataframe:765) else goto L12 :: bool
L12:
    r25 = PyList_Append(r0, df)
    dec_ref df
    r26 = r25 >= 0 :: signed
    if not r26 goto L31 (error at dataframe:766) else goto L13 :: bool
L13:
    r27 = CPyDict_CheckSize(self, r3)
    if not r27 goto L31 (error at dataframe:763) else goto L2 :: bool
L14:
    r28 = CPy_NoErrOccurred()
    if not r28 goto L25 (error at dataframe:763) else goto L15 :: bool
L15:
    r29 = get_element_ptr r0 ob_size :: PyVarObject
    r30 = load_mem r29 :: native_int*
    r31 = r30 << 1
    r32 = r31 != 0
    if r32 goto L16 else goto L32 :: bool
L16:
    r33 = eth_portfolio.typing.globals :: static
    r34 = 'concat'
    r35 = CPyDict_GetItem(r33, r34)
    if is_error(r35) goto L25 (error at dataframe:767) else goto L17
L17:
    r36 = [r0]
    r37 = load_address r36
    r38 = _PyObject_Vectorcall(r35, r37, 1, 0)
    dec_ref r35
    if is_error(r38) goto L25 (error at dataframe:767) else goto L18
L18:
    dec_ref r0
    r39 = 'reset_index'
    r40 = box(bool, 1)
    r41 = [r38, r40]
    r42 = load_address r41
    r43 = ('drop',)
    r44 = PyObject_VectorcallMethod(r39, r42, 9223372036854775809, r43)
    if is_error(r44) goto L33 (error at dataframe:767) else goto L19
L19:
    dec_ref r38
    r45 = r44
    goto L23
L20:
    r46 = eth_portfolio.typing.globals :: static
    r47 = 'DataFrame'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L24 (error at dataframe:767) else goto L21
L21:
    r49 = _PyObject_Vectorcall(r48, 0, 0, 0)
    dec_ref r48
    if is_error(r49) goto L24 (error at dataframe:767) else goto L22
L22:
    r45 = r49
L23:
    return r45
L24:
    r50 = <error> :: object
    return r50
L25:
    dec_ref r0
    goto L24
L26:
    dec_ref r4
    dec_ref r5
    goto L14
L27:
    dec_ref r0
    dec_ref r4
    dec_ref r9
    goto L24
L28:
    dec_ref r0
    dec_ref r4
    dec_ref r10
    goto L24
L29:
    dec_ref r0
    dec_ref r4
    dec_ref r10
    goto L24
L30:
    dec_ref r0
    dec_ref r4
    dec_ref df
    goto L24
L31:
    dec_ref r0
    dec_ref r4
    goto L24
L32:
    dec_ref r0
    goto L20
L33:
    dec_ref r38
    goto L24

def WalletBalances.sum_usd(self):
    self :: dict
    r0 :: str
    r1 :: object
    r2 :: eth_portfolio.typing.TokenBalances
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: dict
    r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object[1]
    r17 :: object_ptr
    r18, r19, r20 :: object
L0:
    r0 = 'assets'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L12 (error at sum_usd:782) else goto L1
L1:
    r2 = cast(eth_portfolio.typing.TokenBalances, r1)
    if is_error(r2) goto L12 (error at sum_usd:782) else goto L2
L2:
    r3 = r2.sum_usd()
    dec_ref r2
    if is_error(r3) goto L12 (error at sum_usd:782) else goto L3
L3:
    r4 = 'debt'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L13 (error at sum_usd:782) else goto L4
L4:
    r6 = cast(dict, r5)
    if is_error(r6) goto L13 (error at sum_usd:782) else goto L5
L5:
    r7 = 'sum_usd'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L14 (error at sum_usd:782) else goto L6
L6:
    dec_ref r6
    r11 = PyNumber_Subtract(r3, r10)
    dec_ref r3
    dec_ref r10
    if is_error(r11) goto L12 (error at sum_usd:782) else goto L7
L7:
    r12 = 'external'
    r13 = CPyObject_GetAttr(self, r12)
    if is_error(r13) goto L15 (error at sum_usd:782) else goto L8
L8:
    r14 = cast(dict, r13)
    if is_error(r14) goto L15 (error at sum_usd:782) else goto L9
L9:
    r15 = 'sum_usd'
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775809, 0)
    if is_error(r18) goto L16 (error at sum_usd:782) else goto L10
L10:
    dec_ref r14
    r19 = PyNumber_Add(r11, r18)
    dec_ref r11
    dec_ref r18
    if is_error(r19) goto L12 (error at sum_usd:782) else goto L11
L11:
    return r19
L12:
    r20 = <error> :: object
    return r20
L13:
    dec_ref r3
    goto L12
L14:
    dec_ref r3
    dec_ref r6
    goto L12
L15:
    dec_ref r11
    goto L12
L16:
    dec_ref r11
    dec_ref r14
    goto L12

def WalletBalances.__bool__(self):
    self :: dict
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bool
L0:
    r0 = CPyDict_ValuesView(self)
    if is_error(r0) goto L5 (error at __bool__:796) else goto L1
L1:
    r1 = builtins :: module
    r2 = 'any'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L6 (error at __bool__:796) else goto L2
L2:
    r4 = [r0]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L6 (error at __bool__:796) else goto L3
L3:
    dec_ref r0
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L5 (error at __bool__:796) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: bool
    return r8
L6:
    dec_ref r0
    goto L5

def WalletBalances.__repr__(self):
    self :: dict
    r0 :: str
    r1 :: dict
    r2, r3, r4 :: str
L0:
    r0 = 'WalletBalances '
    r1 = PyDict_Copy(self)
    if is_error(r1) goto L4 (error at __repr__:805) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:805) else goto L2
L2:
    r3 = CPyStr_Build(2, r0, r2)
    dec_ref r2
    if is_error(r3) goto L4 (error at __repr__:805) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: str
    return r4

def WalletBalances.__add__(self, other):
    self, other :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: union[int, None]
    r26 :: str
    r27 :: object
    r28 :: union[int, None]
    r29 :: object
    r30 :: bool
    r31, r32 :: str
    r33 :: object
    r34 :: union[int, None]
    r35, r36, r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40, r41, r42 :: str
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: union[int, None]
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: dict
    r58 :: short_int
    r59 :: native_int
    r60 :: short_int
    r61 :: object
    r62 :: tuple[bool, short_int, object, object]
    r63 :: short_int
    r64 :: bool
    r65, r66 :: object
    r67 :: str
    r68 :: union[eth_portfolio.typing.TokenBalances, dict]
    category :: str
    balances :: union[eth_portfolio.typing.TokenBalances, dict]
    r69 :: i32
    r70 :: bit
    r71 :: bool
    r72, r73 :: object
    r74 :: i32
    r75, r76, r77 :: bit
    r78 :: short_int
    r79 :: native_int
    r80 :: short_int
    r81 :: object
    r82 :: tuple[bool, short_int, object, object]
    r83 :: short_int
    r84 :: bool
    r85, r86 :: object
    r87 :: str
    r88 :: union[eth_portfolio.typing.TokenBalances, dict]
    r89 :: i32
    r90 :: bit
    r91 :: bool
    r92, r93 :: object
    r94 :: i32
    r95, r96, r97 :: bit
    r98 :: dict
L0:
    r0 = eth_portfolio.typing.WalletBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L53 (error at __add__:828) else goto L2
L2:
    r11 = ' is not a WalletBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L54 (error at __add__:828) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L53 (error at __add__:828) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L55 (error at __add__:828) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L55 (error at __add__:828) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L53 (error at __add__:828) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = 'block'
    r24 = CPyObject_GetAttr(self, r23)
    if is_error(r24) goto L53 (error at __add__:829) else goto L9
L9:
    r25 = cast(union[int, None], r24)
    if is_error(r25) goto L53 (error at __add__:829) else goto L10
L10:
    r26 = 'block'
    r27 = CPyObject_GetAttr(other, r26)
    if is_error(r27) goto L56 (error at __add__:829) else goto L11
L11:
    r28 = cast(union[int, None], r27)
    if is_error(r28) goto L56 (error at __add__:829) else goto L12
L12:
    r29 = PyObject_RichCompare(r25, r28, 3)
    dec_ref r25
    dec_ref r28
    if is_error(r29) goto L53 (error at __add__:829) else goto L13
L13:
    r30 = unbox(bool, r29)
    dec_ref r29
    if is_error(r30) goto L53 (error at __add__:829) else goto L14
L14:
    if r30 goto L15 else goto L26 :: bool
L15:
    r31 = 'These WalletBalances objects are not from the same block ('
    r32 = 'block'
    r33 = CPyObject_GetAttr(self, r32)
    if is_error(r33) goto L53 (error at __add__:831) else goto L16
L16:
    r34 = cast(union[int, None], r33)
    if is_error(r34) goto L53 (error at __add__:831) else goto L17
L17:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L53 (error at __add__:831) else goto L18
L18:
    r36 = ' and '
    r37 = 'block'
    r38 = CPyObject_GetAttr(other, r37)
    if is_error(r38) goto L57 (error at __add__:831) else goto L19
L19:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L57 (error at __add__:831) else goto L20
L20:
    r40 = PyObject_Str(r39)
    dec_ref r39
    if is_error(r40) goto L57 (error at __add__:831) else goto L21
L21:
    r41 = ')'
    r42 = CPyStr_Build(5, r31, r35, r36, r40, r41)
    dec_ref r35
    dec_ref r40
    if is_error(r42) goto L53 (error at __add__:831) else goto L22
L22:
    r43 = builtins :: module
    r44 = 'ValueError'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L58 (error at __add__:830) else goto L23
L23:
    r46 = [r42]
    r47 = load_address r46
    r48 = _PyObject_Vectorcall(r45, r47, 1, 0)
    dec_ref r45
    if is_error(r48) goto L58 (error at __add__:830) else goto L24
L24:
    dec_ref r42
    CPy_Raise(r48)
    dec_ref r48
    if not 0 goto L53 (error at __add__:830) else goto L25 :: bool
L25:
    unreachable
L26:
    r49 = 'block'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L53 (error at __add__:834) else goto L27
L27:
    r51 = cast(union[int, None], r50)
    if is_error(r51) goto L53 (error at __add__:834) else goto L28
L28:
    r52 = eth_portfolio.typing.WalletBalances :: type
    r53 = [r51]
    r54 = load_address r53
    r55 = ('block',)
    r56 = _PyObject_Vectorcall(r52, r54, 0, r55)
    if is_error(r56) goto L59 (error at __add__:834) else goto L29
L29:
    dec_ref r51
    r57 = cast(dict, r56)
    if is_error(r57) goto L53 (error at __add__:834) else goto L30
L30:
    r58 = 0
    r59 = PyDict_Size(self)
    r60 = r59 << 1
    r61 = CPyDict_GetItemsIter(self)
    if is_error(r61) goto L60 (error at __add__:835) else goto L31
L31:
    r62 = CPyDict_NextItem(r61, r58)
    r63 = r62[1]
    r58 = r63
    r64 = r62[0]
    if r64 goto L32 else goto L61 :: bool
L32:
    r65 = r62[2]
    r66 = r62[3]
    dec_ref r62
    r67 = cast(str, r65)
    if is_error(r67) goto L62 (error at __add__:835) else goto L33
L33:
    r68 = cast(union[eth_portfolio.typing.TokenBalances, dict], r66)
    if is_error(r68) goto L63 (error at __add__:835) else goto L34
L34:
    category = r67
    balances = r68
    r69 = PyObject_IsTrue(balances)
    r70 = r69 >= 0 :: signed
    if not r70 goto L64 (error at __add__:835) else goto L35 :: bool
L35:
    r71 = truncate r69: i32 to builtins.bool
    if r71 goto L36 else goto L65 :: bool
L36:
    r72 = CPyDict_GetItem(r57, category)
    if is_error(r72) goto L64 (error at __add__:837) else goto L37
L37:
    r73 = PyNumber_InPlaceAdd(r72, balances)
    dec_ref r72
    dec_ref balances
    if is_error(r73) goto L66 (error at __add__:837) else goto L38
L38:
    r74 = CPyDict_SetItem(r57, category, r73)
    dec_ref category
    dec_ref r73
    r75 = r74 >= 0 :: signed
    if not r75 goto L67 (error at __add__:837) else goto L39 :: bool
L39:
    r76 = CPyDict_CheckSize(self, r60)
    if not r76 goto L67 (error at __add__:835) else goto L31 :: bool
L40:
    r77 = CPy_NoErrOccurred()
    if not r77 goto L60 (error at __add__:835) else goto L41 :: bool
L41:
    r78 = 0
    r79 = PyDict_Size(other)
    r80 = r79 << 1
    r81 = CPyDict_GetItemsIter(other)
    if is_error(r81) goto L60 (error at __add__:838) else goto L42
L42:
    r82 = CPyDict_NextItem(r81, r78)
    r83 = r82[1]
    r78 = r83
    r84 = r82[0]
    if r84 goto L43 else goto L68 :: bool
L43:
    r85 = r82[2]
    r86 = r82[3]
    dec_ref r82
    r87 = cast(str, r85)
    if is_error(r87) goto L69 (error at __add__:838) else goto L44
L44:
    r88 = cast(union[eth_portfolio.typing.TokenBalances, dict], r86)
    if is_error(r88) goto L70 (error at __add__:838) else goto L45
L45:
    category = r87
    balances = r88
    r89 = PyObject_IsTrue(balances)
    r90 = r89 >= 0 :: signed
    if not r90 goto L71 (error at __add__:835) else goto L46 :: bool
L46:
    r91 = truncate r89: i32 to builtins.bool
    if r91 goto L47 else goto L72 :: bool
L47:
    r92 = CPyDict_GetItem(r57, category)
    if is_error(r92) goto L71 (error at __add__:840) else goto L48
L48:
    r93 = PyNumber_InPlaceAdd(r92, balances)
    dec_ref r92
    dec_ref balances
    if is_error(r93) goto L73 (error at __add__:840) else goto L49
L49:
    r94 = CPyDict_SetItem(r57, category, r93)
    dec_ref category
    dec_ref r93
    r95 = r94 >= 0 :: signed
    if not r95 goto L74 (error at __add__:840) else goto L50 :: bool
L50:
    r96 = CPyDict_CheckSize(other, r80)
    if not r96 goto L74 (error at __add__:838) else goto L42 :: bool
L51:
    r97 = CPy_NoErrOccurred()
    if not r97 goto L60 (error at __add__:838) else goto L52 :: bool
L52:
    return r57
L53:
    r98 = <error> :: dict
    return r98
L54:
    dec_ref r10
    goto L53
L55:
    dec_ref r16
    goto L53
L56:
    dec_ref r25
    goto L53
L57:
    dec_ref r35
    goto L53
L58:
    dec_ref r42
    goto L53
L59:
    dec_ref r51
    goto L53
L60:
    dec_ref r57
    goto L53
L61:
    dec_ref r61
    dec_ref r62
    goto L40
L62:
    dec_ref r57
    dec_ref r61
    dec_ref r66
    goto L53
L63:
    dec_ref r57
    dec_ref r61
    dec_ref r67
    goto L53
L64:
    dec_ref r57
    dec_ref r61
    dec_ref category
    dec_ref balances
    goto L53
L65:
    dec_ref category
    dec_ref balances
    goto L39
L66:
    dec_ref r57
    dec_ref r61
    dec_ref category
    goto L53
L67:
    dec_ref r57
    dec_ref r61
    goto L53
L68:
    dec_ref r81
    dec_ref r82
    goto L51
L69:
    dec_ref r57
    dec_ref r81
    dec_ref r86
    goto L53
L70:
    dec_ref r57
    dec_ref r81
    dec_ref r87
    goto L53
L71:
    dec_ref r57
    dec_ref category
    dec_ref balances
    dec_ref r81
    goto L53
L72:
    dec_ref category
    dec_ref balances
    goto L50
L73:
    dec_ref r57
    dec_ref category
    dec_ref r81
    goto L53
L74:
    dec_ref r57
    dec_ref r81
    goto L53

def WalletBalances.__add_____SummableNonNumericMixin_glue(self, other):
    self :: eth_portfolio.typing.WalletBalances
    other :: eth_portfolio.typing._SummableNonNumericMixin
    r0, r1, r2 :: dict
    r3, r4 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    inc_ref self
    r0 = cast(dict, self)
    if is_error(r0) goto L5 else goto L1
L1:
    inc_ref other
    r1 = cast(dict, other)
    if is_error(r1) goto L6 else goto L2
L2:
    r2 = WalletBalances.__add__(r0, r1)
    dec_ref r0
    dec_ref r1
    if is_error(r2) goto L5 else goto L3
L3:
    r3 = cast(eth_portfolio.typing._SummableNonNumericMixin, r2)
    if is_error(r3) goto L5 else goto L4
L4:
    return r3
L5:
    r4 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r4
L6:
    dec_ref r0
    goto L5

def WalletBalances.__sub__(self, other):
    self, other :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: union[int, None]
    r26 :: str
    r27 :: object
    r28 :: union[int, None]
    r29 :: object
    r30 :: bool
    r31, r32 :: str
    r33 :: object
    r34 :: union[int, None]
    r35, r36, r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40, r41, r42 :: str
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: union[int, None]
    r52 :: object
    r53 :: object[2]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: dict
    r58 :: short_int
    r59 :: native_int
    r60 :: short_int
    r61 :: object
    r62 :: tuple[bool, short_int, object, object]
    r63 :: short_int
    r64 :: bool
    r65, r66 :: object
    r67 :: str
    r68 :: union[eth_portfolio.typing.TokenBalances, dict]
    category :: str
    balances :: union[eth_portfolio.typing.TokenBalances, dict]
    r69, r70 :: object
    r71 :: i32
    r72, r73, r74 :: bit
    r75 :: dict
    r76 :: short_int
    r77 :: native_int
    r78 :: short_int
    r79 :: object
    r80 :: tuple[bool, short_int, object, object]
    r81 :: short_int
    r82 :: bool
    r83, r84 :: object
    r85 :: str
    r86 :: union[eth_portfolio.typing.TokenBalances, dict]
    r87 :: i32
    r88 :: bit
    r89 :: bool
    r90 :: i32
    r91, r92, r93 :: bit
    r94 :: dict
L0:
    r0 = eth_portfolio.typing.WalletBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L50 (error at __sub__:864) else goto L2
L2:
    r11 = ' is not a WalletBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L51 (error at __sub__:864) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L50 (error at __sub__:864) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L52 (error at __sub__:864) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L52 (error at __sub__:864) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L50 (error at __sub__:864) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = 'block'
    r24 = CPyObject_GetAttr(self, r23)
    if is_error(r24) goto L50 (error at __sub__:865) else goto L9
L9:
    r25 = cast(union[int, None], r24)
    if is_error(r25) goto L50 (error at __sub__:865) else goto L10
L10:
    r26 = 'block'
    r27 = CPyObject_GetAttr(other, r26)
    if is_error(r27) goto L53 (error at __sub__:865) else goto L11
L11:
    r28 = cast(union[int, None], r27)
    if is_error(r28) goto L53 (error at __sub__:865) else goto L12
L12:
    r29 = PyObject_RichCompare(r25, r28, 3)
    dec_ref r25
    dec_ref r28
    if is_error(r29) goto L50 (error at __sub__:865) else goto L13
L13:
    r30 = unbox(bool, r29)
    dec_ref r29
    if is_error(r30) goto L50 (error at __sub__:865) else goto L14
L14:
    if r30 goto L15 else goto L26 :: bool
L15:
    r31 = 'These WalletBalances objects are not from the same block ('
    r32 = 'block'
    r33 = CPyObject_GetAttr(self, r32)
    if is_error(r33) goto L50 (error at __sub__:867) else goto L16
L16:
    r34 = cast(union[int, None], r33)
    if is_error(r34) goto L50 (error at __sub__:867) else goto L17
L17:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L50 (error at __sub__:867) else goto L18
L18:
    r36 = ' and '
    r37 = 'block'
    r38 = CPyObject_GetAttr(other, r37)
    if is_error(r38) goto L54 (error at __sub__:867) else goto L19
L19:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L54 (error at __sub__:867) else goto L20
L20:
    r40 = PyObject_Str(r39)
    dec_ref r39
    if is_error(r40) goto L54 (error at __sub__:867) else goto L21
L21:
    r41 = ')'
    r42 = CPyStr_Build(5, r31, r35, r36, r40, r41)
    dec_ref r35
    dec_ref r40
    if is_error(r42) goto L50 (error at __sub__:867) else goto L22
L22:
    r43 = builtins :: module
    r44 = 'ValueError'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L55 (error at __sub__:866) else goto L23
L23:
    r46 = [r42]
    r47 = load_address r46
    r48 = _PyObject_Vectorcall(r45, r47, 1, 0)
    dec_ref r45
    if is_error(r48) goto L55 (error at __sub__:866) else goto L24
L24:
    dec_ref r42
    CPy_Raise(r48)
    dec_ref r48
    if not 0 goto L50 (error at __sub__:866) else goto L25 :: bool
L25:
    unreachable
L26:
    r49 = 'block'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L50 (error at __sub__:870) else goto L27
L27:
    r51 = cast(union[int, None], r50)
    if is_error(r51) goto L50 (error at __sub__:870) else goto L28
L28:
    r52 = eth_portfolio.typing.WalletBalances :: type
    r53 = [self, r51]
    r54 = load_address r53
    r55 = ('block',)
    r56 = _PyObject_Vectorcall(r52, r54, 1, r55)
    if is_error(r56) goto L56 (error at __sub__:870) else goto L29
L29:
    dec_ref r51
    r57 = cast(dict, r56)
    if is_error(r57) goto L50 (error at __sub__:870) else goto L30
L30:
    r58 = 0
    r59 = PyDict_Size(other)
    r60 = r59 << 1
    r61 = CPyDict_GetItemsIter(other)
    if is_error(r61) goto L57 (error at __sub__:871) else goto L31
L31:
    r62 = CPyDict_NextItem(r61, r58)
    r63 = r62[1]
    r58 = r63
    r64 = r62[0]
    if r64 goto L32 else goto L58 :: bool
L32:
    r65 = r62[2]
    r66 = r62[3]
    dec_ref r62
    r67 = cast(str, r65)
    if is_error(r67) goto L59 (error at __sub__:871) else goto L33
L33:
    r68 = cast(union[eth_portfolio.typing.TokenBalances, dict], r66)
    if is_error(r68) goto L60 (error at __sub__:871) else goto L34
L34:
    category = r67
    balances = r68
    r69 = CPyDict_GetItem(r57, category)
    if is_error(r69) goto L61 (error at __sub__:872) else goto L35
L35:
    r70 = PyNumber_InPlaceSubtract(r69, balances)
    dec_ref r69
    dec_ref balances
    if is_error(r70) goto L62 (error at __sub__:872) else goto L36
L36:
    r71 = CPyDict_SetItem(r57, category, r70)
    dec_ref category
    dec_ref r70
    r72 = r71 >= 0 :: signed
    if not r72 goto L63 (error at __sub__:872) else goto L37 :: bool
L37:
    r73 = CPyDict_CheckSize(other, r60)
    if not r73 goto L63 (error at __sub__:871) else goto L31 :: bool
L38:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L57 (error at __sub__:871) else goto L39 :: bool
L39:
    r75 = PyDict_Copy(r57)
    if is_error(r75) goto L57 (error at __sub__:873) else goto L40
L40:
    r76 = 0
    r77 = PyDict_Size(r75)
    r78 = r77 << 1
    r79 = CPyDict_GetItemsIter(r75)
    if is_error(r79) goto L64 (error at __sub__:873) else goto L41
L41:
    r80 = CPyDict_NextItem(r79, r76)
    r81 = r80[1]
    r76 = r81
    r82 = r80[0]
    if r82 goto L42 else goto L65 :: bool
L42:
    r83 = r80[2]
    r84 = r80[3]
    dec_ref r80
    r85 = cast(str, r83)
    if is_error(r85) goto L66 (error at __sub__:873) else goto L43
L43:
    r86 = cast(union[eth_portfolio.typing.TokenBalances, dict], r84)
    if is_error(r86) goto L67 (error at __sub__:873) else goto L44
L44:
    category = r85
    balances = r86
    r87 = PyObject_IsTrue(balances)
    dec_ref balances
    r88 = r87 >= 0 :: signed
    if not r88 goto L68 (error at __sub__:871) else goto L45 :: bool
L45:
    r89 = truncate r87: i32 to builtins.bool
    if r89 goto L69 else goto L46 :: bool
L46:
    r90 = PyObject_DelItem(r57, category)
    dec_ref category
    r91 = r90 >= 0 :: signed
    if not r91 goto L70 (error at __sub__:875) else goto L47 :: bool
L47:
    r92 = CPyDict_CheckSize(r75, r78)
    if not r92 goto L70 (error at __sub__:873) else goto L41 :: bool
L48:
    r93 = CPy_NoErrOccurred()
    if not r93 goto L57 (error at __sub__:873) else goto L49 :: bool
L49:
    return r57
L50:
    r94 = <error> :: dict
    return r94
L51:
    dec_ref r10
    goto L50
L52:
    dec_ref r16
    goto L50
L53:
    dec_ref r25
    goto L50
L54:
    dec_ref r35
    goto L50
L55:
    dec_ref r42
    goto L50
L56:
    dec_ref r51
    goto L50
L57:
    dec_ref r57
    goto L50
L58:
    dec_ref r61
    dec_ref r62
    goto L38
L59:
    dec_ref r57
    dec_ref r61
    dec_ref r66
    goto L50
L60:
    dec_ref r57
    dec_ref r61
    dec_ref r67
    goto L50
L61:
    dec_ref r57
    dec_ref r61
    dec_ref category
    dec_ref balances
    goto L50
L62:
    dec_ref r57
    dec_ref r61
    dec_ref category
    goto L50
L63:
    dec_ref r57
    dec_ref r61
    goto L50
L64:
    dec_ref r57
    dec_ref r75
    goto L50
L65:
    dec_ref r75
    dec_ref r79
    dec_ref r80
    goto L48
L66:
    dec_ref r57
    dec_ref r75
    dec_ref r79
    dec_ref r84
    goto L50
L67:
    dec_ref r57
    dec_ref r75
    dec_ref r79
    dec_ref r85
    goto L50
L68:
    dec_ref r57
    dec_ref category
    dec_ref r75
    dec_ref r79
    goto L50
L69:
    dec_ref category
    goto L47
L70:
    dec_ref r57
    dec_ref r75
    dec_ref r79
    goto L50

def WalletBalances.__getitem__(self, key):
    self :: dict
    key, r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3, r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16, r17 :: union[eth_portfolio.typing.TokenBalances, dict]
L0:
    r0 = '__validatekey'
    r1 = [self, key]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L7 (error at __getitem__:897) else goto L8
L1:
    r4 = builtins :: module
    r5 = 'super'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L7 (error at __getitem__:898) else goto L2
L2:
    r7 = eth_portfolio.typing.WalletBalances :: type
    r8 = [r7, self]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r6, r9, 2, 0)
    dec_ref r6
    if is_error(r10) goto L7 (error at __getitem__:898) else goto L3
L3:
    r11 = '__getitem__'
    r12 = CPyObject_GetAttr(r10, r11)
    dec_ref r10
    if is_error(r12) goto L7 (error at __getitem__:898) else goto L4
L4:
    r13 = [key]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L7 (error at __getitem__:898) else goto L5
L5:
    r16 = cast(union[eth_portfolio.typing.TokenBalances, dict], r15)
    if is_error(r16) goto L7 (error at __getitem__:898) else goto L6
L6:
    return r16
L7:
    r17 = <error> :: union[eth_portfolio.typing.TokenBalances, dict]
    return r17
L8:
    dec_ref r3
    goto L1

def WalletBalances.__setitem__(self, key, value):
    self :: dict
    key :: str
    value :: union[eth_portfolio.typing.TokenBalances, dict]
    r0 :: str
    r1 :: object[3]
    r2 :: object_ptr
    r3, r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[2]
    r14 :: object_ptr
    r15 :: object
    r16 :: None
L0:
    r0 = '__validateitem'
    r1 = [self, key, value]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775811, 0)
    if is_error(r3) goto L6 (error at __setitem__:920) else goto L7
L1:
    r4 = builtins :: module
    r5 = 'super'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L6 (error at __setitem__:921) else goto L2
L2:
    r7 = eth_portfolio.typing.WalletBalances :: type
    r8 = [r7, self]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r6, r9, 2, 0)
    dec_ref r6
    if is_error(r10) goto L6 (error at __setitem__:921) else goto L3
L3:
    r11 = '__setitem__'
    r12 = CPyObject_GetAttr(r10, r11)
    dec_ref r10
    if is_error(r12) goto L6 (error at __setitem__:921) else goto L4
L4:
    r13 = [key, value]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 2, 0)
    dec_ref r12
    if is_error(r15) goto L6 (error at __setitem__:921) else goto L8
L5:
    return 1
L6:
    r16 = <error> :: None
    return r16
L7:
    dec_ref r3
    goto L1
L8:
    dec_ref r15
    goto L5

def WalletBalances.__validatekey(self, key):
    self :: dict
    key, r0 :: str
    r1 :: object
    r2 :: tuple[str, str, str]
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6, r7 :: bool
    r8, r9 :: str
    r10 :: object
    r11 :: tuple[str, str, str]
    r12 :: object
    r13, r14 :: str
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: None
L0:
    r0 = '_keys'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L13 (error at __validatekey:935) else goto L1
L1:
    r2 = unbox(tuple[str, str, str], r1)
    dec_ref r1
    if is_error(r2) goto L13 (error at __validatekey:935) else goto L2
L2:
    r3 = box(tuple[str, str, str], r2)
    r4 = PySequence_Contains(r3, key)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L13 (error at __validatekey:935) else goto L3 :: bool
L3:
    r6 = truncate r4: i32 to builtins.bool
    r7 = r6 ^ 1
    if r7 goto L4 else goto L12 :: bool
L4:
    r8 = ' is not a valid key for WalletBalances. Valid keys are: '
    r9 = '_keys'
    r10 = CPyObject_GetAttr(self, r9)
    if is_error(r10) goto L13 (error at __validatekey:937) else goto L5
L5:
    r11 = unbox(tuple[str, str, str], r10)
    dec_ref r10
    if is_error(r11) goto L13 (error at __validatekey:937) else goto L6
L6:
    r12 = box(tuple[str, str, str], r11)
    r13 = PyObject_Str(r12)
    dec_ref r12
    if is_error(r13) goto L13 (error at __validatekey:937) else goto L7
L7:
    r14 = CPyStr_Build(3, key, r8, r13)
    dec_ref r13
    if is_error(r14) goto L13 (error at __validatekey:937) else goto L8
L8:
    r15 = builtins :: module
    r16 = 'KeyError'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L14 (error at __validatekey:936) else goto L9
L9:
    r18 = [r14]
    r19 = load_address r18
    r20 = _PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L14 (error at __validatekey:936) else goto L10
L10:
    dec_ref r14
    CPy_Raise(r20)
    dec_ref r20
    if not 0 goto L13 (error at __validatekey:936) else goto L11 :: bool
L11:
    unreachable
L12:
    return 1
L13:
    r21 = <error> :: None
    return r21
L14:
    dec_ref r14
    goto L13

def WalletBalances.__validateitem(self, key, item):
    self :: dict
    key :: str
    item :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: i32
    r6 :: bit
    r7 :: object
    r8, r9, r10 :: bit
    r11 :: object
    r12 :: ptr
    r13 :: object
    r14 :: bit
    r15, r16, r17, r18 :: str
    r19 :: object
    r20 :: str
    r21 :: object
    r22 :: object[1]
    r23 :: object_ptr
    r24 :: object
    r25 :: str
    r26 :: i32
    r27 :: bit
    r28 :: object
    r29, r30, r31 :: bit
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36, r37, r38 :: bit
    r39 :: object
    r40 :: ptr
    r41 :: object
    r42 :: bit
    r43, r44, r45, r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53, r54, r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: object[1]
    r60 :: object_ptr
    r61 :: object
    r62 :: None
L0:
    r0 = '__validatekey'
    r1 = [self, key]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L34 (error at __validateitem:952) else goto L35
L1:
    r4 = 'assets'
    r5 = PyUnicode_Compare(key, r4)
    r6 = r5 == -1
    if r6 goto L2 else goto L4 :: bool
L2:
    r7 = PyErr_Occurred()
    r8 = r7 != 0
    if r8 goto L3 else goto L4 :: bool
L3:
    r9 = CPy_KeepPropagating()
    if not r9 goto L34 (error at __validateitem:953) else goto L4 :: bool
L4:
    r10 = r5 == 0
    if r10 goto L5 else goto L12 :: bool
L5:
    r11 = eth_portfolio.typing.TokenBalances :: type
    r12 = get_element_ptr item ob_type :: PyObject
    r13 = load_mem r12 :: builtins.object*
    r14 = r13 == r11
    if r14 goto L33 else goto L6 :: bool
L6:
    r15 = PyObject_Str(item)
    if is_error(r15) goto L34 (error at __validateitem:956) else goto L7
L7:
    r16 = ' is not a valid value for "'
    r17 = '". Must be a TokenBalances object.'
    r18 = CPyStr_Build(4, r15, r16, key, r17)
    dec_ref r15
    if is_error(r18) goto L34 (error at __validateitem:956) else goto L8
L8:
    r19 = builtins :: module
    r20 = 'TypeError'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L36 (error at __validateitem:955) else goto L9
L9:
    r22 = [r18]
    r23 = load_address r22
    r24 = _PyObject_Vectorcall(r21, r23, 1, 0)
    dec_ref r21
    if is_error(r24) goto L36 (error at __validateitem:955) else goto L10
L10:
    dec_ref r18
    CPy_Raise(r24)
    dec_ref r24
    if not 0 goto L34 (error at __validateitem:955) else goto L11 :: bool
L11:
    unreachable
L12:
    r25 = 'debt'
    r26 = PyUnicode_Compare(key, r25)
    r27 = r26 == -1
    if r27 goto L13 else goto L15 :: bool
L13:
    r28 = PyErr_Occurred()
    r29 = r28 != 0
    if r29 goto L14 else goto L15 :: bool
L14:
    r30 = CPy_KeepPropagating()
    if not r30 goto L34 (error at __validateitem:-1) else goto L15 :: bool
L15:
    r31 = r26 == 0
    if r31 goto L16 else goto L17 :: bool
L16:
    if r31 goto L21 else goto L28 :: bool
L17:
    r32 = 'external'
    r33 = PyUnicode_Compare(key, r32)
    r34 = r33 == -1
    if r34 goto L18 else goto L20 :: bool
L18:
    r35 = PyErr_Occurred()
    r36 = r35 != 0
    if r36 goto L19 else goto L20 :: bool
L19:
    r37 = CPy_KeepPropagating()
    if not r37 goto L34 (error at __validateitem:-1) else goto L20 :: bool
L20:
    r38 = r33 == 0
    if r38 goto L21 else goto L28 :: bool
L21:
    r39 = eth_portfolio.typing.RemoteTokenBalances :: type
    r40 = get_element_ptr item ob_type :: PyObject
    r41 = load_mem r40 :: builtins.object*
    r42 = r41 == r39
    if r42 goto L33 else goto L22 :: bool
L22:
    r43 = PyObject_Str(item)
    if is_error(r43) goto L34 (error at __validateitem:961) else goto L23
L23:
    r44 = ' is not a valid value for "'
    r45 = '". Must be a RemoteTokenBalances object.'
    r46 = CPyStr_Build(4, r43, r44, key, r45)
    dec_ref r43
    if is_error(r46) goto L34 (error at __validateitem:961) else goto L24
L24:
    r47 = builtins :: module
    r48 = 'TypeError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L37 (error at __validateitem:960) else goto L25
L25:
    r50 = [r46]
    r51 = load_address r50
    r52 = _PyObject_Vectorcall(r49, r51, 1, 0)
    dec_ref r49
    if is_error(r52) goto L37 (error at __validateitem:960) else goto L26
L26:
    dec_ref r46
    CPy_Raise(r52)
    dec_ref r52
    if not 0 goto L34 (error at __validateitem:960) else goto L27 :: bool
L27:
    unreachable
L28:
    r53 = 'key '
    r54 = ' is not yet implemented.'
    r55 = CPyStr_Build(3, r53, key, r54)
    if is_error(r55) goto L34 (error at __validateitem:964) else goto L29
L29:
    r56 = builtins :: module
    r57 = 'NotImplementedError'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L38 (error at __validateitem:964) else goto L30
L30:
    r59 = [r55]
    r60 = load_address r59
    r61 = _PyObject_Vectorcall(r58, r60, 1, 0)
    dec_ref r58
    if is_error(r61) goto L38 (error at __validateitem:964) else goto L31
L31:
    dec_ref r55
    CPy_Raise(r61)
    dec_ref r61
    if not 0 goto L34 (error at __validateitem:964) else goto L32 :: bool
L32:
    unreachable
L33:
    return 1
L34:
    r62 = <error> :: None
    return r62
L35:
    dec_ref r3
    goto L1
L36:
    dec_ref r18
    goto L34
L37:
    dec_ref r46
    goto L34
L38:
    dec_ref r55
    goto L34

def __mypyc_lambda__1___init___PortfolioBalances_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__1___init___PortfolioBalances_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: eth_portfolio.typing.__mypyc_lambda__1___init___PortfolioBalances_obj
    r0 :: eth_portfolio.typing.__init___PortfolioBalances_env
    r1 :: union[int, None]
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5, r6 :: object
    r7, r8 :: dict
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L5 (error at <lambda>:987) else goto L1
L1:
    r1 = r0.block
    dec_ref r0
    if is_error(r1) goto L5 (error at <lambda>:987) else goto L2
L2:
    r2 = eth_portfolio.typing.WalletBalances :: type
    r3 = [r1]
    r4 = load_address r3
    r5 = ('block',)
    r6 = _PyObject_Vectorcall(r2, r4, 0, r5)
    if is_error(r6) goto L6 (error at <lambda>:987) else goto L3
L3:
    dec_ref r1
    r7 = cast(dict, r6)
    if is_error(r7) goto L5 (error at <lambda>:987) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: dict
    return r8
L6:
    dec_ref r1
    goto L5

def PortfolioBalances.__init__(self, seed, block):
    self :: eth_portfolio.typing.PortfolioBalances
    seed :: union[dict, list, None]
    block :: union[int, None]
    r0, r1 :: object
    r2 :: eth_portfolio.typing.__init___PortfolioBalances_env
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: eth_portfolio.typing.__mypyc_lambda__1___init___PortfolioBalances_obj
    r14 :: bool
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: union[int, None]
    r19 :: object
    r20 :: bit
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: dict
    r26 :: short_int
    r27 :: native_int
    r28 :: short_int
    r29 :: object
    r30 :: tuple[bool, short_int, object, object]
    r31 :: short_int
    r32 :: bool
    r33, r34 :: object
    r35 :: dict
    wallet :: object
    balances :: dict
    r36 :: union[int, None]
    r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40 :: object
    r41 :: bool
    r42 :: str
    r43 :: union[int, None]
    r44, r45, r46 :: str
    r47 :: object
    r48 :: union[int, None]
    r49, r50, r51 :: str
    r52 :: object
    r53 :: str
    r54 :: object
    r55 :: object[1]
    r56 :: object_ptr
    r57, r58, r59 :: object
    r60 :: dict
    r61 :: None
    r62, r63 :: bit
    r64 :: object
    r65 :: i32
    r66 :: bit
    r67 :: bool
    r68 :: list
    r69 :: short_int
    r70 :: ptr
    r71 :: native_int
    r72 :: short_int
    r73 :: bit
    r74 :: native_int
    r75, r76 :: ptr
    r77 :: native_int
    r78 :: ptr
    r79 :: object
    r80 :: tuple[object, dict]
    r81 :: object
    r82 :: dict
    r83 :: union[int, None]
    r84 :: str
    r85 :: object
    r86 :: union[int, None]
    r87 :: object
    r88 :: bool
    r89 :: str
    r90 :: union[int, None]
    r91, r92, r93 :: str
    r94 :: object
    r95 :: union[int, None]
    r96, r97, r98 :: str
    r99 :: object
    r100 :: str
    r101 :: object
    r102 :: object[1]
    r103 :: object_ptr
    r104, r105, r106 :: object
    r107 :: dict
    r108 :: None
    r109 :: short_int
    r110, r111, r112, r113 :: str
    r114 :: object[3]
    r115 :: object_ptr
    r116 :: object
    r117 :: str
    r118 :: list
    r119, r120, r121 :: ptr
    r122 :: str
    r123 :: object
    r124 :: str
    r125 :: object
    r126 :: object[1]
    r127 :: object_ptr
    r128 :: object
    r129 :: None
L0:
    if is_error(seed) goto L1 else goto L75
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    if is_error(block) goto L3 else goto L76
L3:
    r1 = box(None, 1)
    inc_ref r1
    block = r1
L4:
    r2 = __init___PortfolioBalances_env()
    if is_error(r2) goto L77 (error at __init__:986) else goto L5
L5:
    r2.block = block; r3 = is_error
    if not r3 goto L78 (error at __init__:986) else goto L6 :: bool
L6:
    r4 = builtins :: module
    r5 = 'super'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L78 (error at __init__:987) else goto L7
L7:
    r7 = eth_portfolio.typing.PortfolioBalances :: type
    r8 = [r7, self]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r6, r9, 2, 0)
    dec_ref r6
    if is_error(r10) goto L78 (error at __init__:987) else goto L8
L8:
    r11 = '__init__'
    r12 = CPyObject_GetAttr(r10, r11)
    dec_ref r10
    if is_error(r12) goto L78 (error at __init__:987) else goto L9
L9:
    r13 = __mypyc_lambda__1___init___PortfolioBalances_obj()
    if is_error(r13) goto L79 (error at __init__:987) else goto L10
L10:
    inc_ref r2
    r13.__mypyc_env__ = r2; r14 = is_error
    if not r14 goto L80 (error at __init__:987) else goto L11 :: bool
L11:
    r15 = [r13]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r12, r16, 1, 0)
    dec_ref r12
    if is_error(r17) goto L81 (error at __init__:987) else goto L82
L12:
    dec_ref r13
    r18 = r2.block
    dec_ref r2
    if is_error(r18) goto L83 (error at __init__:988) else goto L13
L13:
    self.block = r18
    r19 = load_address _Py_NoneStruct
    r20 = seed == r19
    if r20 goto L84 else goto L15 :: bool
L14:
    return 1
L15:
    r21 = load_address PyDict_Type
    r22 = PyObject_IsInstance(seed, r21)
    r23 = r22 >= 0 :: signed
    if not r23 goto L83 (error at __init__:991) else goto L16 :: bool
L16:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L17 else goto L41 :: bool
L17:
    r25 = cast(dict, seed)
    if is_error(r25) goto L74 (error at __init__:992) else goto L18
L18:
    r26 = 0
    r27 = PyDict_Size(r25)
    r28 = r27 << 1
    r29 = CPyDict_GetItemsIter(r25)
    if is_error(r29) goto L85 (error at __init__:992) else goto L19
L19:
    r30 = CPyDict_NextItem(r29, r26)
    r31 = r30[1]
    r26 = r31
    r32 = r30[0]
    if r32 goto L20 else goto L86 :: bool
L20:
    r33 = r30[2]
    r34 = r30[3]
    dec_ref r30
    r35 = cast(dict, r34)
    if is_error(r35) goto L87 (error at __init__:992) else goto L21
L21:
    wallet = r33
    balances = r35
    r36 = self.block
    r37 = 'block'
    r38 = CPyObject_GetAttr(balances, r37)
    if is_error(r38) goto L88 (error at __init__:993) else goto L22
L22:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L88 (error at __init__:993) else goto L23
L23:
    r40 = PyObject_RichCompare(r36, r39, 3)
    dec_ref r36
    dec_ref r39
    if is_error(r40) goto L89 (error at __init__:993) else goto L24
L24:
    r41 = unbox(bool, r40)
    dec_ref r40
    if is_error(r41) goto L89 (error at __init__:993) else goto L25
L25:
    if r41 goto L90 else goto L35 :: bool
L26:
    r42 = 'These objects are not from the same block ('
    r43 = self.block
    r44 = PyObject_Str(r43)
    dec_ref r43
    if is_error(r44) goto L91 (error at __init__:995) else goto L27
L27:
    r45 = ' and '
    r46 = 'block'
    r47 = CPyObject_GetAttr(balances, r46)
    dec_ref balances
    if is_error(r47) goto L92 (error at __init__:995) else goto L28
L28:
    r48 = cast(union[int, None], r47)
    if is_error(r48) goto L92 (error at __init__:995) else goto L29
L29:
    r49 = PyObject_Str(r48)
    dec_ref r48
    if is_error(r49) goto L92 (error at __init__:995) else goto L30
L30:
    r50 = ')'
    r51 = CPyStr_Build(5, r42, r44, r45, r49, r50)
    dec_ref r44
    dec_ref r49
    if is_error(r51) goto L74 (error at __init__:995) else goto L31
L31:
    r52 = builtins :: module
    r53 = 'ValueError'
    r54 = CPyObject_GetAttr(r52, r53)
    if is_error(r54) goto L93 (error at __init__:994) else goto L32
L32:
    r55 = [r51]
    r56 = load_address r55
    r57 = _PyObject_Vectorcall(r54, r56, 1, 0)
    dec_ref r54
    if is_error(r57) goto L93 (error at __init__:994) else goto L33
L33:
    dec_ref r51
    CPy_Raise(r57)
    dec_ref r57
    if not 0 goto L74 (error at __init__:994) else goto L34 :: bool
L34:
    unreachable
L35:
    r58 = PyObject_GetItem(self, wallet)
    if is_error(r58) goto L89 (error at __init__:997) else goto L36
L36:
    r59 = PyNumber_InPlaceAdd(r58, balances)
    dec_ref r58
    dec_ref balances
    if is_error(r59) goto L94 (error at __init__:997) else goto L37
L37:
    r60 = cast(dict, r59)
    if is_error(r60) goto L94 (error at __init__:997) else goto L38
L38:
    r61 = self.__setitem__(wallet, r60)
    dec_ref wallet
    dec_ref r60
    if is_error(r61) goto L95 (error at __init__:997) else goto L39
L39:
    r62 = CPyDict_CheckSize(r25, r28)
    if not r62 goto L95 (error at __init__:992) else goto L19 :: bool
L40:
    r63 = CPy_NoErrOccurred()
    if not r63 goto L74 (error at __init__:992) else goto L73 :: bool
L41:
    r64 = load_address PyList_Type
    r65 = PyObject_IsInstance(seed, r64)
    r66 = r65 >= 0 :: signed
    if not r66 goto L83 (error at __init__:998) else goto L42 :: bool
L42:
    r67 = truncate r65: i32 to builtins.bool
    if r67 goto L43 else goto L66 :: bool
L43:
    r68 = cast(list, seed)
    if is_error(r68) goto L74 (error at __init__:999) else goto L44
L44:
    r69 = 0
L45:
    r70 = get_element_ptr r68 ob_size :: PyVarObject
    r71 = load_mem r70 :: native_int*
    r72 = r71 << 1
    r73 = r69 < r72 :: signed
    if r73 goto L46 else goto L96 :: bool
L46:
    r74 = r69 >> 1
    r75 = get_element_ptr r68 ob_item :: PyListObject
    r76 = load_mem r75 :: ptr*
    r77 = r74 * 8
    r78 = r76 + r77
    r79 = load_mem r78 :: builtins.object*
    inc_ref r79
    r80 = unbox(tuple[object, dict], r79)
    dec_ref r79
    if is_error(r80) goto L97 (error at __init__:999) else goto L47
L47:
    r81 = r80[0]
    wallet = r81
    r82 = r80[1]
    dec_ref r80
    balances = r82
    r83 = self.block
    r84 = 'block'
    r85 = CPyObject_GetAttr(balances, r84)
    if is_error(r85) goto L98 (error at __init__:1000) else goto L48
L48:
    r86 = cast(union[int, None], r85)
    if is_error(r86) goto L98 (error at __init__:1000) else goto L49
L49:
    r87 = PyObject_RichCompare(r83, r86, 3)
    dec_ref r83
    dec_ref r86
    if is_error(r87) goto L99 (error at __init__:1000) else goto L50
L50:
    r88 = unbox(bool, r87)
    dec_ref r87
    if is_error(r88) goto L99 (error at __init__:1000) else goto L51
L51:
    if r88 goto L100 else goto L61 :: bool
L52:
    r89 = 'These objects are not from the same block ('
    r90 = self.block
    r91 = PyObject_Str(r90)
    dec_ref r90
    if is_error(r91) goto L91 (error at __init__:1002) else goto L53
L53:
    r92 = ' and '
    r93 = 'block'
    r94 = CPyObject_GetAttr(balances, r93)
    dec_ref balances
    if is_error(r94) goto L101 (error at __init__:1002) else goto L54
L54:
    r95 = cast(union[int, None], r94)
    if is_error(r95) goto L101 (error at __init__:1002) else goto L55
L55:
    r96 = PyObject_Str(r95)
    dec_ref r95
    if is_error(r96) goto L101 (error at __init__:1002) else goto L56
L56:
    r97 = ')'
    r98 = CPyStr_Build(5, r89, r91, r92, r96, r97)
    dec_ref r91
    dec_ref r96
    if is_error(r98) goto L74 (error at __init__:1002) else goto L57
L57:
    r99 = builtins :: module
    r100 = 'ValueError'
    r101 = CPyObject_GetAttr(r99, r100)
    if is_error(r101) goto L102 (error at __init__:1001) else goto L58
L58:
    r102 = [r98]
    r103 = load_address r102
    r104 = _PyObject_Vectorcall(r101, r103, 1, 0)
    dec_ref r101
    if is_error(r104) goto L102 (error at __init__:1001) else goto L59
L59:
    dec_ref r98
    CPy_Raise(r104)
    dec_ref r104
    if not 0 goto L74 (error at __init__:1001) else goto L60 :: bool
L60:
    unreachable
L61:
    r105 = PyObject_GetItem(self, wallet)
    if is_error(r105) goto L99 (error at __init__:1004) else goto L62
L62:
    r106 = PyNumber_InPlaceAdd(r105, balances)
    dec_ref r105
    dec_ref balances
    if is_error(r106) goto L103 (error at __init__:1004) else goto L63
L63:
    r107 = cast(dict, r106)
    if is_error(r107) goto L103 (error at __init__:1004) else goto L64
L64:
    r108 = self.__setitem__(wallet, r107)
    dec_ref wallet
    dec_ref r107
    if is_error(r108) goto L97 (error at __init__:1004) else goto L65
L65:
    r109 = r69 + 2
    r69 = r109
    goto L45
L66:
    r110 = ''
    r111 = '{:{}}'
    r112 = ''
    r113 = 'format'
    r114 = [r111, seed, r112]
    r115 = load_address r114
    r116 = PyObject_VectorcallMethod(r113, r115, 9223372036854775811, 0)
    if is_error(r116) goto L83 (error at __init__:1006) else goto L67
L67:
    dec_ref seed
    r117 = ' is not a valid input for PortfolioBalances'
    r118 = PyList_New(2)
    if is_error(r118) goto L104 (error at __init__:1006) else goto L68
L68:
    r119 = get_element_ptr r118 ob_item :: PyListObject
    r120 = load_mem r119 :: ptr*
    set_mem r120, r116 :: builtins.object*
    inc_ref r117
    r121 = r120 + 8
    set_mem r121, r117 :: builtins.object*
    r122 = PyUnicode_Join(r110, r118)
    dec_ref r118
    if is_error(r122) goto L74 (error at __init__:1006) else goto L69
L69:
    r123 = builtins :: module
    r124 = 'TypeError'
    r125 = CPyObject_GetAttr(r123, r124)
    if is_error(r125) goto L105 (error at __init__:1006) else goto L70
L70:
    r126 = [r122]
    r127 = load_address r126
    r128 = _PyObject_Vectorcall(r125, r127, 1, 0)
    dec_ref r125
    if is_error(r128) goto L105 (error at __init__:1006) else goto L71
L71:
    dec_ref r122
    CPy_Raise(r128)
    dec_ref r128
    if not 0 goto L74 (error at __init__:1006) else goto L72 :: bool
L72:
    unreachable
L73:
    return 1
L74:
    r129 = <error> :: None
    return r129
L75:
    inc_ref seed
    goto L2
L76:
    inc_ref block
    goto L4
L77:
    dec_ref seed
    dec_ref block
    goto L74
L78:
    dec_ref seed
    dec_ref r2
    goto L74
L79:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    goto L74
L80:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    dec_ref r13
    goto L74
L81:
    dec_ref seed
    dec_ref r2
    dec_ref r13
    goto L74
L82:
    dec_ref r17
    goto L12
L83:
    dec_ref seed
    goto L74
L84:
    dec_ref seed
    goto L14
L85:
    dec_ref r25
    goto L74
L86:
    dec_ref r25
    dec_ref r29
    dec_ref r30
    goto L40
L87:
    dec_ref r25
    dec_ref r29
    dec_ref r33
    goto L74
L88:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    dec_ref balances
    dec_ref r36
    goto L74
L89:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    dec_ref balances
    goto L74
L90:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    goto L26
L91:
    dec_ref balances
    goto L74
L92:
    dec_ref r44
    goto L74
L93:
    dec_ref r51
    goto L74
L94:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    goto L74
L95:
    dec_ref r25
    dec_ref r29
    goto L74
L96:
    dec_ref r68
    goto L73
L97:
    dec_ref r68
    goto L74
L98:
    dec_ref wallet
    dec_ref balances
    dec_ref r68
    dec_ref r83
    goto L74
L99:
    dec_ref wallet
    dec_ref balances
    dec_ref r68
    goto L74
L100:
    dec_ref wallet
    dec_ref r68
    goto L52
L101:
    dec_ref r91
    goto L74
L102:
    dec_ref r98
    goto L74
L103:
    dec_ref wallet
    dec_ref r68
    goto L74
L104:
    dec_ref r116
    goto L74
L105:
    dec_ref r122
    goto L74

def PortfolioBalances.__setitem__(self, key, value):
    self :: eth_portfolio.typing.PortfolioBalances
    key :: object
    value :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22, r23 :: object
    r24 :: str
    r25, r26 :: object
    r27 :: object[2]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: object[2]
    r33 :: object_ptr
    r34 :: object
    r35 :: None
L0:
    r0 = eth_portfolio.typing.WalletBalances :: type
    r1 = get_element_ptr value ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = 'value must be a `WalletBalances` object. You passed '
    r6 = '{:{}}'
    r7 = ''
    r8 = 'format'
    r9 = [r6, value, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L13 (error at __setitem__:1011) else goto L2
L2:
    r12 = PyList_New(2)
    if is_error(r12) goto L14 (error at __setitem__:1011) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    inc_ref r5
    set_mem r14, r5 :: builtins.object*
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L13 (error at __setitem__:1011) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L15 (error at __setitem__:1010) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L15 (error at __setitem__:1010) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L13 (error at __setitem__:1010) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = builtins :: module
    r24 = 'super'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L13 (error at __setitem__:1013) else goto L9
L9:
    r26 = eth_portfolio.typing.PortfolioBalances :: type
    r27 = [r26, self]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r25, r28, 2, 0)
    dec_ref r25
    if is_error(r29) goto L13 (error at __setitem__:1013) else goto L10
L10:
    r30 = '__setitem__'
    r31 = CPyObject_GetAttr(r29, r30)
    dec_ref r29
    if is_error(r31) goto L13 (error at __setitem__:1013) else goto L11
L11:
    r32 = [key, value]
    r33 = load_address r32
    r34 = _PyObject_Vectorcall(r31, r33, 2, 0)
    dec_ref r31
    if is_error(r34) goto L13 (error at __setitem__:1013) else goto L16
L12:
    return 1
L13:
    r35 = <error> :: None
    return r35
L14:
    dec_ref r11
    goto L13
L15:
    dec_ref r16
    goto L13
L16:
    dec_ref r34
    goto L12

def PortfolioBalances.dataframe(self):
    self :: eth_portfolio.typing.PortfolioBalances
    r0 :: list
    r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7, r8 :: object
    r9 :: bool
    r10 :: object
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: str
    r15 :: object
    r16 :: str
    r17 :: i32
    r18 :: bit
    r19 :: i32
    r20, r21 :: bit
    r22 :: ptr
    r23 :: native_int
    r24 :: short_int
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: str
    r33 :: object
    r34 :: object[2]
    r35 :: object_ptr
    r36, r37, r38 :: object
    r39 :: dict
    r40 :: str
    r41, r42, r43 :: object
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L27 (error at dataframe:1023) else goto L1
L1:
    r1 = 'items'
    r2 = [self]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L28 (error at dataframe:1024) else goto L2
L2:
    r5 = PyObject_GetIter(r4)
    dec_ref r4
    if is_error(r5) goto L28 (error at dataframe:1024) else goto L3
L3:
    r6 = PyIter_Next(r5)
    if is_error(r6) goto L29 else goto L4
L4:
    r7 = PyObject_GetIter(r6)
    dec_ref r6
    if is_error(r7) goto L30 (error at dataframe:1024) else goto L5
L5:
    r8 = PyIter_Next(r7)
    if is_error(r8) goto L31 else goto L8
L6:
    r9 = raise ValueError('not enough values to unpack')
    if not r9 goto L27 (error at dataframe:1024) else goto L7 :: bool
L7:
    unreachable
L8:
    r10 = PyIter_Next(r7)
    if is_error(r10) goto L32 else goto L11
L9:
    r11 = raise ValueError('not enough values to unpack')
    if not r11 goto L27 (error at dataframe:1024) else goto L10 :: bool
L10:
    unreachable
L11:
    r12 = PyIter_Next(r7)
    dec_ref r7
    if is_error(r12) goto L14 else goto L33
L12:
    r13 = raise ValueError('too many values to unpack')
    if not r13 goto L27 (error at dataframe:1024) else goto L13 :: bool
L13:
    unreachable
L14:
    r14 = 'dataframe'
    r15 = CPyObject_GetAttr(r10, r14)
    dec_ref r10
    if is_error(r15) goto L34 (error at dataframe:1025) else goto L15
L15:
    r16 = 'wallet'
    r17 = PyObject_SetItem(r15, r16, r8)
    dec_ref r8
    r18 = r17 >= 0 :: signed
    if not r18 goto L35 (error at dataframe:1026) else goto L16 :: bool
L16:
    r19 = PyList_Append(r0, r15)
    dec_ref r15
    r20 = r19 >= 0 :: signed
    if not r20 goto L30 (error at dataframe:1027) else goto L3 :: bool
L17:
    r21 = CPy_NoErrOccurred()
    if not r21 goto L28 (error at dataframe:1024) else goto L18 :: bool
L18:
    r22 = get_element_ptr r0 ob_size :: PyVarObject
    r23 = load_mem r22 :: native_int*
    r24 = r23 << 1
    r25 = r24 != 0
    if r25 goto L19 else goto L36 :: bool
L19:
    r26 = eth_portfolio.typing.globals :: static
    r27 = 'concat'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L28 (error at dataframe:1028) else goto L20
L20:
    r29 = [r0]
    r30 = load_address r29
    r31 = _PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L28 (error at dataframe:1028) else goto L21
L21:
    dec_ref r0
    r32 = 'reset_index'
    r33 = box(bool, 1)
    r34 = [r31, r33]
    r35 = load_address r34
    r36 = ('drop',)
    r37 = PyObject_VectorcallMethod(r32, r35, 9223372036854775809, r36)
    if is_error(r37) goto L37 (error at dataframe:1028) else goto L22
L22:
    dec_ref r31
    r38 = r37
    goto L26
L23:
    r39 = eth_portfolio.typing.globals :: static
    r40 = 'DataFrame'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L27 (error at dataframe:1028) else goto L24
L24:
    r42 = _PyObject_Vectorcall(r41, 0, 0, 0)
    dec_ref r41
    if is_error(r42) goto L27 (error at dataframe:1028) else goto L25
L25:
    r38 = r42
L26:
    return r38
L27:
    r43 = <error> :: object
    return r43
L28:
    dec_ref r0
    goto L27
L29:
    dec_ref r5
    goto L17
L30:
    dec_ref r0
    dec_ref r5
    goto L27
L31:
    dec_ref r0
    dec_ref r5
    dec_ref r7
    goto L6
L32:
    dec_ref r0
    dec_ref r5
    dec_ref r7
    dec_ref r8
    goto L9
L33:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    dec_ref r10
    dec_ref r12
    goto L12
L34:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L27
L35:
    dec_ref r0
    dec_ref r5
    dec_ref r15
    goto L27
L36:
    dec_ref r0
    goto L23
L37:
    dec_ref r31
    goto L27

def PortfolioBalances.sum_usd(self):
    self :: eth_portfolio.typing.PortfolioBalances
    r0, r1 :: object
    r2 :: str
    r3 :: object[1]
    r4 :: object_ptr
    r5, r6, r7 :: object
    r8 :: str
    r9 :: object[1]
    r10 :: object_ptr
    r11, r12 :: object
    r13 :: bit
    r14 :: object
L0:
    r0 = object 0
    inc_ref r0
    r1 = r0
    r2 = 'values'
    r3 = [self]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775809, 0)
    if is_error(r5) goto L9 (error at sum_usd:1043) else goto L1
L1:
    r6 = PyObject_GetIter(r5)
    dec_ref r5
    if is_error(r6) goto L9 (error at sum_usd:1043) else goto L2
L2:
    r7 = PyIter_Next(r6)
    if is_error(r7) goto L10 else goto L3
L3:
    r8 = 'sum_usd'
    r9 = [r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775809, 0)
    if is_error(r11) goto L11 (error at sum_usd:1043) else goto L4
L4:
    dec_ref r7
    r12 = PyNumber_Add(r1, r11)
    dec_ref r1
    dec_ref r11
    if is_error(r12) goto L12 (error at sum_usd:-1) else goto L5
L5:
    r1 = r12
    goto L2
L6:
    r13 = CPy_NoErrOccurred()
    if not r13 goto L9 (error at sum_usd:1043) else goto L7 :: bool
L7:
    return r1
L8:
    r14 = <error> :: object
    return r14
L9:
    dec_ref r1
    goto L8
L10:
    dec_ref r6
    goto L6
L11:
    dec_ref r1
    dec_ref r6
    dec_ref r7
    goto L8
L12:
    dec_ref r6
    goto L8

def PortfolioBalances.inverted(self):
    self :: eth_portfolio.typing.PortfolioBalances
    r0, r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7, r8, r9, r10 :: object
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: bool
    r16 :: str
    r17 :: object[1]
    r18 :: object_ptr
    r19, r20, r21, r22, r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27 :: object
    r28 :: bool
    r29 :: i32
    r30 :: bit
    r31 :: bool
    r32 :: object
    r33 :: eth_portfolio.typing.WalletBalancesRaw
    r34, r35 :: object
    r36 :: i32
    r37, r38, r39 :: bit
    r40 :: dict
L0:
    r0 = eth_portfolio.typing.PortfolioBalancesByCategory :: type
    r1 = _PyObject_Vectorcall(r0, 0, 0, 0)
    if is_error(r1) goto L38 (error at inverted:1059) else goto L1
L1:
    r2 = cast(dict, r1)
    if is_error(r2) goto L38 (error at inverted:1059) else goto L2
L2:
    r3 = 'items'
    r4 = [self]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r3, r5, 9223372036854775809, 0)
    if is_error(r6) goto L39 (error at inverted:1060) else goto L3
L3:
    r7 = PyObject_GetIter(r6)
    dec_ref r6
    if is_error(r7) goto L39 (error at inverted:1060) else goto L4
L4:
    r8 = PyIter_Next(r7)
    if is_error(r8) goto L40 else goto L5
L5:
    r9 = PyObject_GetIter(r8)
    dec_ref r8
    if is_error(r9) goto L41 (error at inverted:1060) else goto L6
L6:
    r10 = PyIter_Next(r9)
    if is_error(r10) goto L42 else goto L9
L7:
    r11 = raise ValueError('not enough values to unpack')
    if not r11 goto L38 (error at inverted:1060) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = PyIter_Next(r9)
    if is_error(r12) goto L43 else goto L12
L10:
    r13 = raise ValueError('not enough values to unpack')
    if not r13 goto L38 (error at inverted:1060) else goto L11 :: bool
L11:
    unreachable
L12:
    r14 = PyIter_Next(r9)
    dec_ref r9
    if is_error(r14) goto L15 else goto L44
L13:
    r15 = raise ValueError('too many values to unpack')
    if not r15 goto L38 (error at inverted:1060) else goto L14 :: bool
L14:
    unreachable
L15:
    r16 = 'items'
    r17 = [r12]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r16, r18, 9223372036854775809, 0)
    if is_error(r19) goto L45 (error at inverted:1061) else goto L16
L16:
    dec_ref r12
    r20 = PyObject_GetIter(r19)
    dec_ref r19
    if is_error(r20) goto L46 (error at inverted:1061) else goto L17
L17:
    r21 = PyIter_Next(r20)
    if is_error(r21) goto L47 else goto L18
L18:
    r22 = PyObject_GetIter(r21)
    dec_ref r21
    if is_error(r22) goto L48 (error at inverted:1061) else goto L19
L19:
    r23 = PyIter_Next(r22)
    if is_error(r23) goto L49 else goto L22
L20:
    r24 = raise ValueError('not enough values to unpack')
    if not r24 goto L38 (error at inverted:1061) else goto L21 :: bool
L21:
    unreachable
L22:
    r25 = PyIter_Next(r22)
    if is_error(r25) goto L50 else goto L25
L23:
    r26 = raise ValueError('not enough values to unpack')
    if not r26 goto L38 (error at inverted:1061) else goto L24 :: bool
L24:
    unreachable
L25:
    r27 = PyIter_Next(r22)
    dec_ref r22
    if is_error(r27) goto L28 else goto L51
L26:
    r28 = raise ValueError('too many values to unpack')
    if not r28 goto L38 (error at inverted:1061) else goto L27 :: bool
L27:
    unreachable
L28:
    r29 = PyObject_IsTrue(r25)
    r30 = r29 >= 0 :: signed
    if not r30 goto L52 (error at inverted:1061) else goto L29 :: bool
L29:
    r31 = truncate r29: i32 to builtins.bool
    if r31 goto L30 else goto L53 :: bool
L30:
    r32 = CPyDict_GetItem(r2, r23)
    dec_ref r23
    if is_error(r32) goto L54 (error at inverted:1063) else goto L31
L31:
    r33 = cast(eth_portfolio.typing.WalletBalancesRaw, r32)
    if is_error(r33) goto L54 (error at inverted:1063) else goto L32
L32:
    r34 = PyObject_GetItem(r33, r10)
    if is_error(r34) goto L55 (error at inverted:1063) else goto L33
L33:
    r35 = PyNumber_InPlaceAdd(r34, r25)
    dec_ref r34
    dec_ref r25
    if is_error(r35) goto L56 (error at inverted:1063) else goto L34
L34:
    r36 = PyObject_SetItem(r33, r10, r35)
    dec_ref r33
    dec_ref r35
    r37 = r36 >= 0 :: signed
    if not r37 goto L48 (error at inverted:1063) else goto L17 :: bool
L35:
    r38 = CPy_NoErrOccurred()
    if not r38 goto L41 (error at inverted:1061) else goto L4 :: bool
L36:
    r39 = CPy_NoErrOccurred()
    if not r39 goto L39 (error at inverted:1060) else goto L37 :: bool
L37:
    return r2
L38:
    r40 = <error> :: dict
    return r40
L39:
    dec_ref r2
    goto L38
L40:
    dec_ref r7
    goto L36
L41:
    dec_ref r2
    dec_ref r7
    goto L38
L42:
    dec_ref r2
    dec_ref r7
    dec_ref r9
    goto L7
L43:
    dec_ref r2
    dec_ref r7
    dec_ref r9
    dec_ref r10
    goto L10
L44:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r12
    dec_ref r14
    goto L13
L45:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r12
    goto L38
L46:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    goto L38
L47:
    dec_ref r10
    dec_ref r20
    goto L35
L48:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    goto L38
L49:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r22
    goto L20
L50:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r22
    dec_ref r23
    goto L23
L51:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r23
    dec_ref r25
    dec_ref r27
    goto L26
L52:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r23
    dec_ref r25
    goto L38
L53:
    dec_ref r23
    dec_ref r25
    goto L17
L54:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r25
    goto L38
L55:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r25
    dec_ref r33
    goto L38
L56:
    dec_ref r2
    dec_ref r7
    dec_ref r10
    dec_ref r20
    dec_ref r33
    goto L38

def PortfolioBalances.__bool__(self):
    self :: eth_portfolio.typing.PortfolioBalances
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3, r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bool
L0:
    r0 = 'values'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L5 (error at __bool__:1078) else goto L1
L1:
    r4 = builtins :: module
    r5 = 'any'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L6 (error at __bool__:1078) else goto L2
L2:
    r7 = [r3]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r6, r8, 1, 0)
    dec_ref r6
    if is_error(r9) goto L6 (error at __bool__:1078) else goto L3
L3:
    dec_ref r3
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L5 (error at __bool__:1078) else goto L4
L4:
    return r10
L5:
    r11 = <error> :: bool
    return r11
L6:
    dec_ref r3
    goto L5

def PortfolioBalances.__repr__(self):
    self :: eth_portfolio.typing.PortfolioBalances
    r0 :: str
    r1 :: dict
    r2, r3, r4 :: str
L0:
    r0 = 'WalletBalances'
    r1 = CPyDict_FromAny(self)
    if is_error(r1) goto L4 (error at __repr__:1087) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:1087) else goto L2
L2:
    r3 = CPyStr_Build(2, r0, r2)
    dec_ref r2
    if is_error(r3) goto L4 (error at __repr__:1087) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: str
    return r4

def PortfolioBalances.__add__(self, other):
    self, other :: eth_portfolio.typing.PortfolioBalances
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[int, None]
    r25 :: object
    r26 :: bool
    r27 :: str
    r28 :: union[int, None]
    r29, r30 :: str
    r31 :: union[int, None]
    r32, r33, r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: union[int, None]
    r42 :: union[dict, list, None]
    r43 :: eth_portfolio.typing.PortfolioBalances
    r44 :: str
    r45 :: object[1]
    r46 :: object_ptr
    r47, r48, r49, r50, r51 :: object
    r52 :: bool
    wallet, r53 :: object
    r54 :: bool
    balance, r55 :: object
    r56 :: bool
    r57 :: i32
    r58 :: bit
    r59 :: bool
    r60 :: str
    r61 :: object[2]
    r62 :: object_ptr
    r63, r64 :: object
    r65 :: str
    r66 :: object[3]
    r67 :: object_ptr
    r68 :: object
    r69 :: bit
    r70 :: str
    r71 :: object[1]
    r72 :: object_ptr
    r73, r74, r75, r76, r77 :: object
    r78 :: bool
    r79 :: object
    r80 :: bool
    r81 :: object
    r82 :: bool
    r83 :: i32
    r84 :: bit
    r85 :: bool
    r86 :: str
    r87 :: object[2]
    r88 :: object_ptr
    r89, r90 :: object
    r91 :: str
    r92 :: object[3]
    r93 :: object_ptr
    r94 :: object
    r95 :: bit
    r96 :: eth_portfolio.typing.PortfolioBalances
L0:
    r0 = eth_portfolio.typing.PortfolioBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L60 (error at __add__:1110) else goto L2
L2:
    r11 = ' is not a PortfolioBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L61 (error at __add__:1110) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L60 (error at __add__:1110) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L62 (error at __add__:1110) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L62 (error at __add__:1110) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L60 (error at __add__:1110) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.block
    r24 = other.block
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L60 (error at __add__:1111) else goto L9
L9:
    r26 = unbox(bool, r25)
    dec_ref r25
    if is_error(r26) goto L60 (error at __add__:1111) else goto L10
L10:
    if r26 goto L11 else goto L18 :: bool
L11:
    r27 = 'These PortfolioBalances objects are not from the same block ('
    r28 = self.block
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L60 (error at __add__:1113) else goto L12
L12:
    r30 = ' and '
    r31 = other.block
    r32 = PyObject_Str(r31)
    dec_ref r31
    if is_error(r32) goto L63 (error at __add__:1113) else goto L13
L13:
    r33 = ')'
    r34 = CPyStr_Build(5, r27, r29, r30, r32, r33)
    dec_ref r29
    dec_ref r32
    if is_error(r34) goto L60 (error at __add__:1113) else goto L14
L14:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L64 (error at __add__:1112) else goto L15
L15:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L64 (error at __add__:1112) else goto L16
L16:
    dec_ref r34
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L60 (error at __add__:1112) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = self.block
    r42 = <error> :: union[dict, list, None]
    r43 = PortfolioBalances(r42, r41)
    dec_ref r41
    if is_error(r43) goto L60 (error at __add__:1116) else goto L19
L19:
    r44 = 'items'
    r45 = [self]
    r46 = load_address r45
    r47 = PyObject_VectorcallMethod(r44, r46, 9223372036854775809, 0)
    if is_error(r47) goto L65 (error at __add__:1117) else goto L20
L20:
    r48 = PyObject_GetIter(r47)
    dec_ref r47
    if is_error(r48) goto L65 (error at __add__:1117) else goto L21
L21:
    r49 = PyIter_Next(r48)
    if is_error(r49) goto L66 else goto L22
L22:
    r50 = PyObject_GetIter(r49)
    dec_ref r49
    if is_error(r50) goto L67 (error at __add__:1117) else goto L23
L23:
    r51 = PyIter_Next(r50)
    if is_error(r51) goto L68 else goto L26
L24:
    r52 = raise ValueError('not enough values to unpack')
    if not r52 goto L60 (error at __add__:1117) else goto L25 :: bool
L25:
    unreachable
L26:
    wallet = r51
    r53 = PyIter_Next(r50)
    if is_error(r53) goto L69 else goto L29
L27:
    r54 = raise ValueError('not enough values to unpack')
    if not r54 goto L60 (error at __add__:1117) else goto L28 :: bool
L28:
    unreachable
L29:
    balance = r53
    r55 = PyIter_Next(r50)
    dec_ref r50
    if is_error(r55) goto L32 else goto L70
L30:
    r56 = raise ValueError('too many values to unpack')
    if not r56 goto L60 (error at __add__:1117) else goto L31 :: bool
L31:
    unreachable
L32:
    r57 = PyObject_IsTrue(balance)
    r58 = r57 >= 0 :: signed
    if not r58 goto L71 (error at __add__:1117) else goto L33 :: bool
L33:
    r59 = truncate r57: i32 to builtins.bool
    if r59 goto L34 else goto L72 :: bool
L34:
    r60 = '_getitem_nochecksum'
    r61 = [r43, wallet]
    r62 = load_address r61
    r63 = PyObject_VectorcallMethod(r60, r62, 9223372036854775810, 0)
    if is_error(r63) goto L71 (error at __add__:1119) else goto L35
L35:
    r64 = PyNumber_Add(r63, balance)
    dec_ref r63
    dec_ref balance
    if is_error(r64) goto L73 (error at __add__:1119) else goto L36
L36:
    r65 = '_setitem_nochecksum'
    r66 = [r43, wallet, r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775811, 0)
    if is_error(r68) goto L74 (error at __add__:1119) else goto L75
L37:
    dec_ref wallet
    dec_ref r64
    goto L21
L38:
    r69 = CPy_NoErrOccurred()
    if not r69 goto L65 (error at __add__:1117) else goto L39 :: bool
L39:
    r70 = 'items'
    r71 = [other]
    r72 = load_address r71
    r73 = PyObject_VectorcallMethod(r70, r72, 9223372036854775809, 0)
    if is_error(r73) goto L65 (error at __add__:1120) else goto L40
L40:
    r74 = PyObject_GetIter(r73)
    dec_ref r73
    if is_error(r74) goto L65 (error at __add__:1120) else goto L41
L41:
    r75 = PyIter_Next(r74)
    if is_error(r75) goto L76 else goto L42
L42:
    r76 = PyObject_GetIter(r75)
    dec_ref r75
    if is_error(r76) goto L77 (error at __add__:1120) else goto L43
L43:
    r77 = PyIter_Next(r76)
    if is_error(r77) goto L78 else goto L46
L44:
    r78 = raise ValueError('not enough values to unpack')
    if not r78 goto L60 (error at __add__:1120) else goto L45 :: bool
L45:
    unreachable
L46:
    wallet = r77
    r79 = PyIter_Next(r76)
    if is_error(r79) goto L79 else goto L49
L47:
    r80 = raise ValueError('not enough values to unpack')
    if not r80 goto L60 (error at __add__:1120) else goto L48 :: bool
L48:
    unreachable
L49:
    balance = r79
    r81 = PyIter_Next(r76)
    dec_ref r76
    if is_error(r81) goto L52 else goto L80
L50:
    r82 = raise ValueError('too many values to unpack')
    if not r82 goto L60 (error at __add__:1120) else goto L51 :: bool
L51:
    unreachable
L52:
    r83 = PyObject_IsTrue(balance)
    r84 = r83 >= 0 :: signed
    if not r84 goto L81 (error at __add__:1117) else goto L53 :: bool
L53:
    r85 = truncate r83: i32 to builtins.bool
    if r85 goto L54 else goto L82 :: bool
L54:
    r86 = '_getitem_nochecksum'
    r87 = [r43, wallet]
    r88 = load_address r87
    r89 = PyObject_VectorcallMethod(r86, r88, 9223372036854775810, 0)
    if is_error(r89) goto L81 (error at __add__:1122) else goto L55
L55:
    r90 = PyNumber_Add(r89, balance)
    dec_ref r89
    dec_ref balance
    if is_error(r90) goto L83 (error at __add__:1122) else goto L56
L56:
    r91 = '_setitem_nochecksum'
    r92 = [r43, wallet, r90]
    r93 = load_address r92
    r94 = PyObject_VectorcallMethod(r91, r93, 9223372036854775811, 0)
    if is_error(r94) goto L84 (error at __add__:1122) else goto L85
L57:
    dec_ref wallet
    dec_ref r90
    goto L41
L58:
    r95 = CPy_NoErrOccurred()
    if not r95 goto L65 (error at __add__:1120) else goto L59 :: bool
L59:
    return r43
L60:
    r96 = <error> :: eth_portfolio.typing.PortfolioBalances
    return r96
L61:
    dec_ref r10
    goto L60
L62:
    dec_ref r16
    goto L60
L63:
    dec_ref r29
    goto L60
L64:
    dec_ref r34
    goto L60
L65:
    dec_ref r43
    goto L60
L66:
    dec_ref r48
    goto L38
L67:
    dec_ref r43
    dec_ref r48
    goto L60
L68:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    goto L24
L69:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    dec_ref wallet
    goto L27
L70:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref balance
    dec_ref r55
    goto L30
L71:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref balance
    goto L60
L72:
    dec_ref wallet
    dec_ref balance
    goto L21
L73:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    goto L60
L74:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref r64
    goto L60
L75:
    dec_ref r68
    goto L37
L76:
    dec_ref r74
    goto L58
L77:
    dec_ref r43
    dec_ref r74
    goto L60
L78:
    dec_ref r43
    dec_ref r74
    dec_ref r76
    goto L44
L79:
    dec_ref r43
    dec_ref wallet
    dec_ref r74
    dec_ref r76
    goto L47
L80:
    dec_ref r43
    dec_ref wallet
    dec_ref balance
    dec_ref r74
    dec_ref r81
    goto L50
L81:
    dec_ref r43
    dec_ref wallet
    dec_ref balance
    dec_ref r74
    goto L60
L82:
    dec_ref wallet
    dec_ref balance
    goto L41
L83:
    dec_ref r43
    dec_ref wallet
    dec_ref r74
    goto L60
L84:
    dec_ref r43
    dec_ref wallet
    dec_ref r74
    dec_ref r90
    goto L60
L85:
    dec_ref r94
    goto L57

def PortfolioBalances.__add_____SummableNonNumericMixin_glue(self, other):
    self :: eth_portfolio.typing.PortfolioBalances
    other :: eth_portfolio.typing._SummableNonNumericMixin
    r0, r1 :: eth_portfolio.typing.PortfolioBalances
    r2 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    inc_ref other
    r0 = cast(eth_portfolio.typing.PortfolioBalances, other)
    if is_error(r0) goto L3 else goto L1
L1:
    r1 = PortfolioBalances.__add__(self, r0)
    dec_ref r0
    if is_error(r1) goto L3 else goto L2
L2:
    return r1
L3:
    r2 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r2

def PortfolioBalances.__sub__(self, other):
    self, other :: eth_portfolio.typing.PortfolioBalances
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[int, None]
    r25 :: object
    r26 :: bool
    r27 :: str
    r28 :: union[int, None]
    r29, r30 :: str
    r31 :: union[int, None]
    r32, r33, r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: union[int, None]
    r42 :: union[dict, list, None]
    r43 :: eth_portfolio.typing.PortfolioBalances
    r44 :: str
    r45 :: object[1]
    r46 :: object_ptr
    r47, r48, r49, r50, r51 :: object
    r52 :: bool
    protocol, r53 :: object
    r54 :: bool
    balances, r55 :: object
    r56 :: bool
    r57, r58 :: object
    r59 :: dict
    r60 :: None
    r61 :: bit
    r62 :: str
    r63 :: object[1]
    r64 :: object_ptr
    r65, r66, r67, r68, r69 :: object
    r70 :: bool
    r71 :: object
    r72 :: bool
    r73 :: object
    r74 :: bool
    r75 :: i32
    r76 :: bit
    r77 :: bool
    r78 :: i32
    r79, r80 :: bit
    r81 :: eth_portfolio.typing.PortfolioBalances
L0:
    r0 = eth_portfolio.typing.PortfolioBalances :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L56 (error at __sub__:1146) else goto L2
L2:
    r11 = ' is not a PortfolioBalances object'
    r12 = PyList_New(2)
    if is_error(r12) goto L57 (error at __sub__:1146) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L56 (error at __sub__:1146) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L58 (error at __sub__:1146) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L58 (error at __sub__:1146) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L56 (error at __sub__:1146) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.block
    r24 = other.block
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L56 (error at __sub__:1147) else goto L9
L9:
    r26 = unbox(bool, r25)
    dec_ref r25
    if is_error(r26) goto L56 (error at __sub__:1147) else goto L10
L10:
    if r26 goto L11 else goto L18 :: bool
L11:
    r27 = 'These PortfolioBalances objects are not from the same block ('
    r28 = self.block
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L56 (error at __sub__:1149) else goto L12
L12:
    r30 = ' and '
    r31 = other.block
    r32 = PyObject_Str(r31)
    dec_ref r31
    if is_error(r32) goto L59 (error at __sub__:1149) else goto L13
L13:
    r33 = ')'
    r34 = CPyStr_Build(5, r27, r29, r30, r32, r33)
    dec_ref r29
    dec_ref r32
    if is_error(r34) goto L56 (error at __sub__:1149) else goto L14
L14:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L60 (error at __sub__:1148) else goto L15
L15:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L60 (error at __sub__:1148) else goto L16
L16:
    dec_ref r34
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L56 (error at __sub__:1148) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = self.block
    inc_ref self
    r42 = cast(union[dict, list, None], self)
    if is_error(r42) goto L61 (error at __sub__:1152) else goto L19
L19:
    r43 = PortfolioBalances(r42, r41)
    dec_ref r42
    dec_ref r41
    if is_error(r43) goto L56 (error at __sub__:1152) else goto L20
L20:
    r44 = 'items'
    r45 = [other]
    r46 = load_address r45
    r47 = PyObject_VectorcallMethod(r44, r46, 9223372036854775809, 0)
    if is_error(r47) goto L62 (error at __sub__:1153) else goto L21
L21:
    r48 = PyObject_GetIter(r47)
    dec_ref r47
    if is_error(r48) goto L62 (error at __sub__:1153) else goto L22
L22:
    r49 = PyIter_Next(r48)
    if is_error(r49) goto L63 else goto L23
L23:
    r50 = PyObject_GetIter(r49)
    dec_ref r49
    if is_error(r50) goto L64 (error at __sub__:1153) else goto L24
L24:
    r51 = PyIter_Next(r50)
    if is_error(r51) goto L65 else goto L27
L25:
    r52 = raise ValueError('not enough values to unpack')
    if not r52 goto L56 (error at __sub__:1153) else goto L26 :: bool
L26:
    unreachable
L27:
    protocol = r51
    r53 = PyIter_Next(r50)
    if is_error(r53) goto L66 else goto L30
L28:
    r54 = raise ValueError('not enough values to unpack')
    if not r54 goto L56 (error at __sub__:1153) else goto L29 :: bool
L29:
    unreachable
L30:
    balances = r53
    r55 = PyIter_Next(r50)
    dec_ref r50
    if is_error(r55) goto L33 else goto L67
L31:
    r56 = raise ValueError('too many values to unpack')
    if not r56 goto L56 (error at __sub__:1153) else goto L32 :: bool
L32:
    unreachable
L33:
    r57 = PyObject_GetItem(r43, protocol)
    if is_error(r57) goto L68 (error at __sub__:1154) else goto L34
L34:
    r58 = PyNumber_InPlaceSubtract(r57, balances)
    dec_ref r57
    dec_ref balances
    if is_error(r58) goto L69 (error at __sub__:1154) else goto L35
L35:
    r59 = cast(dict, r58)
    if is_error(r59) goto L69 (error at __sub__:1154) else goto L36
L36:
    r60 = r43.__setitem__(protocol, r59)
    dec_ref protocol
    dec_ref r59
    if is_error(r60) goto L64 (error at __sub__:1154) else goto L22
L37:
    r61 = CPy_NoErrOccurred()
    if not r61 goto L62 (error at __sub__:1153) else goto L38 :: bool
L38:
    r62 = 'items'
    r63 = [r43]
    r64 = load_address r63
    r65 = PyObject_VectorcallMethod(r62, r64, 9223372036854775809, 0)
    if is_error(r65) goto L62 (error at __sub__:1155) else goto L39
L39:
    r66 = PyObject_GetIter(r65)
    dec_ref r65
    if is_error(r66) goto L62 (error at __sub__:1155) else goto L40
L40:
    r67 = PyIter_Next(r66)
    if is_error(r67) goto L70 else goto L41
L41:
    r68 = PyObject_GetIter(r67)
    dec_ref r67
    if is_error(r68) goto L71 (error at __sub__:1155) else goto L42
L42:
    r69 = PyIter_Next(r68)
    if is_error(r69) goto L72 else goto L45
L43:
    r70 = raise ValueError('not enough values to unpack')
    if not r70 goto L56 (error at __sub__:1155) else goto L44 :: bool
L44:
    unreachable
L45:
    protocol = r69
    r71 = PyIter_Next(r68)
    if is_error(r71) goto L73 else goto L48
L46:
    r72 = raise ValueError('not enough values to unpack')
    if not r72 goto L56 (error at __sub__:1155) else goto L47 :: bool
L47:
    unreachable
L48:
    balances = r71
    r73 = PyIter_Next(r68)
    dec_ref r68
    if is_error(r73) goto L51 else goto L74
L49:
    r74 = raise ValueError('too many values to unpack')
    if not r74 goto L56 (error at __sub__:1155) else goto L50 :: bool
L50:
    unreachable
L51:
    r75 = PyObject_IsTrue(balances)
    dec_ref balances
    r76 = r75 >= 0 :: signed
    if not r76 goto L75 (error at __sub__:1153) else goto L52 :: bool
L52:
    r77 = truncate r75: i32 to builtins.bool
    if r77 goto L76 else goto L53 :: bool
L53:
    r78 = PyObject_DelItem(r43, protocol)
    dec_ref protocol
    r79 = r78 >= 0 :: signed
    if not r79 goto L71 (error at __sub__:1157) else goto L40 :: bool
L54:
    r80 = CPy_NoErrOccurred()
    if not r80 goto L62 (error at __sub__:1155) else goto L55 :: bool
L55:
    return r43
L56:
    r81 = <error> :: eth_portfolio.typing.PortfolioBalances
    return r81
L57:
    dec_ref r10
    goto L56
L58:
    dec_ref r16
    goto L56
L59:
    dec_ref r29
    goto L56
L60:
    dec_ref r34
    goto L56
L61:
    dec_ref r41
    goto L56
L62:
    dec_ref r43
    goto L56
L63:
    dec_ref r48
    goto L37
L64:
    dec_ref r43
    dec_ref r48
    goto L56
L65:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    goto L25
L66:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    dec_ref protocol
    goto L28
L67:
    dec_ref r43
    dec_ref r48
    dec_ref protocol
    dec_ref balances
    dec_ref r55
    goto L31
L68:
    dec_ref r43
    dec_ref r48
    dec_ref protocol
    dec_ref balances
    goto L56
L69:
    dec_ref r43
    dec_ref r48
    dec_ref protocol
    goto L56
L70:
    dec_ref r66
    goto L54
L71:
    dec_ref r43
    dec_ref r66
    goto L56
L72:
    dec_ref r43
    dec_ref r66
    dec_ref r68
    goto L43
L73:
    dec_ref r43
    dec_ref protocol
    dec_ref r66
    dec_ref r68
    goto L46
L74:
    dec_ref r43
    dec_ref protocol
    dec_ref balances
    dec_ref r66
    dec_ref r73
    goto L49
L75:
    dec_ref r43
    dec_ref protocol
    dec_ref r66
    goto L56
L76:
    dec_ref protocol
    goto L40

def __mypyc_lambda__2___init___WalletBalancesRaw_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__2___init___WalletBalancesRaw_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: eth_portfolio.typing.__mypyc_lambda__2___init___WalletBalancesRaw_obj
    r0 :: eth_portfolio.typing.__init___WalletBalancesRaw_env
    r1 :: union[int, None]
    r2 :: union[dict, object, None]
    r3, r4 :: eth_portfolio.typing.TokenBalances
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L4 (error at <lambda>:1187) else goto L1
L1:
    r1 = r0.block
    dec_ref r0
    if is_error(r1) goto L4 (error at <lambda>:1187) else goto L2
L2:
    r2 = <error> :: union[dict, object, None]
    r3 = TokenBalances(r2, r1)
    dec_ref r1
    if is_error(r3) goto L4 (error at <lambda>:1187) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: eth_portfolio.typing.TokenBalances
    return r4

def WalletBalancesRaw.__init__(self, seed, block):
    self :: eth_portfolio.typing.WalletBalancesRaw
    seed :: union[dict, list, None]
    block :: union[int, None]
    r0, r1 :: object
    r2 :: eth_portfolio.typing.__init___WalletBalancesRaw_env
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: eth_portfolio.typing.__mypyc_lambda__2___init___WalletBalancesRaw_obj
    r14 :: bool
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: union[int, None]
    r19 :: object
    r20 :: bit
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: dict
    r26 :: short_int
    r27 :: native_int
    r28 :: short_int
    r29 :: object
    r30 :: tuple[bool, short_int, object, object]
    r31 :: short_int
    r32 :: bool
    r33, r34 :: object
    r35 :: eth_portfolio.typing.TokenBalances
    wallet :: object
    balances :: eth_portfolio.typing.TokenBalances
    r36, r37 :: union[int, None]
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: union[int, None]
    r42, r43 :: str
    r44 :: union[int, None]
    r45, r46, r47 :: str
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53, r54, r55 :: object
    r56 :: i32
    r57, r58, r59 :: bit
    r60 :: object
    r61 :: i32
    r62 :: bit
    r63 :: bool
    r64 :: list
    r65 :: short_int
    r66 :: ptr
    r67 :: native_int
    r68 :: short_int
    r69 :: bit
    r70 :: native_int
    r71, r72 :: ptr
    r73 :: native_int
    r74 :: ptr
    r75 :: object
    r76 :: tuple[object, eth_portfolio.typing.TokenBalances]
    r77 :: object
    r78 :: eth_portfolio.typing.TokenBalances
    r79, r80 :: union[int, None]
    r81 :: object
    r82 :: bool
    r83 :: str
    r84 :: union[int, None]
    r85, r86 :: str
    r87 :: union[int, None]
    r88, r89, r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: object[1]
    r95 :: object_ptr
    r96, r97, r98 :: object
    r99 :: i32
    r100 :: bit
    r101 :: short_int
    r102, r103, r104, r105 :: str
    r106 :: object[3]
    r107 :: object_ptr
    r108 :: object
    r109 :: str
    r110 :: list
    r111, r112, r113 :: ptr
    r114 :: str
    r115 :: object
    r116 :: str
    r117 :: object
    r118 :: object[1]
    r119 :: object_ptr
    r120 :: object
    r121 :: None
L0:
    if is_error(seed) goto L1 else goto L65
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    if is_error(block) goto L3 else goto L66
L3:
    r1 = box(None, 1)
    inc_ref r1
    block = r1
L4:
    r2 = __init___WalletBalancesRaw_env()
    if is_error(r2) goto L67 (error at __init__:1186) else goto L5
L5:
    r2.block = block; r3 = is_error
    if not r3 goto L68 (error at __init__:1186) else goto L6 :: bool
L6:
    r4 = builtins :: module
    r5 = 'super'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L68 (error at __init__:1187) else goto L7
L7:
    r7 = eth_portfolio.typing.WalletBalancesRaw :: type
    r8 = [r7, self]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r6, r9, 2, 0)
    dec_ref r6
    if is_error(r10) goto L68 (error at __init__:1187) else goto L8
L8:
    r11 = '__init__'
    r12 = CPyObject_GetAttr(r10, r11)
    dec_ref r10
    if is_error(r12) goto L68 (error at __init__:1187) else goto L9
L9:
    r13 = __mypyc_lambda__2___init___WalletBalancesRaw_obj()
    if is_error(r13) goto L69 (error at __init__:1187) else goto L10
L10:
    inc_ref r2
    r13.__mypyc_env__ = r2; r14 = is_error
    if not r14 goto L70 (error at __init__:1187) else goto L11 :: bool
L11:
    r15 = [r13]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r12, r16, 1, 0)
    dec_ref r12
    if is_error(r17) goto L71 (error at __init__:1187) else goto L72
L12:
    dec_ref r13
    r18 = r2.block
    dec_ref r2
    if is_error(r18) goto L73 (error at __init__:1188) else goto L13
L13:
    self.block = r18
    r19 = load_address _Py_NoneStruct
    r20 = seed == r19
    if r20 goto L74 else goto L15 :: bool
L14:
    return 1
L15:
    r21 = load_address PyDict_Type
    r22 = PyObject_IsInstance(seed, r21)
    r23 = r22 >= 0 :: signed
    if not r23 goto L73 (error at __init__:1191) else goto L16 :: bool
L16:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L17 else goto L36 :: bool
L17:
    r25 = cast(dict, seed)
    if is_error(r25) goto L64 (error at __init__:1192) else goto L18
L18:
    r26 = 0
    r27 = PyDict_Size(r25)
    r28 = r27 << 1
    r29 = CPyDict_GetItemsIter(r25)
    if is_error(r29) goto L75 (error at __init__:1192) else goto L19
L19:
    r30 = CPyDict_NextItem(r29, r26)
    r31 = r30[1]
    r26 = r31
    r32 = r30[0]
    if r32 goto L20 else goto L76 :: bool
L20:
    r33 = r30[2]
    r34 = r30[3]
    dec_ref r30
    r35 = cast(eth_portfolio.typing.TokenBalances, r34)
    if is_error(r35) goto L77 (error at __init__:1192) else goto L21
L21:
    wallet = r33
    balances = r35
    r36 = self.block
    r37 = balances.block
    r38 = PyObject_RichCompare(r36, r37, 3)
    dec_ref r36
    dec_ref r37
    if is_error(r38) goto L78 (error at __init__:1193) else goto L22
L22:
    r39 = unbox(bool, r38)
    dec_ref r38
    if is_error(r39) goto L78 (error at __init__:1193) else goto L23
L23:
    if r39 goto L79 else goto L31 :: bool
L24:
    r40 = 'These objects are not from the same block ('
    r41 = self.block
    r42 = PyObject_Str(r41)
    dec_ref r41
    if is_error(r42) goto L80 (error at __init__:1195) else goto L25
L25:
    r43 = ' and '
    r44 = balances.block
    dec_ref balances
    r45 = PyObject_Str(r44)
    dec_ref r44
    if is_error(r45) goto L81 (error at __init__:1195) else goto L26
L26:
    r46 = ')'
    r47 = CPyStr_Build(5, r40, r42, r43, r45, r46)
    dec_ref r42
    dec_ref r45
    if is_error(r47) goto L64 (error at __init__:1195) else goto L27
L27:
    r48 = builtins :: module
    r49 = 'ValueError'
    r50 = CPyObject_GetAttr(r48, r49)
    if is_error(r50) goto L82 (error at __init__:1194) else goto L28
L28:
    r51 = [r47]
    r52 = load_address r51
    r53 = _PyObject_Vectorcall(r50, r52, 1, 0)
    dec_ref r50
    if is_error(r53) goto L82 (error at __init__:1194) else goto L29
L29:
    dec_ref r47
    CPy_Raise(r53)
    dec_ref r53
    if not 0 goto L64 (error at __init__:1194) else goto L30 :: bool
L30:
    unreachable
L31:
    r54 = PyObject_GetItem(self, wallet)
    if is_error(r54) goto L78 (error at __init__:1197) else goto L32
L32:
    r55 = PyNumber_InPlaceAdd(r54, balances)
    dec_ref r54
    dec_ref balances
    if is_error(r55) goto L83 (error at __init__:1197) else goto L33
L33:
    r56 = PyObject_SetItem(self, wallet, r55)
    dec_ref wallet
    dec_ref r55
    r57 = r56 >= 0 :: signed
    if not r57 goto L84 (error at __init__:1197) else goto L34 :: bool
L34:
    r58 = CPyDict_CheckSize(r25, r28)
    if not r58 goto L84 (error at __init__:1192) else goto L19 :: bool
L35:
    r59 = CPy_NoErrOccurred()
    if not r59 goto L64 (error at __init__:1192) else goto L63 :: bool
L36:
    r60 = load_address PyList_Type
    r61 = PyObject_IsInstance(seed, r60)
    r62 = r61 >= 0 :: signed
    if not r62 goto L73 (error at __init__:1198) else goto L37 :: bool
L37:
    r63 = truncate r61: i32 to builtins.bool
    if r63 goto L38 else goto L56 :: bool
L38:
    r64 = cast(list, seed)
    if is_error(r64) goto L64 (error at __init__:1199) else goto L39
L39:
    r65 = 0
L40:
    r66 = get_element_ptr r64 ob_size :: PyVarObject
    r67 = load_mem r66 :: native_int*
    r68 = r67 << 1
    r69 = r65 < r68 :: signed
    if r69 goto L41 else goto L85 :: bool
L41:
    r70 = r65 >> 1
    r71 = get_element_ptr r64 ob_item :: PyListObject
    r72 = load_mem r71 :: ptr*
    r73 = r70 * 8
    r74 = r72 + r73
    r75 = load_mem r74 :: builtins.object*
    inc_ref r75
    r76 = unbox(tuple[object, eth_portfolio.typing.TokenBalances], r75)
    dec_ref r75
    if is_error(r76) goto L86 (error at __init__:1199) else goto L42
L42:
    r77 = r76[0]
    wallet = r77
    r78 = r76[1]
    dec_ref r76
    balances = r78
    r79 = self.block
    r80 = balances.block
    r81 = PyObject_RichCompare(r79, r80, 3)
    dec_ref r79
    dec_ref r80
    if is_error(r81) goto L87 (error at __init__:1200) else goto L43
L43:
    r82 = unbox(bool, r81)
    dec_ref r81
    if is_error(r82) goto L87 (error at __init__:1200) else goto L44
L44:
    if r82 goto L88 else goto L52 :: bool
L45:
    r83 = 'These objects are not from the same block ('
    r84 = self.block
    r85 = PyObject_Str(r84)
    dec_ref r84
    if is_error(r85) goto L80 (error at __init__:1202) else goto L46
L46:
    r86 = ' and '
    r87 = balances.block
    dec_ref balances
    r88 = PyObject_Str(r87)
    dec_ref r87
    if is_error(r88) goto L89 (error at __init__:1202) else goto L47
L47:
    r89 = ')'
    r90 = CPyStr_Build(5, r83, r85, r86, r88, r89)
    dec_ref r85
    dec_ref r88
    if is_error(r90) goto L64 (error at __init__:1202) else goto L48
L48:
    r91 = builtins :: module
    r92 = 'ValueError'
    r93 = CPyObject_GetAttr(r91, r92)
    if is_error(r93) goto L90 (error at __init__:1201) else goto L49
L49:
    r94 = [r90]
    r95 = load_address r94
    r96 = _PyObject_Vectorcall(r93, r95, 1, 0)
    dec_ref r93
    if is_error(r96) goto L90 (error at __init__:1201) else goto L50
L50:
    dec_ref r90
    CPy_Raise(r96)
    dec_ref r96
    if not 0 goto L64 (error at __init__:1201) else goto L51 :: bool
L51:
    unreachable
L52:
    r97 = PyObject_GetItem(self, wallet)
    if is_error(r97) goto L87 (error at __init__:1204) else goto L53
L53:
    r98 = PyNumber_InPlaceAdd(r97, balances)
    dec_ref r97
    dec_ref balances
    if is_error(r98) goto L91 (error at __init__:1204) else goto L54
L54:
    r99 = PyObject_SetItem(self, wallet, r98)
    dec_ref wallet
    dec_ref r98
    r100 = r99 >= 0 :: signed
    if not r100 goto L86 (error at __init__:1204) else goto L55 :: bool
L55:
    r101 = r65 + 2
    r65 = r101
    goto L40
L56:
    r102 = ''
    r103 = '{:{}}'
    r104 = ''
    r105 = 'format'
    r106 = [r103, seed, r104]
    r107 = load_address r106
    r108 = PyObject_VectorcallMethod(r105, r107, 9223372036854775811, 0)
    if is_error(r108) goto L73 (error at __init__:1206) else goto L57
L57:
    dec_ref seed
    r109 = ' is not a valid input for WalletBalancesRaw'
    r110 = PyList_New(2)
    if is_error(r110) goto L92 (error at __init__:1206) else goto L58
L58:
    r111 = get_element_ptr r110 ob_item :: PyListObject
    r112 = load_mem r111 :: ptr*
    set_mem r112, r108 :: builtins.object*
    inc_ref r109
    r113 = r112 + 8
    set_mem r113, r109 :: builtins.object*
    r114 = PyUnicode_Join(r102, r110)
    dec_ref r110
    if is_error(r114) goto L64 (error at __init__:1206) else goto L59
L59:
    r115 = builtins :: module
    r116 = 'TypeError'
    r117 = CPyObject_GetAttr(r115, r116)
    if is_error(r117) goto L93 (error at __init__:1206) else goto L60
L60:
    r118 = [r114]
    r119 = load_address r118
    r120 = _PyObject_Vectorcall(r117, r119, 1, 0)
    dec_ref r117
    if is_error(r120) goto L93 (error at __init__:1206) else goto L61
L61:
    dec_ref r114
    CPy_Raise(r120)
    dec_ref r120
    if not 0 goto L64 (error at __init__:1206) else goto L62 :: bool
L62:
    unreachable
L63:
    return 1
L64:
    r121 = <error> :: None
    return r121
L65:
    inc_ref seed
    goto L2
L66:
    inc_ref block
    goto L4
L67:
    dec_ref seed
    dec_ref block
    goto L64
L68:
    dec_ref seed
    dec_ref r2
    goto L64
L69:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    goto L64
L70:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    dec_ref r13
    goto L64
L71:
    dec_ref seed
    dec_ref r2
    dec_ref r13
    goto L64
L72:
    dec_ref r17
    goto L12
L73:
    dec_ref seed
    goto L64
L74:
    dec_ref seed
    goto L14
L75:
    dec_ref r25
    goto L64
L76:
    dec_ref r25
    dec_ref r29
    dec_ref r30
    goto L35
L77:
    dec_ref r25
    dec_ref r29
    dec_ref r33
    goto L64
L78:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    dec_ref balances
    goto L64
L79:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    goto L24
L80:
    dec_ref balances
    goto L64
L81:
    dec_ref r42
    goto L64
L82:
    dec_ref r47
    goto L64
L83:
    dec_ref r25
    dec_ref r29
    dec_ref wallet
    goto L64
L84:
    dec_ref r25
    dec_ref r29
    goto L64
L85:
    dec_ref r64
    goto L63
L86:
    dec_ref r64
    goto L64
L87:
    dec_ref wallet
    dec_ref balances
    dec_ref r64
    goto L64
L88:
    dec_ref wallet
    dec_ref r64
    goto L45
L89:
    dec_ref r85
    goto L64
L90:
    dec_ref r90
    goto L64
L91:
    dec_ref wallet
    dec_ref r64
    goto L64
L92:
    dec_ref r108
    goto L64
L93:
    dec_ref r114
    goto L64

def WalletBalancesRaw.__bool__(self):
    self :: eth_portfolio.typing.WalletBalancesRaw
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3, r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bool
L0:
    r0 = 'values'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L5 (error at __bool__:1220) else goto L1
L1:
    r4 = builtins :: module
    r5 = 'any'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L6 (error at __bool__:1220) else goto L2
L2:
    r7 = [r3]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r6, r8, 1, 0)
    dec_ref r6
    if is_error(r9) goto L6 (error at __bool__:1220) else goto L3
L3:
    dec_ref r3
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L5 (error at __bool__:1220) else goto L4
L4:
    return r10
L5:
    r11 = <error> :: bool
    return r11
L6:
    dec_ref r3
    goto L5

def WalletBalancesRaw.__repr__(self):
    self :: eth_portfolio.typing.WalletBalancesRaw
    r0 :: str
    r1 :: dict
    r2, r3, r4 :: str
L0:
    r0 = 'WalletBalances'
    r1 = CPyDict_FromAny(self)
    if is_error(r1) goto L4 (error at __repr__:1229) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:1229) else goto L2
L2:
    r3 = CPyStr_Build(2, r0, r2)
    dec_ref r2
    if is_error(r3) goto L4 (error at __repr__:1229) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: str
    return r4

def WalletBalancesRaw.__add__(self, other):
    self, other :: eth_portfolio.typing.WalletBalancesRaw
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[int, None]
    r25 :: object
    r26 :: bool
    r27 :: str
    r28 :: union[int, None]
    r29, r30 :: str
    r31 :: union[int, None]
    r32, r33, r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: union[int, None]
    r42 :: union[dict, list, None]
    r43 :: eth_portfolio.typing.WalletBalancesRaw
    r44 :: str
    r45 :: object[1]
    r46 :: object_ptr
    r47, r48, r49, r50, r51 :: object
    r52 :: bool
    wallet, r53 :: object
    r54 :: bool
    balance, r55 :: object
    r56 :: bool
    r57 :: i32
    r58 :: bit
    r59 :: bool
    r60 :: str
    r61 :: object[2]
    r62 :: object_ptr
    r63, r64 :: object
    r65 :: str
    r66 :: object[3]
    r67 :: object_ptr
    r68 :: object
    r69 :: bit
    r70 :: str
    r71 :: object[1]
    r72 :: object_ptr
    r73, r74, r75, r76, r77 :: object
    r78 :: bool
    r79 :: object
    r80 :: bool
    r81 :: object
    r82 :: bool
    r83 :: i32
    r84 :: bit
    r85 :: bool
    r86 :: str
    r87 :: object[2]
    r88 :: object_ptr
    r89, r90 :: object
    r91 :: str
    r92 :: object[3]
    r93 :: object_ptr
    r94 :: object
    r95 :: bit
    r96 :: eth_portfolio.typing.WalletBalancesRaw
L0:
    r0 = eth_portfolio.typing.WalletBalancesRaw :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L60 (error at __add__:1252) else goto L2
L2:
    r11 = ' is not a WalletBalancesRaw object'
    r12 = PyList_New(2)
    if is_error(r12) goto L61 (error at __add__:1252) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L60 (error at __add__:1252) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L62 (error at __add__:1252) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L62 (error at __add__:1252) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L60 (error at __add__:1252) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.block
    r24 = other.block
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L60 (error at __add__:1253) else goto L9
L9:
    r26 = unbox(bool, r25)
    dec_ref r25
    if is_error(r26) goto L60 (error at __add__:1253) else goto L10
L10:
    if r26 goto L11 else goto L18 :: bool
L11:
    r27 = 'These WalletBalancesRaw objects are not from the same block ('
    r28 = self.block
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L60 (error at __add__:1255) else goto L12
L12:
    r30 = ' and '
    r31 = other.block
    r32 = PyObject_Str(r31)
    dec_ref r31
    if is_error(r32) goto L63 (error at __add__:1255) else goto L13
L13:
    r33 = ')'
    r34 = CPyStr_Build(5, r27, r29, r30, r32, r33)
    dec_ref r29
    dec_ref r32
    if is_error(r34) goto L60 (error at __add__:1255) else goto L14
L14:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L64 (error at __add__:1254) else goto L15
L15:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L64 (error at __add__:1254) else goto L16
L16:
    dec_ref r34
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L60 (error at __add__:1254) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = self.block
    r42 = <error> :: union[dict, list, None]
    r43 = WalletBalancesRaw(r42, r41)
    dec_ref r41
    if is_error(r43) goto L60 (error at __add__:1258) else goto L19
L19:
    r44 = 'items'
    r45 = [self]
    r46 = load_address r45
    r47 = PyObject_VectorcallMethod(r44, r46, 9223372036854775809, 0)
    if is_error(r47) goto L65 (error at __add__:1259) else goto L20
L20:
    r48 = PyObject_GetIter(r47)
    dec_ref r47
    if is_error(r48) goto L65 (error at __add__:1259) else goto L21
L21:
    r49 = PyIter_Next(r48)
    if is_error(r49) goto L66 else goto L22
L22:
    r50 = PyObject_GetIter(r49)
    dec_ref r49
    if is_error(r50) goto L67 (error at __add__:1259) else goto L23
L23:
    r51 = PyIter_Next(r50)
    if is_error(r51) goto L68 else goto L26
L24:
    r52 = raise ValueError('not enough values to unpack')
    if not r52 goto L60 (error at __add__:1259) else goto L25 :: bool
L25:
    unreachable
L26:
    wallet = r51
    r53 = PyIter_Next(r50)
    if is_error(r53) goto L69 else goto L29
L27:
    r54 = raise ValueError('not enough values to unpack')
    if not r54 goto L60 (error at __add__:1259) else goto L28 :: bool
L28:
    unreachable
L29:
    balance = r53
    r55 = PyIter_Next(r50)
    dec_ref r50
    if is_error(r55) goto L32 else goto L70
L30:
    r56 = raise ValueError('too many values to unpack')
    if not r56 goto L60 (error at __add__:1259) else goto L31 :: bool
L31:
    unreachable
L32:
    r57 = PyObject_IsTrue(balance)
    r58 = r57 >= 0 :: signed
    if not r58 goto L71 (error at __add__:1259) else goto L33 :: bool
L33:
    r59 = truncate r57: i32 to builtins.bool
    if r59 goto L34 else goto L72 :: bool
L34:
    r60 = '_getitem_nochecksum'
    r61 = [r43, wallet]
    r62 = load_address r61
    r63 = PyObject_VectorcallMethod(r60, r62, 9223372036854775810, 0)
    if is_error(r63) goto L71 (error at __add__:1261) else goto L35
L35:
    r64 = PyNumber_Add(r63, balance)
    dec_ref r63
    dec_ref balance
    if is_error(r64) goto L73 (error at __add__:1261) else goto L36
L36:
    r65 = '_setitem_nochecksum'
    r66 = [r43, wallet, r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775811, 0)
    if is_error(r68) goto L74 (error at __add__:1261) else goto L75
L37:
    dec_ref wallet
    dec_ref r64
    goto L21
L38:
    r69 = CPy_NoErrOccurred()
    if not r69 goto L65 (error at __add__:1259) else goto L39 :: bool
L39:
    r70 = 'items'
    r71 = [other]
    r72 = load_address r71
    r73 = PyObject_VectorcallMethod(r70, r72, 9223372036854775809, 0)
    if is_error(r73) goto L65 (error at __add__:1262) else goto L40
L40:
    r74 = PyObject_GetIter(r73)
    dec_ref r73
    if is_error(r74) goto L65 (error at __add__:1262) else goto L41
L41:
    r75 = PyIter_Next(r74)
    if is_error(r75) goto L76 else goto L42
L42:
    r76 = PyObject_GetIter(r75)
    dec_ref r75
    if is_error(r76) goto L77 (error at __add__:1262) else goto L43
L43:
    r77 = PyIter_Next(r76)
    if is_error(r77) goto L78 else goto L46
L44:
    r78 = raise ValueError('not enough values to unpack')
    if not r78 goto L60 (error at __add__:1262) else goto L45 :: bool
L45:
    unreachable
L46:
    wallet = r77
    r79 = PyIter_Next(r76)
    if is_error(r79) goto L79 else goto L49
L47:
    r80 = raise ValueError('not enough values to unpack')
    if not r80 goto L60 (error at __add__:1262) else goto L48 :: bool
L48:
    unreachable
L49:
    balance = r79
    r81 = PyIter_Next(r76)
    dec_ref r76
    if is_error(r81) goto L52 else goto L80
L50:
    r82 = raise ValueError('too many values to unpack')
    if not r82 goto L60 (error at __add__:1262) else goto L51 :: bool
L51:
    unreachable
L52:
    r83 = PyObject_IsTrue(balance)
    r84 = r83 >= 0 :: signed
    if not r84 goto L81 (error at __add__:1259) else goto L53 :: bool
L53:
    r85 = truncate r83: i32 to builtins.bool
    if r85 goto L54 else goto L82 :: bool
L54:
    r86 = '_getitem_nochecksum'
    r87 = [r43, wallet]
    r88 = load_address r87
    r89 = PyObject_VectorcallMethod(r86, r88, 9223372036854775810, 0)
    if is_error(r89) goto L81 (error at __add__:1264) else goto L55
L55:
    r90 = PyNumber_Add(r89, balance)
    dec_ref r89
    dec_ref balance
    if is_error(r90) goto L83 (error at __add__:1264) else goto L56
L56:
    r91 = '_setitem_nochecksum'
    r92 = [r43, wallet, r90]
    r93 = load_address r92
    r94 = PyObject_VectorcallMethod(r91, r93, 9223372036854775811, 0)
    if is_error(r94) goto L84 (error at __add__:1264) else goto L85
L57:
    dec_ref wallet
    dec_ref r90
    goto L41
L58:
    r95 = CPy_NoErrOccurred()
    if not r95 goto L65 (error at __add__:1262) else goto L59 :: bool
L59:
    return r43
L60:
    r96 = <error> :: eth_portfolio.typing.WalletBalancesRaw
    return r96
L61:
    dec_ref r10
    goto L60
L62:
    dec_ref r16
    goto L60
L63:
    dec_ref r29
    goto L60
L64:
    dec_ref r34
    goto L60
L65:
    dec_ref r43
    goto L60
L66:
    dec_ref r48
    goto L38
L67:
    dec_ref r43
    dec_ref r48
    goto L60
L68:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    goto L24
L69:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    dec_ref wallet
    goto L27
L70:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref balance
    dec_ref r55
    goto L30
L71:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref balance
    goto L60
L72:
    dec_ref wallet
    dec_ref balance
    goto L21
L73:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    goto L60
L74:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref r64
    goto L60
L75:
    dec_ref r68
    goto L37
L76:
    dec_ref r74
    goto L58
L77:
    dec_ref r43
    dec_ref r74
    goto L60
L78:
    dec_ref r43
    dec_ref r74
    dec_ref r76
    goto L44
L79:
    dec_ref r43
    dec_ref wallet
    dec_ref r74
    dec_ref r76
    goto L47
L80:
    dec_ref r43
    dec_ref wallet
    dec_ref balance
    dec_ref r74
    dec_ref r81
    goto L50
L81:
    dec_ref r43
    dec_ref wallet
    dec_ref balance
    dec_ref r74
    goto L60
L82:
    dec_ref wallet
    dec_ref balance
    goto L41
L83:
    dec_ref r43
    dec_ref wallet
    dec_ref r74
    goto L60
L84:
    dec_ref r43
    dec_ref wallet
    dec_ref r74
    dec_ref r90
    goto L60
L85:
    dec_ref r94
    goto L57

def WalletBalancesRaw.__add_____SummableNonNumericMixin_glue(self, other):
    self :: eth_portfolio.typing.WalletBalancesRaw
    other :: eth_portfolio.typing._SummableNonNumericMixin
    r0, r1 :: eth_portfolio.typing.WalletBalancesRaw
    r2 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    inc_ref other
    r0 = cast(eth_portfolio.typing.WalletBalancesRaw, other)
    if is_error(r0) goto L3 else goto L1
L1:
    r1 = WalletBalancesRaw.__add__(self, r0)
    dec_ref r0
    if is_error(r1) goto L3 else goto L2
L2:
    return r1
L3:
    r2 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r2

def WalletBalancesRaw.__sub__(self, other):
    self, other :: eth_portfolio.typing.WalletBalancesRaw
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: union[int, None]
    r25 :: object
    r26 :: bool
    r27 :: str
    r28 :: union[int, None]
    r29, r30 :: str
    r31 :: union[int, None]
    r32, r33, r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: union[int, None]
    r42 :: union[dict, list, None]
    r43 :: eth_portfolio.typing.WalletBalancesRaw
    r44 :: str
    r45 :: object[1]
    r46 :: object_ptr
    r47, r48, r49, r50, r51 :: object
    r52 :: bool
    wallet, r53 :: object
    r54 :: bool
    balances, r55 :: object
    r56 :: bool
    r57 :: i32
    r58 :: bit
    r59 :: bool
    r60, r61 :: object
    r62 :: i32
    r63, r64 :: bit
    r65 :: str
    r66 :: object[1]
    r67 :: object_ptr
    r68, r69, r70, r71, r72 :: object
    r73 :: bool
    r74 :: object
    r75 :: bool
    r76 :: object
    r77 :: bool
    r78 :: i32
    r79 :: bit
    r80 :: bool
    r81 :: i32
    r82, r83 :: bit
    r84 :: eth_portfolio.typing.WalletBalancesRaw
L0:
    r0 = eth_portfolio.typing.WalletBalancesRaw :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L57 (error at __sub__:1288) else goto L2
L2:
    r11 = ' is not a WalletBalancesRaw object'
    r12 = PyList_New(2)
    if is_error(r12) goto L58 (error at __sub__:1288) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L57 (error at __sub__:1288) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L59 (error at __sub__:1288) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L59 (error at __sub__:1288) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L57 (error at __sub__:1288) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = self.block
    r24 = other.block
    r25 = PyObject_RichCompare(r23, r24, 3)
    dec_ref r23
    dec_ref r24
    if is_error(r25) goto L57 (error at __sub__:1289) else goto L9
L9:
    r26 = unbox(bool, r25)
    dec_ref r25
    if is_error(r26) goto L57 (error at __sub__:1289) else goto L10
L10:
    if r26 goto L11 else goto L18 :: bool
L11:
    r27 = 'These WalletBalancesRaw objects are not from the same block ('
    r28 = self.block
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L57 (error at __sub__:1291) else goto L12
L12:
    r30 = ' and '
    r31 = other.block
    r32 = PyObject_Str(r31)
    dec_ref r31
    if is_error(r32) goto L60 (error at __sub__:1291) else goto L13
L13:
    r33 = ')'
    r34 = CPyStr_Build(5, r27, r29, r30, r32, r33)
    dec_ref r29
    dec_ref r32
    if is_error(r34) goto L57 (error at __sub__:1291) else goto L14
L14:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L61 (error at __sub__:1290) else goto L15
L15:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L61 (error at __sub__:1290) else goto L16
L16:
    dec_ref r34
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L57 (error at __sub__:1290) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = other.block
    inc_ref self
    r42 = cast(union[dict, list, None], self)
    if is_error(r42) goto L62 (error at __sub__:1294) else goto L19
L19:
    r43 = WalletBalancesRaw(r42, r41)
    dec_ref r42
    dec_ref r41
    if is_error(r43) goto L57 (error at __sub__:1294) else goto L20
L20:
    r44 = 'items'
    r45 = [other]
    r46 = load_address r45
    r47 = PyObject_VectorcallMethod(r44, r46, 9223372036854775809, 0)
    if is_error(r47) goto L63 (error at __sub__:1295) else goto L21
L21:
    r48 = PyObject_GetIter(r47)
    dec_ref r47
    if is_error(r48) goto L63 (error at __sub__:1295) else goto L22
L22:
    r49 = PyIter_Next(r48)
    if is_error(r49) goto L64 else goto L23
L23:
    r50 = PyObject_GetIter(r49)
    dec_ref r49
    if is_error(r50) goto L65 (error at __sub__:1295) else goto L24
L24:
    r51 = PyIter_Next(r50)
    if is_error(r51) goto L66 else goto L27
L25:
    r52 = raise ValueError('not enough values to unpack')
    if not r52 goto L57 (error at __sub__:1295) else goto L26 :: bool
L26:
    unreachable
L27:
    wallet = r51
    r53 = PyIter_Next(r50)
    if is_error(r53) goto L67 else goto L30
L28:
    r54 = raise ValueError('not enough values to unpack')
    if not r54 goto L57 (error at __sub__:1295) else goto L29 :: bool
L29:
    unreachable
L30:
    balances = r53
    r55 = PyIter_Next(r50)
    dec_ref r50
    if is_error(r55) goto L33 else goto L68
L31:
    r56 = raise ValueError('too many values to unpack')
    if not r56 goto L57 (error at __sub__:1295) else goto L32 :: bool
L32:
    unreachable
L33:
    r57 = PyObject_IsTrue(balances)
    r58 = r57 >= 0 :: signed
    if not r58 goto L69 (error at __sub__:1295) else goto L34 :: bool
L34:
    r59 = truncate r57: i32 to builtins.bool
    if r59 goto L35 else goto L70 :: bool
L35:
    r60 = PyObject_GetItem(r43, wallet)
    if is_error(r60) goto L69 (error at __sub__:1297) else goto L36
L36:
    r61 = PyNumber_InPlaceSubtract(r60, balances)
    dec_ref r60
    dec_ref balances
    if is_error(r61) goto L71 (error at __sub__:1297) else goto L37
L37:
    r62 = PyObject_SetItem(r43, wallet, r61)
    dec_ref wallet
    dec_ref r61
    r63 = r62 >= 0 :: signed
    if not r63 goto L65 (error at __sub__:1297) else goto L22 :: bool
L38:
    r64 = CPy_NoErrOccurred()
    if not r64 goto L63 (error at __sub__:1295) else goto L39 :: bool
L39:
    r65 = 'items'
    r66 = [r43]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775809, 0)
    if is_error(r68) goto L63 (error at __sub__:1298) else goto L40
L40:
    r69 = PyObject_GetIter(r68)
    dec_ref r68
    if is_error(r69) goto L63 (error at __sub__:1298) else goto L41
L41:
    r70 = PyIter_Next(r69)
    if is_error(r70) goto L72 else goto L42
L42:
    r71 = PyObject_GetIter(r70)
    dec_ref r70
    if is_error(r71) goto L73 (error at __sub__:1298) else goto L43
L43:
    r72 = PyIter_Next(r71)
    if is_error(r72) goto L74 else goto L46
L44:
    r73 = raise ValueError('not enough values to unpack')
    if not r73 goto L57 (error at __sub__:1298) else goto L45 :: bool
L45:
    unreachable
L46:
    wallet = r72
    r74 = PyIter_Next(r71)
    if is_error(r74) goto L75 else goto L49
L47:
    r75 = raise ValueError('not enough values to unpack')
    if not r75 goto L57 (error at __sub__:1298) else goto L48 :: bool
L48:
    unreachable
L49:
    balances = r74
    r76 = PyIter_Next(r71)
    dec_ref r71
    if is_error(r76) goto L52 else goto L76
L50:
    r77 = raise ValueError('too many values to unpack')
    if not r77 goto L57 (error at __sub__:1298) else goto L51 :: bool
L51:
    unreachable
L52:
    r78 = PyObject_IsTrue(balances)
    dec_ref balances
    r79 = r78 >= 0 :: signed
    if not r79 goto L77 (error at __sub__:1295) else goto L53 :: bool
L53:
    r80 = truncate r78: i32 to builtins.bool
    if r80 goto L78 else goto L54 :: bool
L54:
    r81 = PyObject_DelItem(r43, wallet)
    dec_ref wallet
    r82 = r81 >= 0 :: signed
    if not r82 goto L73 (error at __sub__:1300) else goto L41 :: bool
L55:
    r83 = CPy_NoErrOccurred()
    if not r83 goto L63 (error at __sub__:1298) else goto L56 :: bool
L56:
    return r43
L57:
    r84 = <error> :: eth_portfolio.typing.WalletBalancesRaw
    return r84
L58:
    dec_ref r10
    goto L57
L59:
    dec_ref r16
    goto L57
L60:
    dec_ref r29
    goto L57
L61:
    dec_ref r34
    goto L57
L62:
    dec_ref r41
    goto L57
L63:
    dec_ref r43
    goto L57
L64:
    dec_ref r48
    goto L38
L65:
    dec_ref r43
    dec_ref r48
    goto L57
L66:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    goto L25
L67:
    dec_ref r43
    dec_ref r48
    dec_ref r50
    dec_ref wallet
    goto L28
L68:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref balances
    dec_ref r55
    goto L31
L69:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    dec_ref balances
    goto L57
L70:
    dec_ref wallet
    dec_ref balances
    goto L22
L71:
    dec_ref r43
    dec_ref r48
    dec_ref wallet
    goto L57
L72:
    dec_ref r69
    goto L55
L73:
    dec_ref r43
    dec_ref r69
    goto L57
L74:
    dec_ref r43
    dec_ref r69
    dec_ref r71
    goto L44
L75:
    dec_ref r43
    dec_ref wallet
    dec_ref r69
    dec_ref r71
    goto L47
L76:
    dec_ref r43
    dec_ref wallet
    dec_ref balances
    dec_ref r69
    dec_ref r76
    goto L50
L77:
    dec_ref r43
    dec_ref wallet
    dec_ref r69
    goto L57
L78:
    dec_ref wallet
    goto L41

def __mypyc_lambda__3___init___PortfolioBalancesByCategory_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__3___init___PortfolioBalancesByCategory_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: eth_portfolio.typing.__mypyc_lambda__3___init___PortfolioBalancesByCategory_obj
    r0 :: eth_portfolio.typing.__init___PortfolioBalancesByCategory_env
    r1 :: union[int, None]
    r2 :: union[dict, list, None]
    r3, r4 :: eth_portfolio.typing.WalletBalancesRaw
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L4 (error at <lambda>:1331) else goto L1
L1:
    r1 = r0.block
    dec_ref r0
    if is_error(r1) goto L4 (error at <lambda>:1331) else goto L2
L2:
    r2 = <error> :: union[dict, list, None]
    r3 = WalletBalancesRaw(r2, r1)
    dec_ref r1
    if is_error(r3) goto L4 (error at <lambda>:1331) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: eth_portfolio.typing.WalletBalancesRaw
    return r4

def PortfolioBalancesByCategory.__init__(self, seed, block):
    self :: dict
    seed :: union[dict, object, None]
    block :: union[int, None]
    r0, r1 :: object
    r2 :: eth_portfolio.typing.__init___PortfolioBalancesByCategory_env
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: eth_portfolio.typing.__mypyc_lambda__3___init___PortfolioBalancesByCategory_obj
    r14 :: bool
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: union[int, None]
    r19 :: str
    r20 :: i32
    r21 :: bit
    r22 :: object
    r23 :: bit
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: bool
    r28 :: dict
    r29 :: object
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: bool
    r36, r37, r38, r39 :: str
    r40 :: object[3]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44 :: list
    r45, r46, r47 :: ptr
    r48 :: str
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: object[1]
    r53 :: object_ptr
    r54, r55, r56 :: object
    r57 :: union[str, tuple[str, eth_portfolio.typing.WalletBalancesRaw]]
    r58, r59 :: object
    r60 :: bool
    label :: union[object, str]
    r61 :: object
    r62 :: bool
    balances :: union[object, eth_portfolio.typing.WalletBalancesRaw]
    r63 :: object
    r64 :: bool
    r65 :: str
    r66 :: object
    r67 :: union[int, None]
    r68 :: object
    r69 :: ptr
    r70 :: object
    r71 :: bit
    r72 :: eth_portfolio.typing.WalletBalancesRaw
    r73 :: union[int, None]
    r74 :: union[object, int, None]
    r75 :: object
    r76 :: str
    r77, r78 :: object
    r79 :: bool
    r80, r81 :: str
    r82 :: object
    r83 :: union[int, None]
    r84, r85 :: str
    r86 :: object
    r87 :: ptr
    r88 :: object
    r89 :: bit
    r90 :: eth_portfolio.typing.WalletBalancesRaw
    r91 :: union[int, None]
    r92 :: union[object, int, None]
    r93 :: object
    r94 :: str
    r95 :: object
    r96, r97, r98 :: str
    r99 :: object
    r100 :: str
    r101 :: object
    r102 :: object[1]
    r103 :: object_ptr
    r104, r105, r106 :: object
    r107 :: i32
    r108, r109 :: bit
    r110 :: None
L0:
    if is_error(seed) goto L1 else goto L74
L1:
    r0 = box(None, 1)
    inc_ref r0
    seed = r0
L2:
    if is_error(block) goto L3 else goto L75
L3:
    r1 = box(None, 1)
    inc_ref r1
    block = r1
L4:
    r2 = __init___PortfolioBalancesByCategory_env()
    if is_error(r2) goto L76 (error at __init__:1330) else goto L5
L5:
    r2.block = block; r3 = is_error
    if not r3 goto L77 (error at __init__:1330) else goto L6 :: bool
L6:
    r4 = builtins :: module
    r5 = 'super'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L77 (error at __init__:1331) else goto L7
L7:
    r7 = eth_portfolio.typing.PortfolioBalancesByCategory :: type
    r8 = [r7, self]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r6, r9, 2, 0)
    dec_ref r6
    if is_error(r10) goto L77 (error at __init__:1331) else goto L8
L8:
    r11 = '__init__'
    r12 = CPyObject_GetAttr(r10, r11)
    dec_ref r10
    if is_error(r12) goto L77 (error at __init__:1331) else goto L9
L9:
    r13 = __mypyc_lambda__3___init___PortfolioBalancesByCategory_obj()
    if is_error(r13) goto L78 (error at __init__:1331) else goto L10
L10:
    inc_ref r2
    r13.__mypyc_env__ = r2; r14 = is_error
    if not r14 goto L79 (error at __init__:1331) else goto L11 :: bool
L11:
    r15 = [r13]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r12, r16, 1, 0)
    dec_ref r12
    if is_error(r17) goto L80 (error at __init__:1331) else goto L81
L12:
    dec_ref r13
    r18 = r2.block
    dec_ref r2
    if is_error(r18) goto L82 (error at __init__:1332) else goto L13
L13:
    r19 = 'block'
    r20 = PyObject_SetAttr(self, r19, r18)
    dec_ref r18
    r21 = r20 >= 0 :: signed
    if not r21 goto L82 (error at __init__:1332) else goto L14 :: bool
L14:
    r22 = load_address _Py_NoneStruct
    r23 = seed == r22
    if r23 goto L83 else goto L16 :: bool
L15:
    return 1
L16:
    r24 = load_address PyDict_Type
    r25 = PyObject_IsInstance(seed, r24)
    r26 = r25 >= 0 :: signed
    if not r26 goto L82 (error at __init__:1335) else goto L17 :: bool
L17:
    r27 = truncate r25: i32 to builtins.bool
    if r27 goto L18 else goto L21 :: bool
L18:
    r28 = cast(dict, seed)
    if is_error(r28) goto L73 (error at __init__:1336) else goto L19
L19:
    r29 = CPyDict_ItemsView(r28)
    dec_ref r28
    if is_error(r29) goto L73 (error at __init__:1336) else goto L20
L20:
    seed = r29
L21:
    r30 = eth_portfolio.typing.globals :: static
    r31 = 'Iterable'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L82 (error at __init__:1337) else goto L22
L22:
    r33 = PyObject_IsInstance(seed, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L82 (error at __init__:1337) else goto L23 :: bool
L23:
    r35 = truncate r33: i32 to builtins.bool
    if r35 goto L31 else goto L24 :: bool
L24:
    r36 = ''
    r37 = '{:{}}'
    r38 = ''
    r39 = 'format'
    r40 = [r37, seed, r38]
    r41 = load_address r40
    r42 = PyObject_VectorcallMethod(r39, r41, 9223372036854775811, 0)
    if is_error(r42) goto L82 (error at __init__:1338) else goto L25
L25:
    dec_ref seed
    r43 = ' is not a valid input for PortfolioBalancesByCategory'
    r44 = PyList_New(2)
    if is_error(r44) goto L84 (error at __init__:1338) else goto L26
L26:
    r45 = get_element_ptr r44 ob_item :: PyListObject
    r46 = load_mem r45 :: ptr*
    set_mem r46, r42 :: builtins.object*
    inc_ref r43
    r47 = r46 + 8
    set_mem r47, r43 :: builtins.object*
    r48 = PyUnicode_Join(r36, r44)
    dec_ref r44
    if is_error(r48) goto L73 (error at __init__:1338) else goto L27
L27:
    r49 = builtins :: module
    r50 = 'TypeError'
    r51 = CPyObject_GetAttr(r49, r50)
    if is_error(r51) goto L85 (error at __init__:1338) else goto L28
L28:
    r52 = [r48]
    r53 = load_address r52
    r54 = _PyObject_Vectorcall(r51, r53, 1, 0)
    dec_ref r51
    if is_error(r54) goto L85 (error at __init__:1338) else goto L29
L29:
    dec_ref r48
    CPy_Raise(r54)
    dec_ref r54
    if not 0 goto L73 (error at __init__:1338) else goto L30 :: bool
L30:
    unreachable
L31:
    r55 = PyObject_GetIter(seed)
    dec_ref seed
    if is_error(r55) goto L73 (error at __init__:1339) else goto L32
L32:
    r56 = PyIter_Next(r55)
    if is_error(r56) goto L86 else goto L33
L33:
    r57 = cast(union[str, tuple[str, eth_portfolio.typing.WalletBalancesRaw]], r56)
    if is_error(r57) goto L87 (error at __init__:1339) else goto L34
L34:
    r58 = PyObject_GetIter(r57)
    dec_ref r57
    if is_error(r58) goto L87 (error at __init__:1339) else goto L35
L35:
    r59 = PyIter_Next(r58)
    if is_error(r59) goto L88 else goto L38
L36:
    r60 = raise ValueError('not enough values to unpack')
    if not r60 goto L73 (error at __init__:1339) else goto L37 :: bool
L37:
    unreachable
L38:
    label = r59
    r61 = PyIter_Next(r58)
    if is_error(r61) goto L89 else goto L41
L39:
    r62 = raise ValueError('not enough values to unpack')
    if not r62 goto L73 (error at __init__:1339) else goto L40 :: bool
L40:
    unreachable
L41:
    balances = r61
    r63 = PyIter_Next(r58)
    dec_ref r58
    if is_error(r63) goto L44 else goto L90
L42:
    r64 = raise ValueError('too many values to unpack')
    if not r64 goto L73 (error at __init__:1339) else goto L43 :: bool
L43:
    unreachable
L44:
    r65 = 'block'
    r66 = CPyObject_GetAttr(self, r65)
    if is_error(r66) goto L91 (error at __init__:1340) else goto L45
L45:
    r67 = cast(union[int, None], r66)
    if is_error(r67) goto L91 (error at __init__:1340) else goto L46
L46:
    r68 = eth_portfolio.typing.WalletBalancesRaw :: type
    r69 = get_element_ptr balances ob_type :: PyObject
    r70 = load_mem r69 :: builtins.object*
    r71 = r70 == r68
    if r71 goto L47 else goto L49 :: bool
L47:
    inc_ref balances
    r72 = cast(eth_portfolio.typing.WalletBalancesRaw, balances)
    if is_error(r72) goto L92 (error at __init__:1340) else goto L48
L48:
    r73 = r72.block
    dec_ref r72
    r74 = r73
    goto L51
L49:
    inc_ref balances
    r75 = balances
    r76 = 'block'
    r77 = CPyObject_GetAttr(r75, r76)
    dec_ref r75
    if is_error(r77) goto L92 (error at __init__:1340) else goto L50
L50:
    r74 = r77
L51:
    r78 = PyObject_RichCompare(r67, r74, 3)
    dec_ref r67
    dec_ref r74
    if is_error(r78) goto L91 (error at __init__:1340) else goto L52
L52:
    r79 = unbox(bool, r78)
    dec_ref r78
    if is_error(r79) goto L91 (error at __init__:1340) else goto L53
L53:
    if r79 goto L93 else goto L68 :: bool
L54:
    r80 = 'These objects are not from the same block ('
    r81 = 'block'
    r82 = CPyObject_GetAttr(self, r81)
    if is_error(r82) goto L94 (error at __init__:1342) else goto L55
L55:
    r83 = cast(union[int, None], r82)
    if is_error(r83) goto L94 (error at __init__:1342) else goto L56
L56:
    r84 = PyObject_Str(r83)
    dec_ref r83
    if is_error(r84) goto L94 (error at __init__:1342) else goto L57
L57:
    r85 = ' and '
    r86 = eth_portfolio.typing.WalletBalancesRaw :: type
    r87 = get_element_ptr balances ob_type :: PyObject
    r88 = load_mem r87 :: builtins.object*
    r89 = r88 == r86
    if r89 goto L58 else goto L60 :: bool
L58:
    r90 = cast(eth_portfolio.typing.WalletBalancesRaw, balances)
    if is_error(r90) goto L95 (error at __init__:1342) else goto L59
L59:
    r91 = r90.block
    dec_ref r90
    r92 = r91
    goto L62
L60:
    r93 = balances
    r94 = 'block'
    r95 = CPyObject_GetAttr(r93, r94)
    dec_ref r93
    if is_error(r95) goto L95 (error at __init__:1342) else goto L61
L61:
    r92 = r95
L62:
    r96 = PyObject_Str(r92)
    dec_ref r92
    if is_error(r96) goto L95 (error at __init__:1342) else goto L63
L63:
    r97 = ')'
    r98 = CPyStr_Build(5, r80, r84, r85, r96, r97)
    dec_ref r84
    dec_ref r96
    if is_error(r98) goto L73 (error at __init__:1342) else goto L64
L64:
    r99 = builtins :: module
    r100 = 'ValueError'
    r101 = CPyObject_GetAttr(r99, r100)
    if is_error(r101) goto L96 (error at __init__:1341) else goto L65
L65:
    r102 = [r98]
    r103 = load_address r102
    r104 = _PyObject_Vectorcall(r101, r103, 1, 0)
    dec_ref r101
    if is_error(r104) goto L96 (error at __init__:1341) else goto L66
L66:
    dec_ref r98
    CPy_Raise(r104)
    dec_ref r104
    if not 0 goto L73 (error at __init__:1341) else goto L67 :: bool
L67:
    unreachable
L68:
    r105 = CPyDict_GetItem(self, label)
    if is_error(r105) goto L91 (error at __init__:1344) else goto L69
L69:
    r106 = PyNumber_InPlaceAdd(r105, balances)
    dec_ref r105
    dec_ref balances
    if is_error(r106) goto L97 (error at __init__:1344) else goto L70
L70:
    r107 = CPyDict_SetItem(self, label, r106)
    dec_ref label
    dec_ref r106
    r108 = r107 >= 0 :: signed
    if not r108 goto L87 (error at __init__:1344) else goto L32 :: bool
L71:
    r109 = CPy_NoErrOccurred()
    if not r109 goto L73 (error at __init__:1339) else goto L72 :: bool
L72:
    return 1
L73:
    r110 = <error> :: None
    return r110
L74:
    inc_ref seed
    goto L2
L75:
    inc_ref block
    goto L4
L76:
    dec_ref seed
    dec_ref block
    goto L73
L77:
    dec_ref seed
    dec_ref r2
    goto L73
L78:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    goto L73
L79:
    dec_ref seed
    dec_ref r2
    dec_ref r12
    dec_ref r13
    goto L73
L80:
    dec_ref seed
    dec_ref r2
    dec_ref r13
    goto L73
L81:
    dec_ref r17
    goto L12
L82:
    dec_ref seed
    goto L73
L83:
    dec_ref seed
    goto L15
L84:
    dec_ref r42
    goto L73
L85:
    dec_ref r48
    goto L73
L86:
    dec_ref r55
    goto L71
L87:
    dec_ref r55
    goto L73
L88:
    dec_ref r55
    dec_ref r58
    goto L36
L89:
    dec_ref r55
    dec_ref r58
    dec_ref label
    goto L39
L90:
    dec_ref r55
    dec_ref label
    dec_ref balances
    dec_ref r63
    goto L42
L91:
    dec_ref r55
    dec_ref label
    dec_ref balances
    goto L73
L92:
    dec_ref r55
    dec_ref label
    dec_ref balances
    dec_ref r67
    goto L73
L93:
    dec_ref r55
    dec_ref label
    goto L54
L94:
    dec_ref balances
    goto L73
L95:
    dec_ref r84
    goto L73
L96:
    dec_ref r98
    goto L73
L97:
    dec_ref r55
    dec_ref label
    goto L73

def PortfolioBalancesByCategory.assets(self):
    self :: dict
    r0 :: str
    r1 :: object
    r2, r3 :: eth_portfolio.typing.WalletBalancesRaw
L0:
    r0 = 'assets'
    r1 = CPyDict_GetItem(self, r0)
    if is_error(r1) goto L3 (error at assets:1354) else goto L1
L1:
    r2 = cast(eth_portfolio.typing.WalletBalancesRaw, r1)
    if is_error(r2) goto L3 (error at assets:1354) else goto L2
L2:
    return r2
L3:
    r3 = <error> :: eth_portfolio.typing.WalletBalancesRaw
    return r3

def PortfolioBalancesByCategory.debt(self):
    self :: dict
    r0 :: str
    r1 :: object
    r2, r3 :: eth_portfolio.typing.WalletBalancesRaw
L0:
    r0 = 'debt'
    r1 = CPyDict_GetItem(self, r0)
    if is_error(r1) goto L3 (error at debt:1364) else goto L1
L1:
    r2 = cast(eth_portfolio.typing.WalletBalancesRaw, r1)
    if is_error(r2) goto L3 (error at debt:1364) else goto L2
L2:
    return r2
L3:
    r3 = <error> :: eth_portfolio.typing.WalletBalancesRaw
    return r3

def PortfolioBalancesByCategory.invert(self):
    self :: dict
    r0 :: union[dict, list, None]
    r1 :: union[int, None]
    r2 :: eth_portfolio.typing.PortfolioBalances
    r3 :: short_int
    r4 :: native_int
    r5 :: short_int
    r6 :: object
    r7 :: tuple[bool, short_int, object, object]
    r8 :: short_int
    r9 :: bool
    r10, r11 :: object
    r12 :: str
    r13 :: eth_portfolio.typing.WalletBalancesRaw
    r14 :: str
    r15 :: object[1]
    r16 :: object_ptr
    r17, r18, r19, r20, r21 :: object
    r22 :: bool
    r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27 :: i32
    r28 :: bit
    r29 :: bool
    r30, r31, r32 :: object
    r33 :: i32
    r34, r35, r36, r37 :: bit
    r38 :: eth_portfolio.typing.PortfolioBalances
L0:
    r0 = <error> :: union[dict, list, None]
    r1 = <error> :: union[int, None]
    r2 = PortfolioBalances(r0, r1)
    if is_error(r2) goto L28 (error at invert:1379) else goto L1
L1:
    r3 = 0
    r4 = PyDict_Size(self)
    r5 = r4 << 1
    r6 = CPyDict_GetItemsIter(self)
    if is_error(r6) goto L29 (error at invert:1380) else goto L2
L2:
    r7 = CPyDict_NextItem(r6, r3)
    r8 = r7[1]
    r3 = r8
    r9 = r7[0]
    if r9 goto L3 else goto L30 :: bool
L3:
    r10 = r7[2]
    r11 = r7[3]
    dec_ref r7
    r12 = cast(str, r10)
    if is_error(r12) goto L31 (error at invert:1380) else goto L4
L4:
    r13 = cast(eth_portfolio.typing.WalletBalancesRaw, r11)
    if is_error(r13) goto L32 (error at invert:1380) else goto L5
L5:
    r14 = 'items'
    r15 = [r13]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775809, 0)
    if is_error(r17) goto L33 (error at invert:1381) else goto L6
L6:
    dec_ref r13
    r18 = PyObject_GetIter(r17)
    dec_ref r17
    if is_error(r18) goto L34 (error at invert:1381) else goto L7
L7:
    r19 = PyIter_Next(r18)
    if is_error(r19) goto L35 else goto L8
L8:
    r20 = PyObject_GetIter(r19)
    dec_ref r19
    if is_error(r20) goto L36 (error at invert:1381) else goto L9
L9:
    r21 = PyIter_Next(r20)
    if is_error(r21) goto L37 else goto L12
L10:
    r22 = raise ValueError('not enough values to unpack')
    if not r22 goto L28 (error at invert:1381) else goto L11 :: bool
L11:
    unreachable
L12:
    r23 = PyIter_Next(r20)
    if is_error(r23) goto L38 else goto L15
L13:
    r24 = raise ValueError('not enough values to unpack')
    if not r24 goto L28 (error at invert:1381) else goto L14 :: bool
L14:
    unreachable
L15:
    r25 = PyIter_Next(r20)
    dec_ref r20
    if is_error(r25) goto L18 else goto L39
L16:
    r26 = raise ValueError('too many values to unpack')
    if not r26 goto L28 (error at invert:1381) else goto L17 :: bool
L17:
    unreachable
L18:
    r27 = PyObject_IsTrue(r23)
    r28 = r27 >= 0 :: signed
    if not r28 goto L40 (error at invert:1381) else goto L19 :: bool
L19:
    r29 = truncate r27: i32 to builtins.bool
    if r29 goto L20 else goto L41 :: bool
L20:
    r30 = PyObject_GetItem(r2, r21)
    dec_ref r21
    if is_error(r30) goto L42 (error at invert:1383) else goto L21
L21:
    r31 = PyObject_GetItem(r30, r12)
    if is_error(r31) goto L43 (error at invert:1383) else goto L22
L22:
    r32 = PyNumber_InPlaceAdd(r31, r23)
    dec_ref r31
    dec_ref r23
    if is_error(r32) goto L44 (error at invert:1383) else goto L23
L23:
    r33 = PyObject_SetItem(r30, r12, r32)
    dec_ref r30
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L36 (error at invert:1383) else goto L7 :: bool
L24:
    r35 = CPy_NoErrOccurred()
    if not r35 goto L45 (error at invert:1381) else goto L25 :: bool
L25:
    r36 = CPyDict_CheckSize(self, r5)
    if not r36 goto L45 (error at invert:1380) else goto L2 :: bool
L26:
    r37 = CPy_NoErrOccurred()
    if not r37 goto L29 (error at invert:1380) else goto L27 :: bool
L27:
    return r2
L28:
    r38 = <error> :: eth_portfolio.typing.PortfolioBalances
    return r38
L29:
    dec_ref r2
    goto L28
L30:
    dec_ref r6
    dec_ref r7
    goto L26
L31:
    dec_ref r2
    dec_ref r6
    dec_ref r11
    goto L28
L32:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    goto L28
L33:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r13
    goto L28
L34:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    goto L28
L35:
    dec_ref r12
    dec_ref r18
    goto L24
L36:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    goto L28
L37:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r20
    goto L10
L38:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r20
    dec_ref r21
    goto L13
L39:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r21
    dec_ref r23
    dec_ref r25
    goto L16
L40:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r21
    dec_ref r23
    goto L28
L41:
    dec_ref r21
    dec_ref r23
    goto L7
L42:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r23
    goto L28
L43:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r23
    dec_ref r30
    goto L28
L44:
    dec_ref r2
    dec_ref r6
    dec_ref r12
    dec_ref r18
    dec_ref r30
    goto L28
L45:
    dec_ref r2
    dec_ref r6
    goto L28

def PortfolioBalancesByCategory.__bool__(self):
    self :: dict
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bool
L0:
    r0 = CPyDict_ValuesView(self)
    if is_error(r0) goto L5 (error at __bool__:1398) else goto L1
L1:
    r1 = builtins :: module
    r2 = 'any'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L6 (error at __bool__:1398) else goto L2
L2:
    r4 = [r0]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L6 (error at __bool__:1398) else goto L3
L3:
    dec_ref r0
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L5 (error at __bool__:1398) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: bool
    return r8
L6:
    dec_ref r0
    goto L5

def PortfolioBalancesByCategory.__repr__(self):
    self :: dict
    r0 :: str
    r1 :: dict
    r2, r3, r4 :: str
L0:
    r0 = 'PortfolioBalancesByCategory'
    r1 = PyDict_Copy(self)
    if is_error(r1) goto L4 (error at __repr__:1407) else goto L1
L1:
    r2 = PyObject_Str(r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at __repr__:1407) else goto L2
L2:
    r3 = CPyStr_Build(2, r0, r2)
    dec_ref r2
    if is_error(r3) goto L4 (error at __repr__:1407) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: str
    return r4

def PortfolioBalancesByCategory.__add__(self, other):
    self, other :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: union[int, None]
    r26 :: str
    r27 :: object
    r28 :: union[int, None]
    r29 :: object
    r30 :: bool
    r31, r32 :: str
    r33 :: object
    r34 :: union[int, None]
    r35, r36, r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40, r41, r42 :: str
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: union[int, None]
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: dict
    r58 :: short_int
    r59 :: native_int
    r60 :: short_int
    r61 :: object
    r62 :: tuple[bool, short_int, object, object]
    r63 :: short_int
    r64 :: bool
    r65, r66 :: object
    r67 :: str
    r68 :: eth_portfolio.typing.WalletBalancesRaw
    protocol :: str
    balances :: eth_portfolio.typing.WalletBalancesRaw
    r69 :: bool
    r70, r71 :: object
    r72 :: i32
    r73, r74, r75 :: bit
    r76 :: short_int
    r77 :: native_int
    r78 :: short_int
    r79 :: object
    r80 :: tuple[bool, short_int, object, object]
    r81 :: short_int
    r82 :: bool
    r83, r84 :: object
    r85 :: str
    r86 :: eth_portfolio.typing.WalletBalancesRaw
    r87 :: bool
    r88, r89 :: object
    r90 :: i32
    r91, r92, r93 :: bit
    r94 :: dict
L0:
    r0 = eth_portfolio.typing.PortfolioBalancesByCategory :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L53 (error at __add__:1430) else goto L2
L2:
    r11 = ' is not a PortfolioBalancesByCategory object'
    r12 = PyList_New(2)
    if is_error(r12) goto L54 (error at __add__:1430) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L53 (error at __add__:1430) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L55 (error at __add__:1430) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L55 (error at __add__:1430) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L53 (error at __add__:1430) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = 'block'
    r24 = CPyObject_GetAttr(self, r23)
    if is_error(r24) goto L53 (error at __add__:1431) else goto L9
L9:
    r25 = cast(union[int, None], r24)
    if is_error(r25) goto L53 (error at __add__:1431) else goto L10
L10:
    r26 = 'block'
    r27 = CPyObject_GetAttr(other, r26)
    if is_error(r27) goto L56 (error at __add__:1431) else goto L11
L11:
    r28 = cast(union[int, None], r27)
    if is_error(r28) goto L56 (error at __add__:1431) else goto L12
L12:
    r29 = PyObject_RichCompare(r25, r28, 3)
    dec_ref r25
    dec_ref r28
    if is_error(r29) goto L53 (error at __add__:1431) else goto L13
L13:
    r30 = unbox(bool, r29)
    dec_ref r29
    if is_error(r30) goto L53 (error at __add__:1431) else goto L14
L14:
    if r30 goto L15 else goto L26 :: bool
L15:
    r31 = 'These PortfolioBalancesByCategory objects are not from the same block ('
    r32 = 'block'
    r33 = CPyObject_GetAttr(self, r32)
    if is_error(r33) goto L53 (error at __add__:1433) else goto L16
L16:
    r34 = cast(union[int, None], r33)
    if is_error(r34) goto L53 (error at __add__:1433) else goto L17
L17:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L53 (error at __add__:1433) else goto L18
L18:
    r36 = ' and '
    r37 = 'block'
    r38 = CPyObject_GetAttr(other, r37)
    if is_error(r38) goto L57 (error at __add__:1433) else goto L19
L19:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L57 (error at __add__:1433) else goto L20
L20:
    r40 = PyObject_Str(r39)
    dec_ref r39
    if is_error(r40) goto L57 (error at __add__:1433) else goto L21
L21:
    r41 = ')'
    r42 = CPyStr_Build(5, r31, r35, r36, r40, r41)
    dec_ref r35
    dec_ref r40
    if is_error(r42) goto L53 (error at __add__:1433) else goto L22
L22:
    r43 = builtins :: module
    r44 = 'ValueError'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L58 (error at __add__:1432) else goto L23
L23:
    r46 = [r42]
    r47 = load_address r46
    r48 = _PyObject_Vectorcall(r45, r47, 1, 0)
    dec_ref r45
    if is_error(r48) goto L58 (error at __add__:1432) else goto L24
L24:
    dec_ref r42
    CPy_Raise(r48)
    dec_ref r48
    if not 0 goto L53 (error at __add__:1432) else goto L25 :: bool
L25:
    unreachable
L26:
    r49 = 'block'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L53 (error at __add__:1436) else goto L27
L27:
    r51 = cast(union[int, None], r50)
    if is_error(r51) goto L53 (error at __add__:1436) else goto L28
L28:
    r52 = eth_portfolio.typing.PortfolioBalancesByCategory :: type
    r53 = [r51]
    r54 = load_address r53
    r55 = ('block',)
    r56 = _PyObject_Vectorcall(r52, r54, 0, r55)
    if is_error(r56) goto L59 (error at __add__:1436) else goto L29
L29:
    dec_ref r51
    r57 = cast(dict, r56)
    if is_error(r57) goto L53 (error at __add__:1436) else goto L30
L30:
    r58 = 0
    r59 = PyDict_Size(self)
    r60 = r59 << 1
    r61 = CPyDict_GetItemsIter(self)
    if is_error(r61) goto L60 (error at __add__:1437) else goto L31
L31:
    r62 = CPyDict_NextItem(r61, r58)
    r63 = r62[1]
    r58 = r63
    r64 = r62[0]
    if r64 goto L32 else goto L61 :: bool
L32:
    r65 = r62[2]
    r66 = r62[3]
    dec_ref r62
    r67 = cast(str, r65)
    if is_error(r67) goto L62 (error at __add__:1437) else goto L33
L33:
    r68 = cast(eth_portfolio.typing.WalletBalancesRaw, r66)
    if is_error(r68) goto L63 (error at __add__:1437) else goto L34
L34:
    protocol = r67
    balances = r68
    r69 = balances.__bool__()
    if is_error(r69) goto L64 (error at __add__:1437) else goto L35
L35:
    if r69 goto L36 else goto L65 :: bool
L36:
    r70 = CPyDict_GetItem(r57, protocol)
    if is_error(r70) goto L64 (error at __add__:1439) else goto L37
L37:
    r71 = PyNumber_InPlaceAdd(r70, balances)
    dec_ref r70
    dec_ref balances
    if is_error(r71) goto L66 (error at __add__:1439) else goto L38
L38:
    r72 = CPyDict_SetItem(r57, protocol, r71)
    dec_ref protocol
    dec_ref r71
    r73 = r72 >= 0 :: signed
    if not r73 goto L67 (error at __add__:1439) else goto L39 :: bool
L39:
    r74 = CPyDict_CheckSize(self, r60)
    if not r74 goto L67 (error at __add__:1437) else goto L31 :: bool
L40:
    r75 = CPy_NoErrOccurred()
    if not r75 goto L60 (error at __add__:1437) else goto L41 :: bool
L41:
    r76 = 0
    r77 = PyDict_Size(other)
    r78 = r77 << 1
    r79 = CPyDict_GetItemsIter(other)
    if is_error(r79) goto L60 (error at __add__:1440) else goto L42
L42:
    r80 = CPyDict_NextItem(r79, r76)
    r81 = r80[1]
    r76 = r81
    r82 = r80[0]
    if r82 goto L43 else goto L68 :: bool
L43:
    r83 = r80[2]
    r84 = r80[3]
    dec_ref r80
    r85 = cast(str, r83)
    if is_error(r85) goto L69 (error at __add__:1440) else goto L44
L44:
    r86 = cast(eth_portfolio.typing.WalletBalancesRaw, r84)
    if is_error(r86) goto L70 (error at __add__:1440) else goto L45
L45:
    protocol = r85
    balances = r86
    r87 = balances.__bool__()
    if is_error(r87) goto L71 (error at __add__:1437) else goto L46
L46:
    if r87 goto L47 else goto L72 :: bool
L47:
    r88 = CPyDict_GetItem(r57, protocol)
    if is_error(r88) goto L71 (error at __add__:1442) else goto L48
L48:
    r89 = PyNumber_InPlaceAdd(r88, balances)
    dec_ref r88
    dec_ref balances
    if is_error(r89) goto L73 (error at __add__:1442) else goto L49
L49:
    r90 = CPyDict_SetItem(r57, protocol, r89)
    dec_ref protocol
    dec_ref r89
    r91 = r90 >= 0 :: signed
    if not r91 goto L74 (error at __add__:1442) else goto L50 :: bool
L50:
    r92 = CPyDict_CheckSize(other, r78)
    if not r92 goto L74 (error at __add__:1440) else goto L42 :: bool
L51:
    r93 = CPy_NoErrOccurred()
    if not r93 goto L60 (error at __add__:1440) else goto L52 :: bool
L52:
    return r57
L53:
    r94 = <error> :: dict
    return r94
L54:
    dec_ref r10
    goto L53
L55:
    dec_ref r16
    goto L53
L56:
    dec_ref r25
    goto L53
L57:
    dec_ref r35
    goto L53
L58:
    dec_ref r42
    goto L53
L59:
    dec_ref r51
    goto L53
L60:
    dec_ref r57
    goto L53
L61:
    dec_ref r61
    dec_ref r62
    goto L40
L62:
    dec_ref r57
    dec_ref r61
    dec_ref r66
    goto L53
L63:
    dec_ref r57
    dec_ref r61
    dec_ref r67
    goto L53
L64:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    dec_ref balances
    goto L53
L65:
    dec_ref protocol
    dec_ref balances
    goto L39
L66:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    goto L53
L67:
    dec_ref r57
    dec_ref r61
    goto L53
L68:
    dec_ref r79
    dec_ref r80
    goto L51
L69:
    dec_ref r57
    dec_ref r79
    dec_ref r84
    goto L53
L70:
    dec_ref r57
    dec_ref r79
    dec_ref r85
    goto L53
L71:
    dec_ref r57
    dec_ref protocol
    dec_ref balances
    dec_ref r79
    goto L53
L72:
    dec_ref protocol
    dec_ref balances
    goto L50
L73:
    dec_ref r57
    dec_ref protocol
    dec_ref r79
    goto L53
L74:
    dec_ref r57
    dec_ref r79
    goto L53

def PortfolioBalancesByCategory.__add_____SummableNonNumericMixin_glue(self, other):
    self :: eth_portfolio.typing.PortfolioBalancesByCategory
    other :: eth_portfolio.typing._SummableNonNumericMixin
    r0, r1, r2 :: dict
    r3, r4 :: eth_portfolio.typing._SummableNonNumericMixin
L0:
    inc_ref self
    r0 = cast(dict, self)
    if is_error(r0) goto L5 else goto L1
L1:
    inc_ref other
    r1 = cast(dict, other)
    if is_error(r1) goto L6 else goto L2
L2:
    r2 = PortfolioBalancesByCategory.__add__(r0, r1)
    dec_ref r0
    dec_ref r1
    if is_error(r2) goto L5 else goto L3
L3:
    r3 = cast(eth_portfolio.typing._SummableNonNumericMixin, r2)
    if is_error(r3) goto L5 else goto L4
L4:
    return r3
L5:
    r4 = <error> :: eth_portfolio.typing._SummableNonNumericMixin
    return r4
L6:
    dec_ref r0
    goto L5

def PortfolioBalancesByCategory.__sub__(self, other):
    self, other :: dict
    r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4, r5, r6, r7 :: str
    r8 :: object[3]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: list
    r13, r14, r15 :: ptr
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: union[int, None]
    r26 :: str
    r27 :: object
    r28 :: union[int, None]
    r29 :: object
    r30 :: bool
    r31, r32 :: str
    r33 :: object
    r34 :: union[int, None]
    r35, r36, r37 :: str
    r38 :: object
    r39 :: union[int, None]
    r40, r41, r42 :: str
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48 :: object
    r49 :: str
    r50 :: object
    r51 :: union[int, None]
    r52 :: object
    r53 :: object[2]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: dict
    r58 :: short_int
    r59 :: native_int
    r60 :: short_int
    r61 :: object
    r62 :: tuple[bool, short_int, object, object]
    r63 :: short_int
    r64 :: bool
    r65, r66 :: object
    r67 :: str
    r68 :: eth_portfolio.typing.WalletBalancesRaw
    protocol :: str
    balances :: eth_portfolio.typing.WalletBalancesRaw
    r69, r70 :: object
    r71 :: i32
    r72, r73, r74 :: bit
    r75 :: short_int
    r76 :: native_int
    r77 :: short_int
    r78 :: object
    r79 :: tuple[bool, short_int, object, object]
    r80 :: short_int
    r81 :: bool
    r82, r83 :: object
    r84 :: str
    r85 :: eth_portfolio.typing.WalletBalancesRaw
    r86 :: bool
    r87 :: i32
    r88, r89, r90 :: bit
    r91 :: dict
L0:
    r0 = eth_portfolio.typing.PortfolioBalancesByCategory :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L8 else goto L1 :: bool
L1:
    r4 = ''
    r5 = '{:{}}'
    r6 = ''
    r7 = 'format'
    r8 = [r5, other, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775811, 0)
    if is_error(r10) goto L49 (error at __sub__:1466) else goto L2
L2:
    r11 = ' is not a PortfolioBalancesByCategory object'
    r12 = PyList_New(2)
    if is_error(r12) goto L50 (error at __sub__:1466) else goto L3
L3:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    set_mem r14, r10 :: builtins.object*
    inc_ref r11
    r15 = r14 + 8
    set_mem r15, r11 :: builtins.object*
    r16 = PyUnicode_Join(r4, r12)
    dec_ref r12
    if is_error(r16) goto L49 (error at __sub__:1466) else goto L4
L4:
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L51 (error at __sub__:1466) else goto L5
L5:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L51 (error at __sub__:1466) else goto L6
L6:
    dec_ref r16
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L49 (error at __sub__:1466) else goto L7 :: bool
L7:
    unreachable
L8:
    r23 = 'block'
    r24 = CPyObject_GetAttr(self, r23)
    if is_error(r24) goto L49 (error at __sub__:1467) else goto L9
L9:
    r25 = cast(union[int, None], r24)
    if is_error(r25) goto L49 (error at __sub__:1467) else goto L10
L10:
    r26 = 'block'
    r27 = CPyObject_GetAttr(other, r26)
    if is_error(r27) goto L52 (error at __sub__:1467) else goto L11
L11:
    r28 = cast(union[int, None], r27)
    if is_error(r28) goto L52 (error at __sub__:1467) else goto L12
L12:
    r29 = PyObject_RichCompare(r25, r28, 3)
    dec_ref r25
    dec_ref r28
    if is_error(r29) goto L49 (error at __sub__:1467) else goto L13
L13:
    r30 = unbox(bool, r29)
    dec_ref r29
    if is_error(r30) goto L49 (error at __sub__:1467) else goto L14
L14:
    if r30 goto L15 else goto L26 :: bool
L15:
    r31 = 'These PortfolioBalancesByCategory objects are not from the same block ('
    r32 = 'block'
    r33 = CPyObject_GetAttr(self, r32)
    if is_error(r33) goto L49 (error at __sub__:1469) else goto L16
L16:
    r34 = cast(union[int, None], r33)
    if is_error(r34) goto L49 (error at __sub__:1469) else goto L17
L17:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L49 (error at __sub__:1469) else goto L18
L18:
    r36 = ' and '
    r37 = 'block'
    r38 = CPyObject_GetAttr(other, r37)
    if is_error(r38) goto L53 (error at __sub__:1469) else goto L19
L19:
    r39 = cast(union[int, None], r38)
    if is_error(r39) goto L53 (error at __sub__:1469) else goto L20
L20:
    r40 = PyObject_Str(r39)
    dec_ref r39
    if is_error(r40) goto L53 (error at __sub__:1469) else goto L21
L21:
    r41 = ')'
    r42 = CPyStr_Build(5, r31, r35, r36, r40, r41)
    dec_ref r35
    dec_ref r40
    if is_error(r42) goto L49 (error at __sub__:1469) else goto L22
L22:
    r43 = builtins :: module
    r44 = 'ValueError'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L54 (error at __sub__:1468) else goto L23
L23:
    r46 = [r42]
    r47 = load_address r46
    r48 = _PyObject_Vectorcall(r45, r47, 1, 0)
    dec_ref r45
    if is_error(r48) goto L54 (error at __sub__:1468) else goto L24
L24:
    dec_ref r42
    CPy_Raise(r48)
    dec_ref r48
    if not 0 goto L49 (error at __sub__:1468) else goto L25 :: bool
L25:
    unreachable
L26:
    r49 = 'block'
    r50 = CPyObject_GetAttr(self, r49)
    if is_error(r50) goto L49 (error at __sub__:1473) else goto L27
L27:
    r51 = cast(union[int, None], r50)
    if is_error(r51) goto L49 (error at __sub__:1473) else goto L28
L28:
    r52 = eth_portfolio.typing.PortfolioBalancesByCategory :: type
    r53 = [self, r51]
    r54 = load_address r53
    r55 = ('block',)
    r56 = _PyObject_Vectorcall(r52, r54, 1, r55)
    if is_error(r56) goto L55 (error at __sub__:1472) else goto L29
L29:
    dec_ref r51
    r57 = cast(dict, r56)
    if is_error(r57) goto L49 (error at __sub__:1472) else goto L30
L30:
    r58 = 0
    r59 = PyDict_Size(other)
    r60 = r59 << 1
    r61 = CPyDict_GetItemsIter(other)
    if is_error(r61) goto L56 (error at __sub__:1475) else goto L31
L31:
    r62 = CPyDict_NextItem(r61, r58)
    r63 = r62[1]
    r58 = r63
    r64 = r62[0]
    if r64 goto L32 else goto L57 :: bool
L32:
    r65 = r62[2]
    r66 = r62[3]
    dec_ref r62
    r67 = cast(str, r65)
    if is_error(r67) goto L58 (error at __sub__:1475) else goto L33
L33:
    r68 = cast(eth_portfolio.typing.WalletBalancesRaw, r66)
    if is_error(r68) goto L59 (error at __sub__:1475) else goto L34
L34:
    protocol = r67
    balances = r68
    r69 = CPyDict_GetItem(r57, protocol)
    if is_error(r69) goto L60 (error at __sub__:1476) else goto L35
L35:
    r70 = PyNumber_InPlaceSubtract(r69, balances)
    dec_ref r69
    dec_ref balances
    if is_error(r70) goto L61 (error at __sub__:1476) else goto L36
L36:
    r71 = CPyDict_SetItem(r57, protocol, r70)
    dec_ref protocol
    dec_ref r70
    r72 = r71 >= 0 :: signed
    if not r72 goto L62 (error at __sub__:1476) else goto L37 :: bool
L37:
    r73 = CPyDict_CheckSize(other, r60)
    if not r73 goto L62 (error at __sub__:1475) else goto L31 :: bool
L38:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L56 (error at __sub__:1475) else goto L39 :: bool
L39:
    r75 = 0
    r76 = PyDict_Size(r57)
    r77 = r76 << 1
    r78 = CPyDict_GetItemsIter(r57)
    if is_error(r78) goto L56 (error at __sub__:1477) else goto L40
L40:
    r79 = CPyDict_NextItem(r78, r75)
    r80 = r79[1]
    r75 = r80
    r81 = r79[0]
    if r81 goto L41 else goto L63 :: bool
L41:
    r82 = r79[2]
    r83 = r79[3]
    dec_ref r79
    r84 = cast(str, r82)
    if is_error(r84) goto L64 (error at __sub__:1477) else goto L42
L42:
    r85 = cast(eth_portfolio.typing.WalletBalancesRaw, r83)
    if is_error(r85) goto L65 (error at __sub__:1477) else goto L43
L43:
    protocol = r84
    balances = r85
    r86 = balances.__bool__()
    dec_ref balances
    if is_error(r86) goto L66 (error at __sub__:1475) else goto L44
L44:
    if r86 goto L67 else goto L45 :: bool
L45:
    r87 = PyObject_DelItem(r57, protocol)
    dec_ref protocol
    r88 = r87 >= 0 :: signed
    if not r88 goto L68 (error at __sub__:1479) else goto L46 :: bool
L46:
    r89 = CPyDict_CheckSize(r57, r77)
    if not r89 goto L68 (error at __sub__:1477) else goto L40 :: bool
L47:
    r90 = CPy_NoErrOccurred()
    if not r90 goto L56 (error at __sub__:1477) else goto L48 :: bool
L48:
    return r57
L49:
    r91 = <error> :: dict
    return r91
L50:
    dec_ref r10
    goto L49
L51:
    dec_ref r16
    goto L49
L52:
    dec_ref r25
    goto L49
L53:
    dec_ref r35
    goto L49
L54:
    dec_ref r42
    goto L49
L55:
    dec_ref r51
    goto L49
L56:
    dec_ref r57
    goto L49
L57:
    dec_ref r61
    dec_ref r62
    goto L38
L58:
    dec_ref r57
    dec_ref r61
    dec_ref r66
    goto L49
L59:
    dec_ref r57
    dec_ref r61
    dec_ref r67
    goto L49
L60:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    dec_ref balances
    goto L49
L61:
    dec_ref r57
    dec_ref r61
    dec_ref protocol
    goto L49
L62:
    dec_ref r57
    dec_ref r61
    goto L49
L63:
    dec_ref r78
    dec_ref r79
    goto L47
L64:
    dec_ref r57
    dec_ref r78
    dec_ref r83
    goto L49
L65:
    dec_ref r57
    dec_ref r78
    dec_ref r84
    goto L49
L66:
    dec_ref r57
    dec_ref protocol
    dec_ref r78
    goto L49
L67:
    dec_ref protocol
    goto L46
L68:
    dec_ref r57
    dec_ref r78
    goto L49

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32, r33 :: object
    r34 :: str
    r35 :: dict
    r36 :: object
    r37 :: str
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: dict
    r45 :: str
    r46 :: i32
    r47 :: bit
    r48 :: str
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: object[1]
    r53 :: object_ptr
    r54 :: object
    r55 :: dict
    r56 :: str
    r57 :: i32
    r58 :: bit
    r59 :: str
    r60 :: dict
    r61 :: str
    r62 :: object
    r63 :: object[1]
    r64 :: object_ptr
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: i32
    r69 :: bit
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: dict
    r74 :: str
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: object
    r79 :: tuple[object, object]
    r80, r81 :: object
    r82 :: dict
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: tuple
    r90 :: str
    r91, r92 :: object
    r93 :: bool
    r94, r95, r96, r97, r98 :: str
    r99 :: tuple
    r100 :: i32
    r101 :: bit
    r102 :: dict
    r103 :: str
    r104 :: i32
    r105 :: bit
    r106 :: object
    r107 :: dict
    r108 :: str
    r109 :: i32
    r110 :: bit
    r111 :: dict
    r112 :: str
    r113 :: object
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: dict
    r118 :: str
    r119 :: object
    r120 :: dict
    r121 :: str
    r122, r123 :: object
    r124 :: tuple[object, object]
    r125, r126 :: object
    r127 :: dict
    r128 :: str
    r129 :: i32
    r130 :: bit
    r131 :: str
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: object
    r138 :: object[2]
    r139 :: object_ptr
    r140, r141 :: object
    r142 :: dict
    r143 :: str
    r144 :: i32
    r145 :: bit
    r146 :: object
    r147 :: str
    r148, r149 :: object
    r150 :: bool
    r151 :: str
    r152 :: tuple
    r153 :: i32
    r154 :: bit
    r155 :: dict
    r156 :: str
    r157 :: i32
    r158 :: bit
    r159 :: dict
    r160 :: str
    r161 :: object
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: dict
    r166 :: str
    r167, r168 :: object
    r169 :: tuple[object, object]
    r170, r171 :: object
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: object
    r178 :: dict
    r179 :: str
    r180, r181 :: object
    r182 :: tuple[object, object]
    r183, r184, r185 :: object
    r186 :: tuple[object, object]
    r187, r188 :: object
    r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: dict
    r194 :: str
    r195, r196, r197, r198 :: object
    r199 :: tuple
    r200 :: str
    r201, r202 :: object
    r203 :: bool
    r204, r205 :: str
    r206 :: tuple
    r207 :: i32
    r208 :: bit
    r209 :: dict
    r210 :: str
    r211 :: i32
    r212 :: bit
    r213 :: dict
    r214 :: str
    r215 :: object
    r216 :: dict
    r217 :: str
    r218 :: object
    r219 :: dict
    r220 :: str
    r221, r222 :: object
    r223 :: tuple[object, object]
    r224, r225 :: object
    r226 :: dict
    r227 :: str
    r228 :: object
    r229 :: dict
    r230 :: str
    r231 :: object
    r232 :: dict
    r233 :: str
    r234, r235 :: object
    r236 :: tuple[object, object]
    r237, r238, r239 :: object
    r240 :: tuple[object, object]
    r241, r242 :: object
    r243 :: dict
    r244 :: str
    r245 :: i32
    r246 :: bit
    r247 :: dict
    r248 :: str
    r249 :: object
    r250 :: dict
    r251 :: str
    r252, r253 :: object
    r254 :: tuple[object, object]
    r255, r256, r257 :: object
    r258 :: tuple
    r259 :: str
    r260, r261 :: object
    r262, r263 :: str
    r264 :: tuple
    r265 :: i32
    r266 :: bit
    r267 :: dict
    r268 :: str
    r269 :: i32
    r270 :: bit
    r271 :: dict
    r272 :: str
    r273 :: object
    r274, r275, r276 :: str
    r277 :: tuple[str, str, str]
    r278, r279 :: object
    r280 :: dict
    r281 :: str
    r282 :: i32
    r283 :: bit
    r284 :: dict
    r285 :: str
    r286 :: object
    r287 :: dict
    r288 :: str
    r289 :: object
    r290 :: dict
    r291 :: str
    r292, r293 :: object
    r294 :: tuple[object, object]
    r295, r296 :: object
    r297 :: dict
    r298 :: str
    r299 :: object
    r300 :: dict
    r301 :: str
    r302 :: object
    r303 :: dict
    r304 :: str
    r305, r306 :: object
    r307 :: tuple[object, object]
    r308, r309, r310 :: object
    r311 :: tuple[object, object]
    r312, r313 :: object
    r314 :: dict
    r315 :: str
    r316 :: i32
    r317 :: bit
    r318 :: dict
    r319 :: str
    r320 :: object
    r321 :: dict
    r322 :: str
    r323 :: object
    r324 :: dict
    r325 :: str
    r326, r327, r328 :: object
    r329 :: tuple[object, object]
    r330, r331 :: object
    r332 :: tuple[object, object]
    r333, r334, r335 :: object
    r336 :: tuple
    r337 :: str
    r338, r339 :: object
    r340, r341 :: str
    r342 :: tuple
    r343 :: i32
    r344 :: bit
    r345 :: dict
    r346 :: str
    r347 :: i32
    r348 :: bit
    r349 :: dict
    r350 :: str
    r351 :: object
    r352 :: dict
    r353 :: str
    r354 :: object
    r355 :: dict
    r356 :: str
    r357, r358 :: object
    r359 :: tuple[object, object]
    r360, r361 :: object
    r362 :: dict
    r363 :: str
    r364 :: object
    r365 :: dict
    r366 :: str
    r367 :: object
    r368 :: dict
    r369 :: str
    r370, r371 :: object
    r372 :: tuple[object, object]
    r373, r374, r375 :: object
    r376 :: tuple[object, object]
    r377, r378 :: object
    r379 :: dict
    r380 :: str
    r381 :: i32
    r382 :: bit
    r383 :: dict
    r384 :: str
    r385, r386, r387, r388 :: object
    r389 :: tuple
    r390 :: str
    r391, r392 :: object
    r393 :: bool
    r394, r395 :: str
    r396 :: tuple
    r397 :: i32
    r398 :: bit
    r399 :: dict
    r400 :: str
    r401 :: i32
    r402 :: bit
    r403 :: dict
    r404 :: str
    r405 :: object
    r406 :: dict
    r407 :: str
    r408 :: object
    r409 :: dict
    r410 :: str
    r411, r412 :: object
    r413 :: tuple[object, object]
    r414, r415 :: object
    r416 :: dict
    r417 :: str
    r418 :: object
    r419 :: dict
    r420 :: str
    r421 :: object
    r422 :: dict
    r423 :: str
    r424, r425 :: object
    r426 :: tuple[object, object]
    r427, r428, r429 :: object
    r430 :: tuple[object, object]
    r431, r432 :: object
    r433 :: dict
    r434 :: str
    r435 :: i32
    r436 :: bit
    r437 :: dict
    r438 :: str
    r439, r440, r441, r442 :: object
    r443 :: tuple
    r444 :: str
    r445, r446 :: object
    r447 :: bool
    r448, r449 :: str
    r450 :: tuple
    r451 :: i32
    r452 :: bit
    r453 :: dict
    r454 :: str
    r455 :: i32
    r456 :: bit
    r457 :: dict
    r458 :: str
    r459 :: object
    r460 :: dict
    r461 :: str
    r462 :: object
    r463 :: dict
    r464 :: str
    r465, r466 :: object
    r467 :: tuple[object, object]
    r468, r469 :: object
    r470 :: dict
    r471 :: str
    r472 :: object
    r473 :: dict
    r474 :: str
    r475 :: object
    r476 :: dict
    r477 :: str
    r478, r479 :: object
    r480 :: tuple[object, object]
    r481, r482, r483 :: object
    r484 :: tuple[object, object]
    r485, r486 :: object
    r487 :: dict
    r488 :: str
    r489 :: i32
    r490 :: bit
    r491 :: dict
    r492 :: str
    r493 :: object
    r494 :: dict
    r495 :: str
    r496, r497 :: object
    r498 :: tuple[object, object]
    r499, r500, r501 :: object
    r502 :: tuple
    r503 :: str
    r504, r505 :: object
    r506, r507 :: str
    r508 :: tuple
    r509 :: i32
    r510 :: bit
    r511 :: dict
    r512 :: str
    r513 :: i32
    r514 :: bit
    r515 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L169 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('cached_property',)
    r6 = 'functools'
    r7 = eth_portfolio.typing.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L169 (error at <module>:27) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('Any', 'Callable', 'DefaultDict', 'Dict', 'Iterable', 'List', 'Literal', 'Optional', 'Tuple', 'TypeVar', 'Union', 'final')
    r10 = 'typing'
    r11 = eth_portfolio.typing.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L169 (error at <module>:28) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('DefaultChecksumDict',)
    r14 = 'checksum_dict'
    r15 = eth_portfolio.typing.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L169 (error at <module>:43) else goto L6
L6:
    checksum_dict = r16 :: module
    dec_ref r16
    r17 = ('DictStruct',)
    r18 = 'dictstruct'
    r19 = eth_portfolio.typing.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L169 (error at <module>:44) else goto L7
L7:
    dictstruct = r20 :: module
    dec_ref r20
    r21 = ('BlockNumber', 'ChecksumAddress')
    r22 = 'eth_typing'
    r23 = eth_portfolio.typing.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L169 (error at <module>:45) else goto L8
L8:
    eth_typing = r24 :: module
    dec_ref r24
    r25 = ('DataFrame', 'concat')
    r26 = 'pandas'
    r27 = eth_portfolio.typing.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L169 (error at <module>:46) else goto L9
L9:
    pandas = r28 :: module
    dec_ref r28
    r29 = ('ParamSpec', 'Self')
    r30 = 'typing_extensions'
    r31 = eth_portfolio.typing.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L169 (error at <module>:47) else goto L10
L10:
    typing_extensions = r32 :: module
    dec_ref r32
    r33 = ('Decimal',)
    r34 = 'eth_portfolio._decimal'
    r35 = eth_portfolio.typing.globals :: static
    r36 = CPyImport_ImportFromMany(r34, r33, r33, r35)
    if is_error(r36) goto L169 (error at <module>:49) else goto L11
L11:
    eth_portfolio._decimal = r36 :: module
    dec_ref r36
    r37 = '_T'
    r38 = eth_portfolio.typing.globals :: static
    r39 = 'TypeVar'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L169 (error at <module>:52) else goto L12
L12:
    r41 = [r37]
    r42 = load_address r41
    r43 = _PyObject_Vectorcall(r40, r42, 1, 0)
    dec_ref r40
    if is_error(r43) goto L169 (error at <module>:52) else goto L13
L13:
    r44 = eth_portfolio.typing.globals :: static
    r45 = '_T'
    r46 = CPyDict_SetItem(r44, r45, r43)
    dec_ref r43
    r47 = r46 >= 0 :: signed
    if not r47 goto L169 (error at <module>:52) else goto L14 :: bool
L14:
    r48 = '_I'
    r49 = eth_portfolio.typing.globals :: static
    r50 = 'TypeVar'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L169 (error at <module>:53) else goto L15
L15:
    r52 = [r48]
    r53 = load_address r52
    r54 = _PyObject_Vectorcall(r51, r53, 1, 0)
    dec_ref r51
    if is_error(r54) goto L169 (error at <module>:53) else goto L16
L16:
    r55 = eth_portfolio.typing.globals :: static
    r56 = '_I'
    r57 = CPyDict_SetItem(r55, r56, r54)
    dec_ref r54
    r58 = r57 >= 0 :: signed
    if not r58 goto L169 (error at <module>:53) else goto L17 :: bool
L17:
    r59 = '_P'
    r60 = eth_portfolio.typing.globals :: static
    r61 = 'ParamSpec'
    r62 = CPyDict_GetItem(r60, r61)
    if is_error(r62) goto L169 (error at <module>:54) else goto L18
L18:
    r63 = [r59]
    r64 = load_address r63
    r65 = _PyObject_Vectorcall(r62, r64, 1, 0)
    dec_ref r62
    if is_error(r65) goto L169 (error at <module>:54) else goto L19
L19:
    r66 = eth_portfolio.typing.globals :: static
    r67 = '_P'
    r68 = CPyDict_SetItem(r66, r67, r65)
    dec_ref r65
    r69 = r68 >= 0 :: signed
    if not r69 goto L169 (error at <module>:54) else goto L20 :: bool
L20:
    r70 = eth_portfolio.typing.globals :: static
    r71 = 'Callable'
    r72 = CPyDict_GetItem(r70, r71)
    if is_error(r72) goto L169 (error at <module>:56) else goto L21
L21:
    r73 = eth_portfolio.typing.globals :: static
    r74 = '_P'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L170 (error at <module>:56) else goto L22
L22:
    r76 = eth_portfolio.typing.globals :: static
    r77 = '_T'
    r78 = CPyDict_GetItem(r76, r77)
    if is_error(r78) goto L171 (error at <module>:56) else goto L23
L23:
    r79 = (r75, r78)
    r80 = box(tuple[object, object], r79)
    r81 = PyObject_GetItem(r72, r80)
    dec_ref r72
    dec_ref r80
    if is_error(r81) goto L169 (error at <module>:56) else goto L24
L24:
    r82 = eth_portfolio.typing.globals :: static
    r83 = 'Fn'
    r84 = CPyDict_SetItem(r82, r83, r81)
    dec_ref r81
    r85 = r84 >= 0 :: signed
    if not r85 goto L169 (error at <module>:56) else goto L25 :: bool
L25:
    r86 = eth_portfolio.typing.globals :: static
    r87 = 'DictStruct'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L169 (error at <module>:62) else goto L26
L26:
    r89 = PyTuple_Pack(1, r88)
    dec_ref r88
    if is_error(r89) goto L169 (error at <module>:61) else goto L27
L27:
    r90 = 'eth_portfolio.typing'
    r91 = eth_portfolio.typing.Balance_template :: type
    r92 = CPyType_FromTemplate(r91, r89, r90)
    dec_ref r89
    if is_error(r92) goto L169 (error at <module>:61) else goto L28
L28:
    r93 = Balance_trait_vtable_setup()
    if is_error(r93) goto L172 (error at <module>:-1) else goto L29
L29:
    r94 = '__mypyc_attrs__'
    r95 = 'balance'
    r96 = 'usd_value'
    r97 = 'token'
    r98 = 'block'
    r99 = PyTuple_Pack(4, r95, r96, r97, r98)
    if is_error(r99) goto L172 (error at <module>:61) else goto L30
L30:
    r100 = PyObject_SetAttr(r92, r94, r99)
    dec_ref r99
    r101 = r100 >= 0 :: signed
    if not r101 goto L172 (error at <module>:61) else goto L31 :: bool
L31:
    eth_portfolio.typing.Balance = r92 :: type
    r102 = eth_portfolio.typing.globals :: static
    r103 = 'Balance'
    r104 = CPyDict_SetItem(r102, r103, r92)
    dec_ref r92
    r105 = r104 >= 0 :: signed
    if not r105 goto L169 (error at <module>:61) else goto L32 :: bool
L32:
    r106 = load_address PyUnicode_Type
    r107 = eth_portfolio.typing.globals :: static
    r108 = 'ProtocolLabel'
    r109 = CPyDict_SetItem(r107, r108, r106)
    r110 = r109 >= 0 :: signed
    if not r110 goto L169 (error at <module>:228) else goto L33 :: bool
L33:
    r111 = eth_portfolio.typing.globals :: static
    r112 = 'Union'
    r113 = CPyDict_GetItem(r111, r112)
    if is_error(r113) goto L169 (error at <module>:230) else goto L34
L34:
    r114 = eth_portfolio.typing.globals :: static
    r115 = 'ChecksumAddress'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L173 (error at <module>:230) else goto L35
L35:
    r117 = eth_portfolio.typing.globals :: static
    r118 = 'Iterable'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L174 (error at <module>:230) else goto L36
L36:
    r120 = eth_portfolio.typing.globals :: static
    r121 = 'ChecksumAddress'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L175 (error at <module>:230) else goto L37
L37:
    r123 = PyObject_GetItem(r119, r122)
    dec_ref r119
    dec_ref r122
    if is_error(r123) goto L174 (error at <module>:230) else goto L38
L38:
    r124 = (r116, r123)
    r125 = box(tuple[object, object], r124)
    r126 = PyObject_GetItem(r113, r125)
    dec_ref r113
    dec_ref r125
    if is_error(r126) goto L169 (error at <module>:230) else goto L39
L39:
    r127 = eth_portfolio.typing.globals :: static
    r128 = 'Addresses'
    r129 = CPyDict_SetItem(r127, r128, r126)
    dec_ref r126
    r130 = r129 >= 0 :: signed
    if not r130 goto L169 (error at <module>:230) else goto L40 :: bool
L40:
    r131 = 'TokenAddress'
    r132 = eth_portfolio.typing.globals :: static
    r133 = 'ChecksumAddress'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L169 (error at <module>:231) else goto L41
L41:
    r135 = eth_portfolio.typing.globals :: static
    r136 = 'TypeVar'
    r137 = CPyDict_GetItem(r135, r136)
    if is_error(r137) goto L176 (error at <module>:231) else goto L42
L42:
    r138 = [r131, r134]
    r139 = load_address r138
    r140 = ('bound',)
    r141 = _PyObject_Vectorcall(r137, r139, 1, r140)
    dec_ref r137
    if is_error(r141) goto L176 (error at <module>:231) else goto L43
L43:
    dec_ref r134
    r142 = eth_portfolio.typing.globals :: static
    r143 = 'TokenAddress'
    r144 = CPyDict_SetItem(r142, r143, r141)
    dec_ref r141
    r145 = r144 >= 0 :: signed
    if not r145 goto L169 (error at <module>:231) else goto L44 :: bool
L44:
    r146 = <error> :: object
    r147 = 'eth_portfolio.typing'
    r148 = eth_portfolio.typing._SummableNonNumericMixin_template :: type
    r149 = CPyType_FromTemplate(r148, r146, r147)
    if is_error(r149) goto L169 (error at <module>:234) else goto L45
L45:
    r150 = _SummableNonNumericMixin_trait_vtable_setup()
    if is_error(r150) goto L177 (error at <module>:-1) else goto L46
L46:
    r151 = '__mypyc_attrs__'
    r152 = PyTuple_Pack(0)
    if is_error(r152) goto L177 (error at <module>:234) else goto L47
L47:
    r153 = PyObject_SetAttr(r149, r151, r152)
    dec_ref r152
    r154 = r153 >= 0 :: signed
    if not r154 goto L177 (error at <module>:234) else goto L48 :: bool
L48:
    eth_portfolio.typing._SummableNonNumericMixin = r149 :: type
    r155 = eth_portfolio.typing.globals :: static
    r156 = '_SummableNonNumericMixin'
    r157 = CPyDict_SetItem(r155, r156, r149)
    dec_ref r149
    r158 = r157 >= 0 :: signed
    if not r158 goto L169 (error at <module>:234) else goto L49 :: bool
L49:
    r159 = eth_portfolio.typing.globals :: static
    r160 = 'Union'
    r161 = CPyDict_GetItem(r159, r160)
    if is_error(r161) goto L169 (error at <module>:283) else goto L50
L50:
    r162 = eth_portfolio.typing.globals :: static
    r163 = 'Dict'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L178 (error at <module>:283) else goto L51
L51:
    r165 = eth_portfolio.typing.globals :: static
    r166 = 'ChecksumAddress'
    r167 = CPyDict_GetItem(r165, r166)
    if is_error(r167) goto L179 (error at <module>:283) else goto L52
L52:
    r168 = eth_portfolio.typing.Balance :: type
    inc_ref r168
    r169 = (r167, r168)
    r170 = box(tuple[object, object], r169)
    r171 = PyObject_GetItem(r164, r170)
    dec_ref r164
    dec_ref r170
    if is_error(r171) goto L178 (error at <module>:283) else goto L53
L53:
    r172 = eth_portfolio.typing.globals :: static
    r173 = 'Iterable'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L180 (error at <module>:283) else goto L54
L54:
    r175 = eth_portfolio.typing.globals :: static
    r176 = 'Tuple'
    r177 = CPyDict_GetItem(r175, r176)
    if is_error(r177) goto L181 (error at <module>:283) else goto L55
L55:
    r178 = eth_portfolio.typing.globals :: static
    r179 = 'ChecksumAddress'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L182 (error at <module>:283) else goto L56
L56:
    r181 = eth_portfolio.typing.Balance :: type
    inc_ref r181
    r182 = (r180, r181)
    r183 = box(tuple[object, object], r182)
    r184 = PyObject_GetItem(r177, r183)
    dec_ref r177
    dec_ref r183
    if is_error(r184) goto L181 (error at <module>:283) else goto L57
L57:
    r185 = PyObject_GetItem(r174, r184)
    dec_ref r174
    dec_ref r184
    if is_error(r185) goto L180 (error at <module>:283) else goto L58
L58:
    r186 = (r171, r185)
    r187 = box(tuple[object, object], r186)
    r188 = PyObject_GetItem(r161, r187)
    dec_ref r161
    dec_ref r187
    if is_error(r188) goto L169 (error at <module>:283) else goto L59
L59:
    r189 = eth_portfolio.typing.globals :: static
    r190 = '_TBSeed'
    r191 = CPyDict_SetItem(r189, r190, r188)
    dec_ref r188
    r192 = r191 >= 0 :: signed
    if not r192 goto L169 (error at <module>:283) else goto L60 :: bool
L60:
    r193 = eth_portfolio.typing.globals :: static
    r194 = 'DefaultChecksumDict'
    r195 = CPyDict_GetItem(r193, r194)
    if is_error(r195) goto L169 (error at <module>:286) else goto L61
L61:
    r196 = eth_portfolio.typing.Balance :: type
    r197 = PyObject_GetItem(r195, r196)
    dec_ref r195
    if is_error(r197) goto L169 (error at <module>:286) else goto L62
L62:
    r198 = eth_portfolio.typing._SummableNonNumericMixin :: type
    r199 = PyTuple_Pack(2, r197, r198)
    dec_ref r197
    if is_error(r199) goto L169 (error at <module>:286) else goto L63
L63:
    r200 = 'eth_portfolio.typing'
    r201 = eth_portfolio.typing.TokenBalances_template :: type
    r202 = CPyType_FromTemplate(r201, r199, r200)
    dec_ref r199
    if is_error(r202) goto L169 (error at <module>:286) else goto L64
L64:
    r203 = TokenBalances_trait_vtable_setup()
    if is_error(r203) goto L183 (error at <module>:-1) else goto L65
L65:
    r204 = '__mypyc_attrs__'
    r205 = 'block'
    r206 = PyTuple_Pack(1, r205)
    if is_error(r206) goto L183 (error at <module>:286) else goto L66
L66:
    r207 = PyObject_SetAttr(r202, r204, r206)
    dec_ref r206
    r208 = r207 >= 0 :: signed
    if not r208 goto L183 (error at <module>:286) else goto L67 :: bool
L67:
    eth_portfolio.typing.TokenBalances = r202 :: type
    r209 = eth_portfolio.typing.globals :: static
    r210 = 'TokenBalances'
    r211 = CPyDict_SetItem(r209, r210, r202)
    dec_ref r202
    r212 = r211 >= 0 :: signed
    if not r212 goto L169 (error at <module>:286) else goto L68 :: bool
L68:
    r213 = eth_portfolio.typing.globals :: static
    r214 = 'Union'
    r215 = CPyDict_GetItem(r213, r214)
    if is_error(r215) goto L169 (error at <module>:486) else goto L69
L69:
    r216 = eth_portfolio.typing.globals :: static
    r217 = 'Dict'
    r218 = CPyDict_GetItem(r216, r217)
    if is_error(r218) goto L184 (error at <module>:486) else goto L70
L70:
    r219 = eth_portfolio.typing.globals :: static
    r220 = 'ProtocolLabel'
    r221 = CPyDict_GetItem(r219, r220)
    if is_error(r221) goto L185 (error at <module>:486) else goto L71
L71:
    r222 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r222
    r223 = (r221, r222)
    r224 = box(tuple[object, object], r223)
    r225 = PyObject_GetItem(r218, r224)
    dec_ref r218
    dec_ref r224
    if is_error(r225) goto L184 (error at <module>:486) else goto L72
L72:
    r226 = eth_portfolio.typing.globals :: static
    r227 = 'List'
    r228 = CPyDict_GetItem(r226, r227)
    if is_error(r228) goto L186 (error at <module>:486) else goto L73
L73:
    r229 = eth_portfolio.typing.globals :: static
    r230 = 'Tuple'
    r231 = CPyDict_GetItem(r229, r230)
    if is_error(r231) goto L187 (error at <module>:486) else goto L74
L74:
    r232 = eth_portfolio.typing.globals :: static
    r233 = 'ProtocolLabel'
    r234 = CPyDict_GetItem(r232, r233)
    if is_error(r234) goto L188 (error at <module>:486) else goto L75
L75:
    r235 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r235
    r236 = (r234, r235)
    r237 = box(tuple[object, object], r236)
    r238 = PyObject_GetItem(r231, r237)
    dec_ref r231
    dec_ref r237
    if is_error(r238) goto L187 (error at <module>:486) else goto L76
L76:
    r239 = PyObject_GetItem(r228, r238)
    dec_ref r228
    dec_ref r238
    if is_error(r239) goto L186 (error at <module>:486) else goto L77
L77:
    r240 = (r225, r239)
    r241 = box(tuple[object, object], r240)
    r242 = PyObject_GetItem(r215, r241)
    dec_ref r215
    dec_ref r241
    if is_error(r242) goto L169 (error at <module>:486) else goto L78
L78:
    r243 = eth_portfolio.typing.globals :: static
    r244 = '_RTBSeed'
    r245 = CPyDict_SetItem(r243, r244, r242)
    dec_ref r242
    r246 = r245 >= 0 :: signed
    if not r246 goto L169 (error at <module>:486) else goto L79 :: bool
L79:
    r247 = eth_portfolio.typing.globals :: static
    r248 = 'DefaultDict'
    r249 = CPyDict_GetItem(r247, r248)
    if is_error(r249) goto L169 (error at <module>:489) else goto L80
L80:
    r250 = eth_portfolio.typing.globals :: static
    r251 = 'ProtocolLabel'
    r252 = CPyDict_GetItem(r250, r251)
    if is_error(r252) goto L189 (error at <module>:489) else goto L81
L81:
    r253 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r253
    r254 = (r252, r253)
    r255 = box(tuple[object, object], r254)
    r256 = PyObject_GetItem(r249, r255)
    dec_ref r249
    dec_ref r255
    if is_error(r256) goto L169 (error at <module>:489) else goto L82
L82:
    r257 = eth_portfolio.typing._SummableNonNumericMixin :: type
    r258 = PyTuple_Pack(2, r256, r257)
    dec_ref r256
    if is_error(r258) goto L169 (error at <module>:489) else goto L83
L83:
    r259 = 'eth_portfolio.typing'
    r260 = eth_portfolio.typing.RemoteTokenBalances_template :: type
    r261 = CPyType_FromTemplate(r260, r258, r259)
    dec_ref r258
    if is_error(r261) goto L169 (error at <module>:489) else goto L84
L84:
    r262 = '__mypyc_attrs__'
    r263 = '__dict__'
    r264 = PyTuple_Pack(1, r263)
    if is_error(r264) goto L190 (error at <module>:489) else goto L85
L85:
    r265 = PyObject_SetAttr(r261, r262, r264)
    dec_ref r264
    r266 = r265 >= 0 :: signed
    if not r266 goto L190 (error at <module>:489) else goto L86 :: bool
L86:
    eth_portfolio.typing.RemoteTokenBalances = r261 :: type
    r267 = eth_portfolio.typing.globals :: static
    r268 = 'RemoteTokenBalances'
    r269 = CPyDict_SetItem(r267, r268, r261)
    dec_ref r261
    r270 = r269 >= 0 :: signed
    if not r270 goto L169 (error at <module>:489) else goto L87 :: bool
L87:
    r271 = eth_portfolio.typing.globals :: static
    r272 = 'Literal'
    r273 = CPyDict_GetItem(r271, r272)
    if is_error(r273) goto L169 (error at <module>:674) else goto L88
L88:
    r274 = 'assets'
    r275 = 'debt'
    r276 = 'external'
    inc_ref r274
    inc_ref r275
    inc_ref r276
    r277 = (r274, r275, r276)
    r278 = box(tuple[str, str, str], r277)
    r279 = PyObject_GetItem(r273, r278)
    dec_ref r273
    dec_ref r278
    if is_error(r279) goto L169 (error at <module>:674) else goto L89
L89:
    r280 = eth_portfolio.typing.globals :: static
    r281 = 'CategoryLabel'
    r282 = CPyDict_SetItem(r280, r281, r279)
    dec_ref r279
    r283 = r282 >= 0 :: signed
    if not r283 goto L169 (error at <module>:674) else goto L90 :: bool
L90:
    r284 = eth_portfolio.typing.globals :: static
    r285 = 'Union'
    r286 = CPyDict_GetItem(r284, r285)
    if is_error(r286) goto L169 (error at <module>:676) else goto L91
L91:
    r287 = eth_portfolio.typing.globals :: static
    r288 = 'Dict'
    r289 = CPyDict_GetItem(r287, r288)
    if is_error(r289) goto L191 (error at <module>:676) else goto L92
L92:
    r290 = eth_portfolio.typing.globals :: static
    r291 = 'CategoryLabel'
    r292 = CPyDict_GetItem(r290, r291)
    if is_error(r292) goto L192 (error at <module>:676) else goto L93
L93:
    r293 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r293
    r294 = (r292, r293)
    r295 = box(tuple[object, object], r294)
    r296 = PyObject_GetItem(r289, r295)
    dec_ref r289
    dec_ref r295
    if is_error(r296) goto L191 (error at <module>:676) else goto L94
L94:
    r297 = eth_portfolio.typing.globals :: static
    r298 = 'Iterable'
    r299 = CPyDict_GetItem(r297, r298)
    if is_error(r299) goto L193 (error at <module>:676) else goto L95
L95:
    r300 = eth_portfolio.typing.globals :: static
    r301 = 'Tuple'
    r302 = CPyDict_GetItem(r300, r301)
    if is_error(r302) goto L194 (error at <module>:676) else goto L96
L96:
    r303 = eth_portfolio.typing.globals :: static
    r304 = 'CategoryLabel'
    r305 = CPyDict_GetItem(r303, r304)
    if is_error(r305) goto L195 (error at <module>:676) else goto L97
L97:
    r306 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r306
    r307 = (r305, r306)
    r308 = box(tuple[object, object], r307)
    r309 = PyObject_GetItem(r302, r308)
    dec_ref r302
    dec_ref r308
    if is_error(r309) goto L194 (error at <module>:676) else goto L98
L98:
    r310 = PyObject_GetItem(r299, r309)
    dec_ref r299
    dec_ref r309
    if is_error(r310) goto L193 (error at <module>:676) else goto L99
L99:
    r311 = (r296, r310)
    r312 = box(tuple[object, object], r311)
    r313 = PyObject_GetItem(r286, r312)
    dec_ref r286
    dec_ref r312
    if is_error(r313) goto L169 (error at <module>:676) else goto L100
L100:
    r314 = eth_portfolio.typing.globals :: static
    r315 = '_WBSeed'
    r316 = CPyDict_SetItem(r314, r315, r313)
    dec_ref r313
    r317 = r316 >= 0 :: signed
    if not r317 goto L169 (error at <module>:676) else goto L101 :: bool
L101:
    r318 = eth_portfolio.typing.globals :: static
    r319 = 'Dict'
    r320 = CPyDict_GetItem(r318, r319)
    if is_error(r320) goto L169 (error at <module>:680) else goto L102
L102:
    r321 = eth_portfolio.typing.globals :: static
    r322 = 'CategoryLabel'
    r323 = CPyDict_GetItem(r321, r322)
    if is_error(r323) goto L196 (error at <module>:680) else goto L103
L103:
    r324 = eth_portfolio.typing.globals :: static
    r325 = 'Union'
    r326 = CPyDict_GetItem(r324, r325)
    if is_error(r326) goto L197 (error at <module>:680) else goto L104
L104:
    r327 = eth_portfolio.typing.TokenBalances :: type
    r328 = eth_portfolio.typing.RemoteTokenBalances :: type
    inc_ref r327
    inc_ref r328
    r329 = (r327, r328)
    r330 = box(tuple[object, object], r329)
    r331 = PyObject_GetItem(r326, r330)
    dec_ref r326
    dec_ref r330
    if is_error(r331) goto L197 (error at <module>:680) else goto L105
L105:
    r332 = (r323, r331)
    r333 = box(tuple[object, object], r332)
    r334 = PyObject_GetItem(r320, r333)
    dec_ref r320
    dec_ref r333
    if is_error(r334) goto L169 (error at <module>:680) else goto L106
L106:
    r335 = eth_portfolio.typing._SummableNonNumericMixin :: type
    r336 = PyTuple_Pack(2, r334, r335)
    dec_ref r334
    if is_error(r336) goto L169 (error at <module>:679) else goto L107
L107:
    r337 = 'eth_portfolio.typing'
    r338 = eth_portfolio.typing.WalletBalances_template :: type
    r339 = CPyType_FromTemplate(r338, r336, r337)
    dec_ref r336
    if is_error(r339) goto L169 (error at <module>:679) else goto L108
L108:
    r340 = '__mypyc_attrs__'
    r341 = '__dict__'
    r342 = PyTuple_Pack(1, r341)
    if is_error(r342) goto L198 (error at <module>:679) else goto L109
L109:
    r343 = PyObject_SetAttr(r339, r340, r342)
    dec_ref r342
    r344 = r343 >= 0 :: signed
    if not r344 goto L198 (error at <module>:679) else goto L110 :: bool
L110:
    eth_portfolio.typing.WalletBalances = r339 :: type
    r345 = eth_portfolio.typing.globals :: static
    r346 = 'WalletBalances'
    r347 = CPyDict_SetItem(r345, r346, r339)
    dec_ref r339
    r348 = r347 >= 0 :: signed
    if not r348 goto L169 (error at <module>:679) else goto L111 :: bool
L111:
    r349 = eth_portfolio.typing.globals :: static
    r350 = 'Union'
    r351 = CPyDict_GetItem(r349, r350)
    if is_error(r351) goto L169 (error at <module>:967) else goto L112
L112:
    r352 = eth_portfolio.typing.globals :: static
    r353 = 'Dict'
    r354 = CPyDict_GetItem(r352, r353)
    if is_error(r354) goto L199 (error at <module>:967) else goto L113
L113:
    r355 = eth_portfolio.typing.globals :: static
    r356 = 'ChecksumAddress'
    r357 = CPyDict_GetItem(r355, r356)
    if is_error(r357) goto L200 (error at <module>:967) else goto L114
L114:
    r358 = eth_portfolio.typing.WalletBalances :: type
    inc_ref r358
    r359 = (r357, r358)
    r360 = box(tuple[object, object], r359)
    r361 = PyObject_GetItem(r354, r360)
    dec_ref r354
    dec_ref r360
    if is_error(r361) goto L199 (error at <module>:967) else goto L115
L115:
    r362 = eth_portfolio.typing.globals :: static
    r363 = 'List'
    r364 = CPyDict_GetItem(r362, r363)
    if is_error(r364) goto L201 (error at <module>:967) else goto L116
L116:
    r365 = eth_portfolio.typing.globals :: static
    r366 = 'Tuple'
    r367 = CPyDict_GetItem(r365, r366)
    if is_error(r367) goto L202 (error at <module>:967) else goto L117
L117:
    r368 = eth_portfolio.typing.globals :: static
    r369 = 'ChecksumAddress'
    r370 = CPyDict_GetItem(r368, r369)
    if is_error(r370) goto L203 (error at <module>:967) else goto L118
L118:
    r371 = eth_portfolio.typing.WalletBalances :: type
    inc_ref r371
    r372 = (r370, r371)
    r373 = box(tuple[object, object], r372)
    r374 = PyObject_GetItem(r367, r373)
    dec_ref r367
    dec_ref r373
    if is_error(r374) goto L202 (error at <module>:967) else goto L119
L119:
    r375 = PyObject_GetItem(r364, r374)
    dec_ref r364
    dec_ref r374
    if is_error(r375) goto L201 (error at <module>:967) else goto L120
L120:
    r376 = (r361, r375)
    r377 = box(tuple[object, object], r376)
    r378 = PyObject_GetItem(r351, r377)
    dec_ref r351
    dec_ref r377
    if is_error(r378) goto L169 (error at <module>:967) else goto L121
L121:
    r379 = eth_portfolio.typing.globals :: static
    r380 = '_PBSeed'
    r381 = CPyDict_SetItem(r379, r380, r378)
    dec_ref r378
    r382 = r381 >= 0 :: signed
    if not r382 goto L169 (error at <module>:967) else goto L122 :: bool
L122:
    r383 = eth_portfolio.typing.globals :: static
    r384 = 'DefaultChecksumDict'
    r385 = CPyDict_GetItem(r383, r384)
    if is_error(r385) goto L169 (error at <module>:970) else goto L123
L123:
    r386 = eth_portfolio.typing.WalletBalances :: type
    r387 = PyObject_GetItem(r385, r386)
    dec_ref r385
    if is_error(r387) goto L169 (error at <module>:970) else goto L124
L124:
    r388 = eth_portfolio.typing._SummableNonNumericMixin :: type
    r389 = PyTuple_Pack(2, r387, r388)
    dec_ref r387
    if is_error(r389) goto L169 (error at <module>:970) else goto L125
L125:
    r390 = 'eth_portfolio.typing'
    r391 = eth_portfolio.typing.PortfolioBalances_template :: type
    r392 = CPyType_FromTemplate(r391, r389, r390)
    dec_ref r389
    if is_error(r392) goto L169 (error at <module>:970) else goto L126
L126:
    r393 = PortfolioBalances_trait_vtable_setup()
    if is_error(r393) goto L204 (error at <module>:-1) else goto L127
L127:
    r394 = '__mypyc_attrs__'
    r395 = 'block'
    r396 = PyTuple_Pack(1, r395)
    if is_error(r396) goto L204 (error at <module>:970) else goto L128
L128:
    r397 = PyObject_SetAttr(r392, r394, r396)
    dec_ref r396
    r398 = r397 >= 0 :: signed
    if not r398 goto L204 (error at <module>:970) else goto L129 :: bool
L129:
    eth_portfolio.typing.PortfolioBalances = r392 :: type
    r399 = eth_portfolio.typing.globals :: static
    r400 = 'PortfolioBalances'
    r401 = CPyDict_SetItem(r399, r400, r392)
    dec_ref r392
    r402 = r401 >= 0 :: signed
    if not r402 goto L169 (error at <module>:970) else goto L130 :: bool
L130:
    r403 = eth_portfolio.typing.globals :: static
    r404 = 'Union'
    r405 = CPyDict_GetItem(r403, r404)
    if is_error(r405) goto L169 (error at <module>:1163) else goto L131
L131:
    r406 = eth_portfolio.typing.globals :: static
    r407 = 'Dict'
    r408 = CPyDict_GetItem(r406, r407)
    if is_error(r408) goto L205 (error at <module>:1163) else goto L132
L132:
    r409 = eth_portfolio.typing.globals :: static
    r410 = 'ChecksumAddress'
    r411 = CPyDict_GetItem(r409, r410)
    if is_error(r411) goto L206 (error at <module>:1163) else goto L133
L133:
    r412 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r412
    r413 = (r411, r412)
    r414 = box(tuple[object, object], r413)
    r415 = PyObject_GetItem(r408, r414)
    dec_ref r408
    dec_ref r414
    if is_error(r415) goto L205 (error at <module>:1163) else goto L134
L134:
    r416 = eth_portfolio.typing.globals :: static
    r417 = 'List'
    r418 = CPyDict_GetItem(r416, r417)
    if is_error(r418) goto L207 (error at <module>:1163) else goto L135
L135:
    r419 = eth_portfolio.typing.globals :: static
    r420 = 'Tuple'
    r421 = CPyDict_GetItem(r419, r420)
    if is_error(r421) goto L208 (error at <module>:1163) else goto L136
L136:
    r422 = eth_portfolio.typing.globals :: static
    r423 = 'ChecksumAddress'
    r424 = CPyDict_GetItem(r422, r423)
    if is_error(r424) goto L209 (error at <module>:1163) else goto L137
L137:
    r425 = eth_portfolio.typing.TokenBalances :: type
    inc_ref r425
    r426 = (r424, r425)
    r427 = box(tuple[object, object], r426)
    r428 = PyObject_GetItem(r421, r427)
    dec_ref r421
    dec_ref r427
    if is_error(r428) goto L208 (error at <module>:1163) else goto L138
L138:
    r429 = PyObject_GetItem(r418, r428)
    dec_ref r418
    dec_ref r428
    if is_error(r429) goto L207 (error at <module>:1163) else goto L139
L139:
    r430 = (r415, r429)
    r431 = box(tuple[object, object], r430)
    r432 = PyObject_GetItem(r405, r431)
    dec_ref r405
    dec_ref r431
    if is_error(r432) goto L169 (error at <module>:1163) else goto L140
L140:
    r433 = eth_portfolio.typing.globals :: static
    r434 = '_WTBInput'
    r435 = CPyDict_SetItem(r433, r434, r432)
    dec_ref r432
    r436 = r435 >= 0 :: signed
    if not r436 goto L169 (error at <module>:1163) else goto L141 :: bool
L141:
    r437 = eth_portfolio.typing.globals :: static
    r438 = 'DefaultChecksumDict'
    r439 = CPyDict_GetItem(r437, r438)
    if is_error(r439) goto L169 (error at <module>:1166) else goto L142
L142:
    r440 = eth_portfolio.typing.TokenBalances :: type
    r441 = PyObject_GetItem(r439, r440)
    dec_ref r439
    if is_error(r441) goto L169 (error at <module>:1166) else goto L143
L143:
    r442 = eth_portfolio.typing._SummableNonNumericMixin :: type
    r443 = PyTuple_Pack(2, r441, r442)
    dec_ref r441
    if is_error(r443) goto L169 (error at <module>:1166) else goto L144
L144:
    r444 = 'eth_portfolio.typing'
    r445 = eth_portfolio.typing.WalletBalancesRaw_template :: type
    r446 = CPyType_FromTemplate(r445, r443, r444)
    dec_ref r443
    if is_error(r446) goto L169 (error at <module>:1166) else goto L145
L145:
    r447 = WalletBalancesRaw_trait_vtable_setup()
    if is_error(r447) goto L210 (error at <module>:-1) else goto L146
L146:
    r448 = '__mypyc_attrs__'
    r449 = 'block'
    r450 = PyTuple_Pack(1, r449)
    if is_error(r450) goto L210 (error at <module>:1166) else goto L147
L147:
    r451 = PyObject_SetAttr(r446, r448, r450)
    dec_ref r450
    r452 = r451 >= 0 :: signed
    if not r452 goto L210 (error at <module>:1166) else goto L148 :: bool
L148:
    eth_portfolio.typing.WalletBalancesRaw = r446 :: type
    r453 = eth_portfolio.typing.globals :: static
    r454 = 'WalletBalancesRaw'
    r455 = CPyDict_SetItem(r453, r454, r446)
    dec_ref r446
    r456 = r455 >= 0 :: signed
    if not r456 goto L169 (error at <module>:1166) else goto L149 :: bool
L149:
    r457 = eth_portfolio.typing.globals :: static
    r458 = 'Union'
    r459 = CPyDict_GetItem(r457, r458)
    if is_error(r459) goto L169 (error at <module>:1306) else goto L150
L150:
    r460 = eth_portfolio.typing.globals :: static
    r461 = 'Dict'
    r462 = CPyDict_GetItem(r460, r461)
    if is_error(r462) goto L211 (error at <module>:1307) else goto L151
L151:
    r463 = eth_portfolio.typing.globals :: static
    r464 = 'CategoryLabel'
    r465 = CPyDict_GetItem(r463, r464)
    if is_error(r465) goto L212 (error at <module>:1307) else goto L152
L152:
    r466 = eth_portfolio.typing.WalletBalancesRaw :: type
    inc_ref r466
    r467 = (r465, r466)
    r468 = box(tuple[object, object], r467)
    r469 = PyObject_GetItem(r462, r468)
    dec_ref r462
    dec_ref r468
    if is_error(r469) goto L211 (error at <module>:1307) else goto L153
L153:
    r470 = eth_portfolio.typing.globals :: static
    r471 = 'Iterable'
    r472 = CPyDict_GetItem(r470, r471)
    if is_error(r472) goto L213 (error at <module>:1307) else goto L154
L154:
    r473 = eth_portfolio.typing.globals :: static
    r474 = 'Tuple'
    r475 = CPyDict_GetItem(r473, r474)
    if is_error(r475) goto L214 (error at <module>:1307) else goto L155
L155:
    r476 = eth_portfolio.typing.globals :: static
    r477 = 'CategoryLabel'
    r478 = CPyDict_GetItem(r476, r477)
    if is_error(r478) goto L215 (error at <module>:1307) else goto L156
L156:
    r479 = eth_portfolio.typing.WalletBalancesRaw :: type
    inc_ref r479
    r480 = (r478, r479)
    r481 = box(tuple[object, object], r480)
    r482 = PyObject_GetItem(r475, r481)
    dec_ref r475
    dec_ref r481
    if is_error(r482) goto L214 (error at <module>:1307) else goto L157
L157:
    r483 = PyObject_GetItem(r472, r482)
    dec_ref r472
    dec_ref r482
    if is_error(r483) goto L213 (error at <module>:1307) else goto L158
L158:
    r484 = (r469, r483)
    r485 = box(tuple[object, object], r484)
    r486 = PyObject_GetItem(r459, r485)
    dec_ref r459
    dec_ref r485
    if is_error(r486) goto L169 (error at <module>:1306) else goto L159
L159:
    r487 = eth_portfolio.typing.globals :: static
    r488 = '_CBInput'
    r489 = CPyDict_SetItem(r487, r488, r486)
    dec_ref r486
    r490 = r489 >= 0 :: signed
    if not r490 goto L169 (error at <module>:1306) else goto L160 :: bool
L160:
    r491 = eth_portfolio.typing.globals :: static
    r492 = 'DefaultDict'
    r493 = CPyDict_GetItem(r491, r492)
    if is_error(r493) goto L169 (error at <module>:1312) else goto L161
L161:
    r494 = eth_portfolio.typing.globals :: static
    r495 = 'CategoryLabel'
    r496 = CPyDict_GetItem(r494, r495)
    if is_error(r496) goto L216 (error at <module>:1312) else goto L162
L162:
    r497 = eth_portfolio.typing.WalletBalancesRaw :: type
    inc_ref r497
    r498 = (r496, r497)
    r499 = box(tuple[object, object], r498)
    r500 = PyObject_GetItem(r493, r499)
    dec_ref r493
    dec_ref r499
    if is_error(r500) goto L169 (error at <module>:1312) else goto L163
L163:
    r501 = eth_portfolio.typing._SummableNonNumericMixin :: type
    r502 = PyTuple_Pack(2, r500, r501)
    dec_ref r500
    if is_error(r502) goto L169 (error at <module>:1311) else goto L164
L164:
    r503 = 'eth_portfolio.typing'
    r504 = eth_portfolio.typing.PortfolioBalancesByCategory_template :: type
    r505 = CPyType_FromTemplate(r504, r502, r503)
    dec_ref r502
    if is_error(r505) goto L169 (error at <module>:1311) else goto L165
L165:
    r506 = '__mypyc_attrs__'
    r507 = '__dict__'
    r508 = PyTuple_Pack(1, r507)
    if is_error(r508) goto L217 (error at <module>:1311) else goto L166
L166:
    r509 = PyObject_SetAttr(r505, r506, r508)
    dec_ref r508
    r510 = r509 >= 0 :: signed
    if not r510 goto L217 (error at <module>:1311) else goto L167 :: bool
L167:
    eth_portfolio.typing.PortfolioBalancesByCategory = r505 :: type
    r511 = eth_portfolio.typing.globals :: static
    r512 = 'PortfolioBalancesByCategory'
    r513 = CPyDict_SetItem(r511, r512, r505)
    dec_ref r505
    r514 = r513 >= 0 :: signed
    if not r514 goto L169 (error at <module>:1311) else goto L168 :: bool
L168:
    return 1
L169:
    r515 = <error> :: None
    return r515
L170:
    dec_ref r72
    goto L169
L171:
    dec_ref r72
    dec_ref r75
    goto L169
L172:
    dec_ref r92
    goto L169
L173:
    dec_ref r113
    goto L169
L174:
    dec_ref r113
    dec_ref r116
    goto L169
L175:
    dec_ref r113
    dec_ref r116
    dec_ref r119
    goto L169
L176:
    dec_ref r134
    goto L169
L177:
    dec_ref r149
    goto L169
L178:
    dec_ref r161
    goto L169
L179:
    dec_ref r161
    dec_ref r164
    goto L169
L180:
    dec_ref r161
    dec_ref r171
    goto L169
L181:
    dec_ref r161
    dec_ref r171
    dec_ref r174
    goto L169
L182:
    dec_ref r161
    dec_ref r171
    dec_ref r174
    dec_ref r177
    goto L169
L183:
    dec_ref r202
    goto L169
L184:
    dec_ref r215
    goto L169
L185:
    dec_ref r215
    dec_ref r218
    goto L169
L186:
    dec_ref r215
    dec_ref r225
    goto L169
L187:
    dec_ref r215
    dec_ref r225
    dec_ref r228
    goto L169
L188:
    dec_ref r215
    dec_ref r225
    dec_ref r228
    dec_ref r231
    goto L169
L189:
    dec_ref r249
    goto L169
L190:
    dec_ref r261
    goto L169
L191:
    dec_ref r286
    goto L169
L192:
    dec_ref r286
    dec_ref r289
    goto L169
L193:
    dec_ref r286
    dec_ref r296
    goto L169
L194:
    dec_ref r286
    dec_ref r296
    dec_ref r299
    goto L169
L195:
    dec_ref r286
    dec_ref r296
    dec_ref r299
    dec_ref r302
    goto L169
L196:
    dec_ref r320
    goto L169
L197:
    dec_ref r320
    dec_ref r323
    goto L169
L198:
    dec_ref r339
    goto L169
L199:
    dec_ref r351
    goto L169
L200:
    dec_ref r351
    dec_ref r354
    goto L169
L201:
    dec_ref r351
    dec_ref r361
    goto L169
L202:
    dec_ref r351
    dec_ref r361
    dec_ref r364
    goto L169
L203:
    dec_ref r351
    dec_ref r361
    dec_ref r364
    dec_ref r367
    goto L169
L204:
    dec_ref r392
    goto L169
L205:
    dec_ref r405
    goto L169
L206:
    dec_ref r405
    dec_ref r408
    goto L169
L207:
    dec_ref r405
    dec_ref r415
    goto L169
L208:
    dec_ref r405
    dec_ref r415
    dec_ref r418
    goto L169
L209:
    dec_ref r405
    dec_ref r415
    dec_ref r418
    dec_ref r421
    goto L169
L210:
    dec_ref r446
    goto L169
L211:
    dec_ref r459
    goto L169
L212:
    dec_ref r459
    dec_ref r462
    goto L169
L213:
    dec_ref r459
    dec_ref r469
    goto L169
L214:
    dec_ref r459
    dec_ref r469
    dec_ref r472
    goto L169
L215:
    dec_ref r459
    dec_ref r469
    dec_ref r472
    dec_ref r475
    goto L169
L216:
    dec_ref r493
    goto L169
L217:
    dec_ref r505
    goto L169
